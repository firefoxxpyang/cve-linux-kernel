#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#include "kallsym.h"

/* 测试打印 */
//#define KSYM_TEST


/* 内核定义字符长度 */
#define KSYM_NAME_LEN             128
/* 检查连续内核地址个数 */
#define KSYM_CHECK_NUM            10240
/* 测试打印数据个数，不能超过256个 */
#define KSYM_PRINT_NUM            100
/* token个数 */
#define TOKEN_NUM                 256

/* 存储内核符号表6个相关全局变量 */
unsigned long *kallsyms_addresses;
unsigned long kallsyms_num_syms;
char* kallsyms_names;
unsigned long *kallsyms_markers;
char* kallsyms_token_table;
unsigned short *kallsyms_token_index;

/* 内核符号地址基址 */
unsigned long kallsyms_relative_base;
/* 内核符号地址基于基址的偏移数组 */
unsigned int* kallsyms_offsets;

/*
 * 函数: find_kallsyms
 * 参数: saddr, 存放内核符号表的内存地址; msize, 内存大小
 * 返回: 0, 成功找到内核符号表; -1, 未找到内核符号表
 * 说明: 根据拷贝出来的内核数据，在其中查找内核符号表
 */
int find_kallsyms_relative(void* saddr, int msize)
{
	unsigned long *ulp= NULL;
	unsigned int *uip = NULL;
	unsigned int *prev = NULL;
	unsigned short *usp = NULL;
	int ret = 0;
	int i, n = 0;

#if 0  // 打印所有内容
	printf("========================== start =============================\n");
	ulp = (unsigned long *)saddr;
	for(i = 0; i < msize / sizeof(void*); i++){
		printf("0x%lx [0x%16lx]    ", (unsigned long)ulp, *ulp);
		ulp++;
		if((i+1)%4 == 0)
			printf("\n");
	}
#endif

	/* 1、查找符号表，并确定 kallsyms_offsets 的位置 */
	prev = (unsigned int*)saddr;
	uip = (unsigned int*)((unsigned char*)prev + sizeof(int));
	for(i = 0; i < msize / sizeof(int) - 1; i++){
		if(*uip >= *prev && *uip != 0){
			if(kallsyms_offsets == NULL)
				kallsyms_offsets = uip;
			n++;
		}
		else if(n < KSYM_CHECK_NUM){
			n = 0;
			kallsyms_offsets = NULL;
		}
		else if((n > KSYM_CHECK_NUM) && (*uip == 0)){
#ifdef KSYM_TEST
			printf(">>> [KSYM] The ksym was found, n = %x\n", n);
#endif
			break;
		}
		prev++;
		uip++;
	}
	if(n < KSYM_CHECK_NUM){
		printf(">>> [KSYM] find_kallsyms_relative 没有找到内核符号表\n");
		return -1;
	}

#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_offsets\n", (unsigned long)kallsyms_offsets);
	printf("========================== addr =============================\n");
	uip = kallsyms_offsets;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%x]\n", (unsigned long)uip, *uip);
		uip++;
	}
#endif

	/* 2、查找符号表中 kallsyms_relative_base 的位置以及内容 */
	while(*uip > 0){
		uip++;
	}
	while(*uip == 0){
		uip++;
	}
	kallsyms_relative_base = *(unsigned long*)uip;
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_relative_base = [0x%lx]\n", (unsigned long)uip, kallsyms_relative_base);
#endif

	/* 3、查找符号表中 kallsyms_num_syms 的位置以及内容 */
	ulp = (unsigned long*)((char*)uip + sizeof(long));
	while(*ulp == 0){
		ulp++;
	}
	kallsyms_num_syms = *ulp;
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_num_syms = [%ld], n = [%d]\n", (unsigned long)ulp, kallsyms_num_syms, n);
#endif

	/* 如果前面统计的内核地址个数与读取的符号个数不相同，需要做调整，以此处值为准 */
	if(n != kallsyms_num_syms){
		kallsyms_offsets = (unsigned int*)((char*)kallsyms_offsets - (kallsyms_num_syms - n)*sizeof(int));
		if((void*)kallsyms_offsets < saddr){
			printf(">>> [KSYM] 内核符号表找到，但是拷贝数据位置需要向前移 0x%lx\n", (kallsyms_num_syms - n)*sizeof(int));
			return -1;
		}
#ifdef KSYM_TEST
		else{
			printf(">>> [KSYM] The ksym was found, but the kallsyms_offsets need to be readjusted\n");
			printf(">>> [KSYM] [0x%lx] kallsyms_offsets\n", (unsigned long)kallsyms_offsets);
		}
#endif
	}

	/* 4、查找符号表中 kallsyms_names 的位置 */
	ulp++;
	while(*ulp == 0){
		ulp++;
	}
	kallsyms_names = (char*)ulp;
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_names\n", (unsigned long)kallsyms_names);
	printf("========================== name =============================\n");
	ulp = (unsigned long*)kallsyms_names;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%lx]\n", (unsigned long)ulp, *ulp);
		ulp++;
	}
#endif

	/* 5、查找符号表中 kallsyms_markers 的位置 */
	while(*ulp != 0){
		ulp++;
	}
	while(*ulp == 0){
		ulp++;
	}
	/* kallsyms_markers 第一个数据为0 */
	kallsyms_markers = (unsigned long*)((char*)ulp - sizeof(unsigned long));
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_markers\n", (unsigned long)kallsyms_markers);
	printf("========================== markers =============================\n");
	ulp = kallsyms_markers;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%lx]\n", (unsigned long)ulp, *ulp);
		ulp++;
	}
#endif

	/* 6、查找符号表中 kallsyms_token_table 的位置 */
	ulp = ++kallsyms_markers;
	n = 1;
	while(*ulp > 0){
		ulp++;
		n++;
	}
	while(*ulp == 0){
		ulp++;
	}
	if(n != ((kallsyms_num_syms/TOKEN_NUM) + ((kallsyms_num_syms%TOKEN_NUM)?1:0))){
		printf(">>> [KSYM] kallsyms_markers 位置错误，找到 n = %d, 实际应该 %ld\n", n, (kallsyms_num_syms/TOKEN_NUM + ((kallsyms_num_syms%TOKEN_NUM)?1:0)));
		return -1;
	}
	kallsyms_token_table = (char*)ulp;
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_token_table\n", (unsigned long)kallsyms_token_table);
	printf("========================== table =============================\n");
	ulp = (unsigned long*)kallsyms_token_table;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%lx]\n", (unsigned long)ulp, *ulp);
		ulp++;
	}
#endif

	/* 7、查找符号表中 kallsyms_token_index 的位置 */
	usp = (unsigned short*)kallsyms_token_table;
	while(*usp != 0){
		usp++;
	}
	while(*usp == 0){
		usp++;
	}
	/* kallsyms_token_index 第一个数据为0 */
	kallsyms_token_index = (unsigned short*)((char*)usp - sizeof(unsigned short));
	if((unsigned long)((char*)kallsyms_token_index + TOKEN_NUM*sizeof(short)) > (unsigned long)((char*)saddr + msize)){
		printf(">>> [KSYM] kallsyms_token_index 个数不够，拷贝数据位置需要往后移或者扩大拷贝长度\n");
		return -1;
	}
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_token_index\n", (unsigned long)kallsyms_token_index);
	printf("========================== index =============================\n");
	usp = kallsyms_token_index;
	for(i = 0; i < TOKEN_NUM/*KSYM_PRINT_NUM*/; i++){
		printf(">>> [KSYM] 0x%lx [0x%x]\n", (unsigned long)usp, *usp);
		usp++;
	}
	printf(">>> [KSYM] %lx %lx\n", (unsigned long)((char*)kallsyms_token_index + TOKEN_NUM*sizeof(short)), (unsigned long)((char*)saddr + msize));
#endif

	return 0;
}

/*
 * 函数: find_kallsyms_direct
 * 参数: saddr, 存放内核符号表的内存地址; msize, 内存大小
 * 返回: 0, 成功找到内核符号表; -1, 未找到内核符号表
 * 说明: 根据拷贝出来的内核数据，在其中查找内核符号表
 */
int find_kallsyms_direct(void* saddr, int msize)
{
	unsigned long *ulp= NULL;
	unsigned long *prev = NULL;
	unsigned short *src = NULL;
	unsigned long *ptr = NULL;
	int ret = 0;
	int i, n = 0;

#if 0  // 打印所有内容
	printf("========================== start =============================\n");
	ptr = (unsigned long *)saddr;
	for(i = 0; i < msize / sizeof(void*); i++){
		printf("0x%lx [0x%16lx]    ", (unsigned long)ptr, *ptr);
		ptr++;
		if((i+1)%4 == 0)
			printf("\n");
	}
#endif
	/* 1、查找符号表中 kallsyms_addresses 的位置 */
	prev = (unsigned long*)saddr;
	ulp = (unsigned long*)((unsigned char*)prev + sizeof(long));
	for(i = 0; i < msize / sizeof(long) - 1; i++){
		if(*ulp >= *prev && *ulp > KSYM_CHECK_ADDR){
			if(kallsyms_addresses == NULL)
				kallsyms_addresses = ulp;
			n++;
		}
		else if(n < KSYM_CHECK_NUM){
			n = 0;
			kallsyms_addresses = NULL;
		}
		else if((n > KSYM_CHECK_NUM) && (*ulp < KSYM_CHECK_ADDR)){
#ifdef KSYM_TEST
			printf(">>> [KSYM] The ksym was found, n = %x\n", n);
#endif
			break;
		}
		prev++;
		ulp++;
	}
	if(n < KSYM_CHECK_NUM){
		printf(">>> [KSYM] find_kallsyms_direct 未找到内核符号表\n");
		return -1;
	}

#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_addresses\n", (unsigned long)kallsyms_addresses);
	printf("========================== addr =============================\n");
	ptr = kallsyms_addresses;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
#endif

	/* 2、查找符号表中 kallsyms_num_syms 的位置以及内容 */
	ptr = kallsyms_addresses;
	n = 0;
	while(*ptr > KSYM_CHECK_ADDR){
		ptr++;
		n++;
	}
	while(*ptr == 0){
		ptr++;
	}
	kallsyms_num_syms = *ptr;
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_num_syms = [%ld], n = [%d]\n", (unsigned long)ptr, kallsyms_num_syms, n);
#endif

	/* 如果前面统计的内核地址个数与读取的符号个数不相同，需要做调整，以此处值为准 */
	if(n != kallsyms_num_syms){
		kallsyms_addresses = (unsigned long*)((char*)kallsyms_addresses - (kallsyms_num_syms - n)*sizeof(long));
		if((void*)kallsyms_addresses < saddr){
			printf(">>> [KSYM] 内核符号表找到，但是拷贝数据位置需要向前移 0x%lx\n", (kallsyms_num_syms - n)*sizeof(long));
			return -1;
		}
#ifdef KSYM_TEST
		else{
			printf(">>> [KSYM] 内核符号表已找到，但是需要重新调整kallsyms_addresses\n");
			printf(">>> [KSYM] [0x%lx] kallsyms_offsets\n", (unsigned long)kallsyms_addresses);
		}
#endif
	}

	/* 3、查找符号表中 kallsyms_names 的位置 */
	ptr++;
	while(*ptr == 0){
		ptr++;
	}
	kallsyms_names = (char*)ptr;
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_names\n", (unsigned long)kallsyms_names);
	printf("========================== name =============================\n");
	ptr = (unsigned long*)kallsyms_names;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
#endif

	/* 4、查找符号表中 kallsyms_markers 的位置 */
	while(*ptr != 0){
		ptr++;
	}
	while(*ptr == 0){
		ptr++;
	}
	/* kallsyms_markers 第一个数据为0 */
	kallsyms_markers = (unsigned long*)((char*)ptr - sizeof(long));
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_markers\n", (unsigned long)kallsyms_markers);
	printf("========================== markers =============================\n");
	ptr = kallsyms_markers;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
#endif

	/* 5、查找符号表中 kallsyms_token_table 的位置 */
	while(*ptr != 0 && *ptr < 0x10000000){
		ptr++;
	}
	while(*ptr == 0 || *ptr < 0x10000000){
		ptr++;
	}
	kallsyms_token_table = (char*)ptr;
#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_token_table\n", (unsigned long)kallsyms_token_table);
	printf("========================== table =============================\n");
	ptr = (unsigned long*)kallsyms_token_table;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
#endif

	/* 6、查找符号表中 kallsyms_token_index 的位置 */
	src = (unsigned short*)kallsyms_token_table;
	while(*src != 0){
		src++;
	}
	while(*src == 0){
		src++;
	}
	/* kallsyms_token_index 第一个数据为0 */
	kallsyms_token_index = (unsigned short*)((char*)src - sizeof(unsigned short));
	if((unsigned long)((char*)kallsyms_token_index + TOKEN_NUM*sizeof(short)) > (unsigned long)((char*)saddr + msize)){
		printf(">>> [KSYM] kallsyms_token_index 个数不够，拷贝数据位置需要往后移或者扩大拷贝长度\n");
		return -1;
	}

#ifdef KSYM_TEST
	printf(">>> [KSYM] [0x%lx] kallsyms_token_index\n", (unsigned long)kallsyms_token_index);
	printf("========================== index =============================\n");
	src = kallsyms_token_index;
	for(i = 0; i < KSYM_PRINT_NUM; i++){
		printf(">>> [KSYM] 0x%lx [0x%x]\n", (unsigned long)src, *src);
		src++;
	}
#endif

	return 0;
}

/*
 * 函数: find_kallsyms
 * 参数: saddr, 存放内核符号表的内存地址; msize, 内存大小
 * 返回: 0, 成功找到内核符号表; -1, 未找到内核符号表
 * 说明: 根据拷贝出来的内核数据，在其中查找内核符号表
 */
int find_kallsyms(void* saddr, int msize)
{
	if(!find_kallsyms_direct(saddr, msize)){
		return 0;
	}
	else if(!find_kallsyms_relative(saddr, msize)){
		return 0;
	}

	return -1;
}

/*
 * 函数: kallsyms_sym_address
 * 参数: idx, 内核符号在地址数组中的偏移
 * 返回: 成功返回内核地址，失败返回0
 * 说明: 已知符号在地址数组中的偏移，获取地址
 */
unsigned long kallsyms_sym_address(int idx)
{
	if(idx > kallsyms_num_syms){
		printf(">>> [KSYM] idx = %d greater than kallsyms_num_syms = %ld\n", idx, kallsyms_num_syms);
		return 0;
	}
	if(kallsyms_relative_base > KSYM_CHECK_ADDR){
		return kallsyms_relative_base + (u32)kallsyms_offsets[idx];
	}
	else{
		return kallsyms_addresses[idx];
	}
}

/*
 * 函数: kallsyms_expand_symbol
 * 参数: off，指定符号在数组kallsyms_names中的字节偏移
 *       result，存放解压后的符号名字符串
 *       maxlen，字符串最大长度
 * 返回: 返回下一个符号在数组kallsyms_names中的偏移量
 * 说明: 获取指定符号对应的字符串
 */
unsigned int kallsyms_expand_symbol(unsigned int off, char *result, size_t maxlen)
{
	int len, skipped_first = 0;
	const u8 *tptr, *data;

	/* Get the compressed symbol length from the first symbol byte. 获得sym的首地址 */
	data = (u8*)&kallsyms_names[off];
	/* sym压缩后的长度，第一个字节存放的是字符串长度 */
	len = *data;
	/* 指向压缩串 */
	data++;

	/*
	 * Update the offset to return the offset for the next symbol on
	 * the compressed stream.
	 *
	 * 指向下一个压缩串偏移
	 */
	off += len + 1;

	/*
	 * For every byte on the compressed symbol data, copy the table
	 * entry for that byte.
	 *
	 * 为了解析而设置了数据结构kallsyms_token_table和kallsyms_token_index
	 * kallsyms_token_table记录每个ascii字符的替代串，
	 * kallsyms_token_index记录每个ascii字符的替代串在kallsyms_token_table中的偏移
	 */
	while (len) {
		/* 
		 * 对于*data指向的字符，在token_index查找该字符所代表的解压串偏移，
		 * 并从token_table中找到该解压串
		 */
		tptr = (u8*)&kallsyms_token_table[kallsyms_token_index[*data]];
		data++;
		len--;

		while (*tptr) {
			/* 跳过类型字符，例如t,T */
			if (skipped_first) {
				if (maxlen <= 1)
					goto tail;
				/* 拷贝解压串 */
				*result = *tptr;
				result++;
				maxlen--;
			} else
				skipped_first = 1;
			tptr++;
		}
	}

tail:
	if (maxlen)
		*result = '\0';

	/* Return to offset to the next symbol. 返回下一个压缩串偏移 */
	return off;
}


/*
 * 函数: kallsyms_lookup_name
 * 参数: name，一个字符串格式的内核符号
 * 返回: 该符号对应的内核地址
 * 说明: 根据给定符号（字符串）查找该符号的地址
 */
unsigned long kallsyms_lookup_name(const char *name)
{
	char namebuf[KSYM_NAME_LEN];
	unsigned long i;
	unsigned int off;

	for (i = 0, off = 0; i < kallsyms_num_syms; i++) {
		off = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));
		//printf(">>> [KSYM] namebuf = %s\n", namebuf);
		if (strcmp(namebuf, name) == 0)
			return kallsyms_sym_address(i);
	}

	return 0;
}


unsigned long find_symbol_by_proc_kallsyms(char* symbol)
{
	unsigned long address = 0;
	char buf[1024];

	FILE *ks = fopen("/proc/kallsyms", "r");
	while (NULL != fgets(buf, sizeof(buf), ks)) 
	{
		unsigned long a;
		unsigned char type;
		unsigned n = strlen(symbol);
		char sym[1024];
		sscanf(buf, "%lx %c %s", &a, &type, sym);
		if (!strncmp(sym, symbol, n) && (sym[n]=='.' || !sym[n])) {
			printf( "found %s in /proc/kallsyms", sym);
			address = a;
			break;
		}
	}

	fclose(ks);

	printf("0x%16lx\n", address);

	return address;
}

