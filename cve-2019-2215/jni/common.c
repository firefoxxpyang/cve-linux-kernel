#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <math.h>
#include <sched.h>
#include <pthread.h>
#include <stdbool.h>
#include <ctype.h>

#include <sys/time.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <fcntl.h>

#include <sys/socket.h>
#include <sys/xattr.h>
#include <netinet/ip.h>
#include <linux/types.h>
#include <arpa/inet.h>

#include <sys/system_properties.h>


void *mmap_uaddr;
void *mmap_kaddr;


/*
 * 函数: kernel_read
 * 参数: src, 要读数据的地址; dst, 存放数据的地址; len, 拷贝数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 读取内核数据
 */
#ifndef CONFIG_BYPASS_PAN
int kernel_read(void *src, void *dst, int len)
{
	int result = -1;
	int pipefd[2];

	if (-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_read open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	errno = 0;
	if (write(pipefd[1], src, len) != len) {
		printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	if(read(pipefd[0], dst, len) != len){
		printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
	}

	result = 0;

err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

#else

/*
 * 函数: kernel_read
 * 参数: src, 要读数据的地址; dst, 存放数据的地址; len, 拷贝数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 开启PAN的情况下读取内核数据，其中 src 和 dst 必须是内核地址
 *       mmap_kaddr 和 mmap_uaddr 分别是映射到同一块物理内存的内核地址和用户地址
 */
int kernel_read(void *src, void *dst, int len)
{
	int result = -1;
	int pipefd[2];

	if((!mmap_kaddr || !mmap_uaddr) && ((unsigned long)src < KERNEL_ADDR_START || (unsigned long)dst < KERNEL_ADDR_START)){
		printf(">>> [ERROR] kernel_read failed! mmap_kaddr || mmap_uaddr == NULL\n");
		return -1;
	}

	if (-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_read open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	errno = 0;
	if (write(pipefd[1], src, len) != len) {
		printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	if((unsigned long)dst < KERNEL_ADDR_START){
		if(read(pipefd[0], mmap_kaddr, len) != len){
			printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
		memcpy(dst, mmap_uaddr, len);
	}
	else{
		if(read(pipefd[0], dst, len) != len){
			printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
	}
	result = 0;

err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

#endif


/*
 * 函数: kernel_write
 * 参数: src, 存放数据的地址; dst, 要修改的地址; len, 修改数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 修改内核数据
 */
#ifndef CONFIG_BYPASS_PAN
int kernel_write(void *dst, void *src, int len)
{
	int result = -1;
	int pipefd[2];

	if(-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_write open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	if(write(pipefd[1], src, len) != len){
		printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}
	
	if(read(pipefd[0], dst, len) != len) {
		printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	result = 0;
err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

#else

/*
 * 函数: kernel_write
 * 参数: src, 存放数据的地址; dst, 要修改的地址; len, 修改数据长度
 * 返回: 成功返回0，失败返回-1
 * 说明: 开启PAN的情况下修改内核数据，其中 src 和 dst 必须是内核地址
 *       mmap_kaddr 和 mmap_uaddr 分别是映射到同一块物理内存的内核地址和用户地址
 */
int kernel_write(void *dst, void *src, int len)
{
	int result = -1;
	int pipefd[2];

	if((!mmap_kaddr || !mmap_uaddr) && ((unsigned long)src < KERNEL_ADDR_START || (unsigned long)dst < KERNEL_ADDR_START)){
		printf(">>> [ERROR] kernel_write failed! mmap_kaddr || mmap_uaddr == NULL\n");
		return -1;
	}

	if(-1 == pipe(pipefd)) {
		printf(">>> [ERROR] kernel_write open pipe failed, errno: %d, %s\n", errno, strerror(errno));
		return -1;
	}

	if((unsigned long)src < KERNEL_ADDR_START){
		memcpy(mmap_uaddr, src, len);
		if(write(pipefd[1], mmap_kaddr, len) != len){
			printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
	}
	else{
		if(write(pipefd[1], src, len) != len){
			printf(">>> [ERROR] pipe write failed, errno: %d, %s\n", errno, strerror(errno));
			goto err;
		}
	}

	if(read(pipefd[0], dst, len) != len) {
		printf(">>> [ERROR] pipe read failed, errno: %d, %s\n", errno, strerror(errno));
		goto err;
	}

	result = 0;
err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}
#endif

/* 读取一个 unsigned long 数据 */
unsigned long kernel_read_ulong(void* kaddr)
{
	unsigned long data;
	kernel_read(kaddr, &data, sizeof(data));
	return data;
}

/* 读取一个 unsigned int 数据 */
unsigned int kernel_read_uint(void* kaddr)
{
	unsigned int data;
	kernel_read(kaddr, &data, sizeof(data));
	return data;
}

/* 写一个 unsigned long 数据 */
void kernel_write_ulong(void* kaddr, unsigned long data)
{
	kernel_write(kaddr, &data, sizeof(data));
}

/* 写一个 unsigned int 数据 */
void kernel_write_uint(void* kaddr, unsigned int data)
{
	kernel_write(kaddr, &data, sizeof(data));
}



void message(char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
	putchar('\n');
}

/* 错误打印 */
void error(char* fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fprintf(stderr, ": %s\n", errno ? strerror(errno) : "error");
	errno = 0;
	//exit(1);
}

/* 打印数据 */
void show_bytes(void *buffer, int len)
{
	int i = 0;
	for (; i < len; i++) {
		if ((i % 16 == 0) && (i != 0)) {
			printf("\n");
		}

		if ((i % 8 == 0) && (i % 16 != 0) && (i != 0)) {
			printf("   ");
		}
		printf("%02x ", ((char *)buffer)[i]);
	}
	printf("\n\n");
}

/* 打印数据 */
void show_data_byint(void *buf, int len)
{
	unsigned int *uip = NULL;
	int i = 0;

	uip = (unsigned int*)buf;
	for(i = 0; i < len / sizeof(int); i++){
		printf("%08lx [%8x]    ", (unsigned long)((void*)uip - buf), *uip);
		uip++;
		if((i+1)%4 == 0)
			printf("\n");
	}
}

/* 打印数据 */
void hexdump_memory(unsigned char *buf, size_t byte_count)
{
	unsigned long byte_offset_start = 0;
	unsigned long byte_offset = byte_offset_start;

	if (byte_count % 16)
		error("hexdump_memory called with non-full line");

	for (; byte_offset < byte_offset_start + byte_count; byte_offset += 16) {
		char line[1000];
		char *linep = line;
		linep += sprintf(linep, "%08lx  ", byte_offset);
		for (int i=0; i<16; i++) {
			linep += sprintf(linep, "%02hhx ", (unsigned char)buf[byte_offset + i]);
		}
		linep += sprintf(linep, " |");
		for (int i=0; i<16; i++) {
			char c = buf[byte_offset + i];
			if (isalnum((int)c) || ispunct((int)c) || c == ' ') {
				*(linep++) = c;
			} else {
				*(linep++) = '.';
			}
		}
		linep += sprintf(linep, "|");
		puts(line);
	}
}

int write_buf_to_file(void *buf, int len)
{
	int fp=open("/data/local/tmp/code.txt", O_RDWR);
	if(-1 == fp){
		printf("打开文件失败！\n");
		return -1;
	}
	write(fp, buf, len);
	
	close(fp);//关闭文件

	return 0;
}

int read_file_to_buf(void *buf, int len)
{
	int fp=open("/data/local/tmp/code.txt", O_RDWR);
	if(-1 == fp){
		printf("打开文件失败！\n");
		return -1;
	}
	read(fp, buf, len);
	
	close(fp);//关闭文件

	return 0;
}


/* 获取线程ID */
pid_t gettid(void)
{
	return syscall(SYS_gettid);
}


/* 通过pid获取进程名, pid = getpid() */
int get_name_by_pid(pid_t pid, char *task_name)
{
	char proc_pid_path[1024];
	char buf[1024];
	FILE* fp;

	sprintf(proc_pid_path, "/proc/%d/status", pid);

	fp = fopen(proc_pid_path, "r");
	if(NULL != fp){
		if( fgets(buf, 1024-1, fp)== NULL ){
			fclose(fp);
		}
		fclose(fp);
		sscanf(buf, "%*s %s", task_name);
	}
	return 0;
}


/* 设置当前进程可以创建线程的个数 */
int set_fd_limit(void)
{
	struct rlimit rlim;
	int ret = 0;

	if ((ret = getrlimit(RLIMIT_NOFILE, &rlim)))
	{
		printf("[ERROR] getrlimit failed!\n");
		return ret;
	}

	printf("[MESSG] Changing fd limit from %lu to %lu\n", rlim.rlim_cur, rlim.rlim_max);
	rlim.rlim_cur = rlim.rlim_max;
	if((ret = setrlimit(RLIMIT_NOFILE, &rlim))){
		printf("[ERROR] setrlimit failed!\n");
		return ret;
	}

	return ret;
}

/* 设置当前进程的调度优先级 prio=[-20，19]=[高，低] */
int set_process_priority(int prio)
{
	int ret = 0;

	if((ret = setpriority(PRIO_PROCESS, 0, prio)) == -1){
		printf("[ERROR] setpriority failed!\n");
	}

	return ret;
}

/* 获取当前进程的优先级 */
int get_process_priority(void)
{
	int ret = 0;

	if((ret = getpriority(PRIO_PROCESS, 0)) == -1){
		printf("[ERROR] setpriority failed!\n");
	}

	return ret;
}

/* 将当前进程绑定到编号为num的CPU上执行 */
int bind_cpu(int num)
{
	cpu_set_t mask;

	CPU_ZERO(&mask);
	CPU_SET(num, &mask);
	if(sched_setaffinity(0, sizeof(mask), &mask) < 0){
		printf("[ERROR] Sched_setaffinity failed!\n");
		return -1;
	}

	return 0;
}

/* 获取当前系统运行内存大小 */
int get_mem_info(const char *key, unsigned long *value)
{
	FILE *fp;
	char command[0x100] = { 0 };
	char keyval[0x100] = { 0 };

	sprintf(command, "cat /proc/meminfo | grep '%s:'", key);

	fp = popen(command, "r");
	if (!fp) {
		printf("[ERROR] popen command failed!\n");
		return -1;
	}

	if (!fscanf(fp, "%s %lu", keyval, value)) {
		printf("[ERROR] fscanf get keyval failed!\n");
		pclose(fp);
		return -1;
	}

	pclose(fp);

	return 0;
}

/* 获得系统内核版本信息 */
int get_kernel_info(char *buf)
{
	FILE *fp;
	char command[0x100] = { 0 };

	sprintf(command, "uname -r");

	fp = popen(command, "r");
	if (!fp) {
		printf("[ERROR] popen command failed!\n");
		return -1;
	}

	if (!fscanf(fp, "%s", buf)) {
		printf("[ERROR] fscanf get kernel info failed!\n");
		pclose(fp);
		return -1;
	}

	pclose(fp);

	return 0;
}

/* cat /system/build.prop */
int get_kernel_version()
{
	FILE *fp;
	struct utsname unameBuf;
	int ret;
	char OS[32] = { 0 };
	char version[128] = { 0 };
	int kernelMajor;
	int kernelMinor;
	int kernelPatch;
	char buf[4096];

	fp = fopen("/proc/version", "r");
	if (!fp) {
		ret = uname(&unameBuf);
		if(ret < 0) {
			return -1;
		}
		sscanf(unameBuf.release, "%d.%d", &kernelMajor, &kernelMinor);

	} else {
		fscanf(fp, "%s %s %s", OS, OS, version);
		fclose(fp);
		sscanf(version, "%d.%d", &kernelMajor, &kernelMinor);
		printf("    kernel: %s, %s, %d, %d\n", OS, version, kernelMajor, kernelMinor);
	}

	if (__system_property_get("ro.product.brand", buf) <= 0) {
		return -1;	
	}
	printf("    band: %s, ", buf);
	
	if (__system_property_get("ro.build.version.sdk", buf) <= 0) {
		return -1;	
	}
	printf("sdk: %s, ", buf);
	if (__system_property_get("ro.product.model", buf) <= 0) {
		return -1;	
	}
	printf("model: %s, ", buf);
	if (__system_property_get("ro.product.date", buf) <= 0) {
		return -1;	
	}
	printf("   date: %s, ", buf);
	printf("\n");

	return 0;
}

