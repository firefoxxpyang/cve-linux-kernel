#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <math.h>
#include <sched.h>
#include <pthread.h>
#include <stdbool.h>

#include <sys/time.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <sys/syscall.h>

#include <sys/socket.h>
#include <sys/xattr.h>
#include <netinet/ip.h>
#include <linux/types.h>
#include <arpa/inet.h>


void show_bytes(void *buffer, int len)
{
	int i = 0;
	for (; i < len; i++) {
		if ((i % 16 == 0) && (i != 0)) {
			printf("\n");
		}

		if ((i % 8 == 0) && (i % 16 != 0) && (i != 0)) {
			printf("   ");
		}
		printf("%02x ", ((char *)buffer)[i]);
	}
	printf("\n\n");
}

/* 获取线程ID */
pid_t gettid(void)
{
	return syscall(SYS_gettid);
}

/* 设置当前进程可以创建线程的个数 */
int set_fd_limit(void)
{
        struct rlimit rlim;
        int ret = 0;

        if ((ret = getrlimit(RLIMIT_NOFILE, &rlim)))
        {
                printf("[ERROR] getrlimit failed!\n");
                return ret;
        }

        printf("[MESSG] Changing fd limit from %lu to %lu\n", rlim.rlim_cur, rlim.rlim_max);
        rlim.rlim_cur = rlim.rlim_max;
        if((ret = setrlimit(RLIMIT_NOFILE, &rlim))){
                printf("[ERROR] setrlimit failed!\n");
                return ret;
        }

        return ret;
}

/* 设置当前进程的调度优先级 prio=[-20，19]=[高，低] */
int set_process_priority(int prio)
{
        int ret = 0;

        if((ret = setpriority(PRIO_PROCESS, 0, prio)) == -1){
                printf("[ERROR] setpriority failed!\n");
        }

        return ret;
}

/* 获取当前进程的优先级 */
int get_process_priority(void)
{
        int ret = 0;

        if((ret = getpriority(PRIO_PROCESS, 0)) == -1){
                printf("[ERROR] setpriority failed!\n");
        }

        return ret;
}

/* 将当前进程绑定到编号为num的CPU上执行 */
int bind_cpu(int num)
{
        cpu_set_t mask;

        CPU_ZERO(&mask);
        CPU_SET(num, &mask);
        if(sched_setaffinity(0, sizeof(mask), &mask) < 0){
                printf("[ERROR] Sched_setaffinity failed!\n");
		return -1;
        }

	return 0;
}

/* 获取当前系统运行内存大小 */
int get_mem_info(const char *key, unsigned long *value)
{
	FILE *fp;
	char command[0x100] = { 0 };
	char keyval[0x100] = { 0 };

	sprintf(command, "cat /proc/meminfo | grep '%s:'", key);

	fp = popen(command, "r");
	if (!fp) {
        	printf("[ERROR] popen command failed!\n");
		return -1;
	}

	if (!fscanf(fp, "%s %lu", keyval, value)) {
        	printf("[ERROR] fscanf get keyval failed!\n");
		pclose(fp);
		return -1;
	}

	pclose(fp);

	return 0;
}

/* 获得系统内核版本信息 */
int get_kernel_info(char *buf)
{
	FILE *fp;
	char command[0x100] = { 0 };

	sprintf(command, "uname -r");

	fp = popen(command, "r");
	if (!fp) {
		printf("[ERROR] popen command failed!\n");
		return -1;
	}

	if (!fscanf(fp, "%s", buf)) {
		printf("[ERROR] fscanf get kernel info failed!\n");
		pclose(fp);
		return -1;
	}

	pclose(fp);

	return 0;
}

