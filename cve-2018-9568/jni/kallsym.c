#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#include "kallsym.h"
#include "common.h"

#define KSYM_TEST			0

#define KSYM_NAME_LEN			128
#define KSYM_CHECK_NUM			1024

#define ARRAY_SIZE(x)    		(sizeof(x) / sizeof(*(x)))

typedef unsigned char u8;


unsigned long *kallsyms_addresses;
unsigned long kallsyms_num_syms;
char* kallsyms_names;
unsigned long *kallsyms_markers;
char* kallsyms_token_table;
unsigned short *kallsyms_token_index;

/* 查找内核符号表 */
int find_kallsyms(void* saddr, int msize)
{
	unsigned long *ptr;
	int ret = 0;
	int i, n = 0;

#if 0
	printf("========================== start =============================\n");
	ptr = (unsigned long *)saddr;
	for(i = 0; i < msize / ADDR_BYTE_LEN; i++){
		printf("   >>>>>> 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
#endif
	/* 1、查找符号表中 kallsyms_addresses 的位置 */
	ptr = (unsigned long *)saddr;
	for(i = 0; i < msize / ADDR_BYTE_LEN; i++){
		if(*ptr > KERNEL_ADDR_MARK){
			n++;
#ifdef ARCH_ARM32
			if(*ptr == 0xc0008000 && kallsyms_addresses == NULL)
				kallsyms_addresses = ptr;
#endif
		}
		else{
			n = 0;
#ifdef ARCH_ARM32
			kallsyms_addresses = NULL;
#endif
		}
		if(n > KSYM_CHECK_NUM){
#ifdef ARCH_ARM32
			ptr = kallsyms_addresses;
#endif
			break;
		}
		ptr++;
	}
	if(n < KSYM_CHECK_NUM){
		printf("   未找到内核符号表\n");
		return -1;
	}

#ifndef ARCH_ARM32
	ptr = (unsigned long*)((char*)ptr - KSYM_CHECK_NUM * ADDR_BYTE_LEN);
	kallsyms_addresses = (unsigned long*)ptr;
#endif
	printf("   [0x%lx] kallsyms_addresses\n", (unsigned long)kallsyms_addresses);
#if KSYM_TEST
	printf("========================== addr =============================\n");
	for(i = 0; i < 100; i++){
		printf("   >>>>>> 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
	ptr = (unsigned long*)((char*)ptr - (100 - 1) * ADDR_BYTE_LEN);
#endif

	/* 2、查找符号表中 kallsyms_num_syms 的位置以及内容 */
	n = 0;
	while(*ptr > KERNEL_ADDR_MARK){
		ptr++;
		n++;
	}
	while(*ptr == 0){
		ptr++;
	}
	kallsyms_num_syms = *ptr;
	if(n != kallsyms_num_syms){
		printf("   内核符号表已找到，但是偏移有问题，需要重新调整偏移kern_copy_offset\n");
	}
	printf("   [0x%lx] kallsyms_num_syms = [%ld], n = [%d]\n", (unsigned long)ptr, kallsyms_num_syms, n);

	/* 3、查找符号表中 kallsyms_names 的位置 */
	ptr++;
	while(*ptr == 0){
		ptr++;
	}
	kallsyms_names = (char*)ptr;
	printf("   [0x%lx] kallsyms_names\n", (unsigned long)kallsyms_names);
#if KSYM_TEST
	printf("========================== name =============================\n");
	printf("   %x\n", *kallsyms_names);
	for(i = 0; i < 100; i++){
		printf("   >>>>>> 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
	ptr = (unsigned long*)((char*)ptr - (100 - 1) * ADDR_BYTE_LEN);
#endif

	/* 4、查找符号表中 kallsyms_markers 的位置 */
	while(*ptr != 0){
		ptr++;
	}
	while(*ptr == 0){
		ptr++;
	}
	kallsyms_markers = (unsigned long*)((char*)ptr - 8);
	printf("   [0x%lx] kallsyms_markers\n", (unsigned long)kallsyms_markers);
#if KSYM_TEST
	printf("========================== markers =============================\n");
	printf("   0x%lx\n", *kallsyms_markers);
	for(i = 0; i < 100; i++){
		printf("   >>>>>> 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
	ptr = (unsigned long*)((char*)ptr - (100 - 1) * ADDR_BYTE_LEN);
#endif

	/* 5、查找符号表中 kallsyms_token_table 的位置 */
	while(*ptr != 0){
		ptr++;
	}
	while(*ptr == 0){
		ptr++;
	}
	kallsyms_token_table = (char*)ptr;
	printf("   [0x%lx] kallsyms_token_table\n", (unsigned long)kallsyms_token_table);
#if KSYM_TEST
	printf("========================== table =============================\n");
	printf("%x\n", *kallsyms_token_table);
	for(i = 0; i < 100; i++){
		printf("   >>>>>> 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
	ptr = (unsigned long*)((char*)ptr - (100 - 1) * ADDR_BYTE_LEN);
#endif

	/* 6、查找符号表中 kallsyms_token_index 的位置 */
	while(*ptr != 0){
		ptr++;
	}
	while(*ptr == 0){
		ptr++;
	}
	kallsyms_token_index = (unsigned short*)ptr;
	printf("   [0x%lx] kallsyms_token_index\n", (unsigned long)kallsyms_token_index);
#if KSYM_TEST
	printf("========================== index =============================\n");
	printf("   %x\n", *kallsyms_token_index);
	for(i = 0; i < 100; i++){
		printf("   >>>>>> 0x%lx [0x%lx]\n", (unsigned long)ptr, *ptr);
		ptr++;
	}
#endif

	return 0;
}


static unsigned long kallsyms_sym_address(int idx)
{
	return kallsyms_addresses[idx];
}


static unsigned int kallsyms_expand_symbol(unsigned int off,
					   char *result, size_t maxlen)
{
	int len, skipped_first = 0;
	const u8 *tptr, *data;

	/* Get the compressed symbol length from the first symbol byte. 获得sym的首地址 */
	data = (u8*)&kallsyms_names[off];
	/* sym压缩后的长度，第一个字节存放的是字符串长度 */
	len = *data;
	/* 指向压缩串 */
	data++;

	/*
	 * Update the offset to return the offset for the next symbol on
	 * the compressed stream.
	 *
	 * 指向下一个压缩串偏移
	 */
	off += len + 1;

	/*
	 * For every byte on the compressed symbol data, copy the table
	 * entry for that byte.
	 *
	 * 为了解析而设置了数据结构kallsyms_token_table和kallsyms_token_index
	 * kallsyms_token_table记录每个ascii字符的替代串，
	 * kallsyms_token_index记录每个ascii字符的替代串在kallsyms_token_table中的偏移
	 */
	while (len) {
		/* 
		 * 对于*data指向的字符，在token_index查找该字符所代表的解压串偏移，
		 * 并从token_table中找到该解压串
		 */
		tptr = (u8*)&kallsyms_token_table[kallsyms_token_index[*data]];
		data++;
		len--;

		while (*tptr) {
			/* 跳过类型字符，例如t,T */
			if (skipped_first) {
				if (maxlen <= 1)
					goto tail;
				/* 拷贝解压串 */
				*result = *tptr;
				result++;
				maxlen--;
			} else
				skipped_first = 1;
			tptr++;
		}
	}

tail:
	if (maxlen)
		*result = '\0';

	/* Return to offset to the next symbol. 返回下一个压缩串偏移 */
	return off;
}

/* 根据符号名查找对应地址 */
unsigned long kallsyms_lookup_name(const char *name)
{
	char namebuf[KSYM_NAME_LEN];
	unsigned long i;
	unsigned int off;

	for (i = 0, off = 0; i < kallsyms_num_syms; i++) {
		off = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));

		if (strcmp(namebuf, name) == 0)
			return kallsyms_sym_address(i);
	}
	//return module_kallsyms_lookup_name(name);
	return 0;
}

